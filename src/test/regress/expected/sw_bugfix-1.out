set client_min_messages = error;
SET CLIENT_ENCODING='UTF8';
set current_schema=swtest;
/* invalid data type */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(NAME),ID,CHA,VCH,TEX,DAT,TIM,TIS,PID,PCHA,PVCH,PTEX,PDAT,PTIM,PTIS
FROM TEST_HCB_FQB
START WITH ID=1
CONNECT BY prior ID=PID
ORDER SIBLINGS BY NAME ASC;
  name  | level | connect_by_isleaf |        sys_connect_by_path        | connect_by_root | id  |    cha     | vch | tex |           dat            |   tim    |           tis            | pid |    pcha    | pvch | ptex |           pdat           |   ptim   |           ptis           
--------+-------+-------------------+-----------------------------------+-----------------+-----+------------+-----+-----+--------------------------+----------+--------------------------+-----+------------+------+------+--------------------------+----------+--------------------------
 中国   |     1 |                 0 | |中国                             | 中国            |   1 | a          | a   | a   | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021 |   0 | 0          | 0    | 0    | Tue Dec 12 12:12:12 2000 | 00:00:01 | Tue Dec 12 12:12:12 2000
 安徽省 |     2 |                 1 | |中国|安徽省                      | 中国            |  13 | ac         | ac  | ac  | Fri Jan 01 01:01:02 2021 | 01:01:02 | Fri Jan 01 01:01:02 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 山东省 |     2 |                 1 | |中国|山东省                      | 中国            |  12 | ab         | ab  | ab  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 武汉省 |     2 |                 1 | |中国|武汉省                      | 中国            |  19 | ai         | ai  | ai  | Fri Jan 01 01:01:09 2021 | 01:01:09 | Fri Jan 01 01:01:09 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 江苏省 |     2 |                 0 | |中国|江苏省                      | 中国            |  11 | aa         | aa  | aa  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 南京市 |     3 |                 0 | |中国|江苏省|南京市               | 中国            | 111 | aaa        | aaa | aaa | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 六合区 |     4 |                 1 | |中国|江苏省|南京市|六合区        | 中国            | 129 | abi        | abi | abi | Fri Jan 01 01:01:28 2021 | 01:01:28 | Fri Jan 01 01:01:28 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 建邺区 |     4 |                 1 | |中国|江苏省|南京市|建邺区        | 中国            | 125 | abe        | abe | abe | Fri Jan 01 01:01:24 2021 | 01:01:24 | Fri Jan 01 01:01:24 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 江宁区 |     4 |                 0 | |中国|江苏省|南京市|江宁区        | 中国            | 121 | aba        | aba | aba | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 东山街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|东山街 | 中国            | 131 | aca        | aca | aca | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 横溪街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|横溪街 | 中国            | 139 | aci        | aci | aci | Fri Jan 01 01:01:38 2021 | 01:01:38 | Fri Jan 01 01:01:38 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 江宁街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|江宁街 | 中国            | 136 | acf        | acf | acf | Fri Jan 01 01:01:35 2021 | 01:01:35 | Fri Jan 01 01:01:35 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 汤山街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|汤山街 | 中国            | 133 | acc        | acc | acc | Fri Jan 01 01:01:32 2021 | 01:01:32 | Fri Jan 01 01:01:32 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 淳化街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|淳化街 | 中国            | 134 | acd        | acd | acd | Fri Jan 01 01:01:33 2021 | 01:01:33 | Fri Jan 01 01:01:33 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 湖熟街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|湖熟街 | 中国            | 138 | ach        | ach | ach | Fri Jan 01 01:01:37 2021 | 01:01:37 | Fri Jan 01 01:01:37 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 禄口街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|禄口街 | 中国            | 135 | ace        | ace | ace | Fri Jan 01 01:01:34 2021 | 01:01:34 | Fri Jan 01 01:01:34 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 秣陵街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|秣陵街 | 中国            | 132 | acb        | acb | acb | Fri Jan 01 01:01:31 2021 | 01:01:31 | Fri Jan 01 01:01:31 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 谷里街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|谷里街 | 中国            | 137 | acg        | acg | acg | Fri Jan 01 01:01:36 2021 | 01:01:36 | Fri Jan 01 01:01:36 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 浦口区 |     4 |                 1 | |中国|江苏省|南京市|浦口区        | 中国            | 127 | abg        | abg | abg | Fri Jan 01 01:01:26 2021 | 01:01:26 | Fri Jan 01 01:01:26 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 浦口区 |     4 |                 1 | |中国|江苏省|南京市|浦口区        | 中国            | 128 | abh        | abh | abh | Fri Jan 01 01:01:27 2021 | 01:01:27 | Fri Jan 01 01:01:27 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 玄武区 |     4 |                 1 | |中国|江苏省|南京市|玄武区        | 中国            | 124 | abd        | abd | abd | Fri Jan 01 01:01:23 2021 | 01:01:23 | Fri Jan 01 01:01:23 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 秦淮区 |     4 |                 1 | |中国|江苏省|南京市|秦淮区        | 中国            | 126 | abf        | abf | abf | Fri Jan 01 01:01:25 2021 | 01:01:25 | Fri Jan 01 01:01:25 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 雨花台 |     4 |                 1 | |中国|江苏省|南京市|雨花台        | 中国            | 122 | abb        | abb | abb | Fri Jan 01 01:01:21 2021 | 01:01:21 | Fri Jan 01 01:01:21 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 鼓楼区 |     4 |                 1 | |中国|江苏省|南京市|鼓楼区        | 中国            | 123 | abc        | abc | abc | Fri Jan 01 01:01:22 2021 | 01:01:22 | Fri Jan 01 01:01:22 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 宿迁市 |     3 |                 1 | |中国|江苏省|宿迁市               | 中国            | 112 | aab        | aab | aab | Fri Jan 01 01:01:11 2021 | 01:01:11 | Fri Jan 01 01:01:11 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 常州市 |     3 |                 1 | |中国|江苏省|常州市               | 中国            | 117 | aag        | aag | aag | Fri Jan 01 01:01:16 2021 | 01:01:16 | Fri Jan 01 01:01:16 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 徐州市 |     3 |                 1 | |中国|江苏省|徐州市               | 中国            | 113 | aac        | aac | aac | Fri Jan 01 01:01:12 2021 | 01:01:12 | Fri Jan 01 01:01:12 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 无锡市 |     3 |                 1 | |中国|江苏省|无锡市               | 中国            | 116 | aaf        | aaf | aaf | Fri Jan 01 01:01:15 2021 | 01:01:15 | Fri Jan 01 01:01:15 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 泰州市 |     3 |                 1 | |中国|江苏省|泰州市               | 中国            | 119 | aai        | aai | aai | Fri Jan 01 01:01:18 2021 | 01:01:18 | Fri Jan 01 01:01:18 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 盐城市 |     3 |                 1 | |中国|江苏省|盐城市               | 中国            | 115 | aae        | aae | aae | Fri Jan 01 01:01:14 2021 | 01:01:14 | Fri Jan 01 01:01:14 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 苏州市 |     3 |                 1 | |中国|江苏省|苏州市               | 中国            | 114 | aad        | aad | aad | Fri Jan 01 01:01:13 2021 | 01:01:13 | Fri Jan 01 01:01:13 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 连云港 |     3 |                 1 | |中国|江苏省|连云港               | 中国            | 118 | aah        | aah | aah | Fri Jan 01 01:01:17 2021 | 01:01:17 | Fri Jan 01 01:01:17 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 河北省 |     2 |                 1 | |中国|河北省                      | 中国            |  15 | ae         | ae  | ae  | Fri Jan 01 01:01:05 2021 | 01:01:05 | Fri Jan 01 01:01:05 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 河南省 |     2 |                 1 | |中国|河南省                      | 中国            |  14 | ad         | ad  | ad  | Fri Jan 01 01:01:03 2021 | 01:01:03 | Fri Jan 01 01:01:03 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 湖北省 |     2 |                 1 | |中国|湖北省                      | 中国            |  17 | ag         | ag  | ag  | Fri Jan 01 01:01:07 2021 | 01:01:07 | Fri Jan 01 01:01:07 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 湖南省 |     2 |                 1 | |中国|湖南省                      | 中国            |  16 | af         | af  | af  | Fri Jan 01 01:01:06 2021 | 01:01:06 | Fri Jan 01 01:01:06 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 贵州省 |     2 |                 1 | |中国|贵州省                      | 中国            |  18 | ah         | ah  | ah  | Fri Jan 01 01:01:08 2021 | 01:01:08 | Fri Jan 01 01:01:08 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
(37 rows)

-- invalid use connect_by_root, will treate it as regular column report column does not exists error 
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
ERROR:  column "connect_by_root" does not exist
LINE 1: ...L,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY...
                                                             ^
CONTEXT:  referenced column: connect_by_root
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT name
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
   name   | level | connect_by_isleaf | sys_connect_by_path |   name   
----------+-------+-------------------+---------------------+----------
 第九单元 |     1 |                 1 | |第九单元           | 第九单元
 第八单元 |     1 |                 1 | |第八单元           | 第八单元
(2 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(name)
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
   name   | level | connect_by_isleaf | sys_connect_by_path | connect_by_root 
----------+-------+-------------------+---------------------+-----------------
 第九单元 |     1 |                 1 | |第九单元           | 第九单元
 第八单元 |     1 |                 1 | |第八单元           | 第八单元
(2 rows)

/* Unsupported StartWith Scenarios */
explain(costs off)
select * from test_hcb_ptbc t1 start with t1.id = 11 connect by prior t1.id = t1.pid;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Row Adapter
                       ->  CStore Scan on test_hcb_ptbc t1
                             Filter: (id = 11)
                 ->  Hash Join
                       Hash Cond: (t1.pid = tmp_reuslt."t1@id")
                       ->  Materialize
                             ->  Row Adapter
                                   ->  CStore Scan on test_hcb_ptbc t1
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(15 rows)

select * from test_hcb_ptbc t1 start with t1.id = 11 connect by prior t1.id = t1.pid;
 id  |    cha     | vch  | tex |           dat            |   tim    |           tis            |   name   | pid |    pcha    | pvch | ptex |           pdat           |   ptim   |           ptis           
-----+------------+------+-----+--------------------------+----------+--------------------------+----------+-----+------------+------+------+--------------------------+----------+--------------------------
  11 | aa         |  aa  | aa  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 | 江苏省   |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 111 | aaa        |  aaa | aaa | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021 | 南京市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 121 | aba        |  aba | aba | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021 | 江宁区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 131 | aca        |  aca | aca | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021 | 东山街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 141 | ada        |  ada | ada | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021 | 江南摩卡 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 151 | aea        |  aea | aea | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021 | 江南一楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 161 | afa        |  afa | afa | Fri Jan 01 01:02:50 2021 | 01:02:50 | Fri Jan 01 01:02:50 2021 | 第一单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 162 | afb        |  afb | afb | Fri Jan 01 01:02:51 2021 | 01:02:51 | Fri Jan 01 01:02:51 2021 | 第二单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 163 | afc        |  afc | afc | Fri Jan 01 01:02:52 2021 | 01:02:52 | Fri Jan 01 01:02:52 2021 | 第三单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 164 | afd        |  afd | afd | Fri Jan 01 01:02:53 2021 | 01:02:53 | Fri Jan 01 01:02:53 2021 | 第四单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 165 | afe        |  afe | afe | Fri Jan 01 01:02:54 2021 | 01:02:54 | Fri Jan 01 01:02:54 2021 | 第五单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 166 | aff        |  aff | aff | Fri Jan 01 01:02:55 2021 | 01:02:55 | Fri Jan 01 01:02:55 2021 | 第六单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 167 | afg        |  afg | afg | Fri Jan 01 01:02:56 2021 | 01:02:56 | Fri Jan 01 01:02:56 2021 | 第七单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 168 | afh        |  afh | afh | Fri Jan 01 01:02:57 2021 | 01:02:57 | Fri Jan 01 01:02:57 2021 | 第八单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 169 | afi        |  afi | afi | Fri Jan 01 01:02:58 2021 | 01:02:58 | Fri Jan 01 01:02:58 2021 | 第九单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 152 | aeb        |  aeb | aeb | Fri Jan 01 01:01:51 2021 | 01:01:51 | Fri Jan 01 01:01:51 2021 | 江南二楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 153 | aec        |  aec | aec | Fri Jan 01 01:01:52 2021 | 01:01:52 | Fri Jan 01 01:01:52 2021 | 江南三楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 154 | aed        |  aed | aed | Fri Jan 01 01:01:53 2021 | 01:01:53 | Fri Jan 01 01:01:53 2021 | 江南四楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 155 | aee        |  aee | aee | Fri Jan 01 01:01:54 2021 | 01:01:54 | Fri Jan 01 01:01:54 2021 | 江南五楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 156 | aef        |  aef | aef | Fri Jan 01 01:01:55 2021 | 01:01:55 | Fri Jan 01 01:01:55 2021 | 江南六楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 157 | aeg        |  aeg | aeg | Fri Jan 01 01:01:56 2021 | 01:01:56 | Fri Jan 01 01:01:56 2021 | 江南七楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 158 | aeh        |  aeh | aeh | Fri Jan 01 01:01:57 2021 | 01:01:57 | Fri Jan 01 01:01:57 2021 | 江南八楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 159 | aei        |  aei | aei | Fri Jan 01 01:01:58 2021 | 01:01:58 | Fri Jan 01 01:01:58 2021 | 江南九楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 142 | adb        |  adb | adb | Fri Jan 01 01:01:41 2021 | 01:01:41 | Fri Jan 01 01:01:41 2021 | 四季云顶 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 143 | adc        |  adc | adc | Fri Jan 01 01:01:42 2021 | 01:01:42 | Fri Jan 01 01:01:42 2021 | 盛世江南 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 144 | add        |  add | add | Fri Jan 01 01:01:43 2021 | 01:01:43 | Fri Jan 01 01:01:43 2021 | 七里香都 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 145 | ade        |  ade | ade | Fri Jan 01 01:01:44 2021 | 01:01:44 | Fri Jan 01 01:01:44 2021 | 西山枫林 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 146 | adf        |  adf | adf | Fri Jan 01 01:01:45 2021 | 01:01:45 | Fri Jan 01 01:01:45 2021 | 醉墨小镇 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 147 | adg        |  adg | adg | Fri Jan 01 01:01:46 2021 | 01:01:46 | Fri Jan 01 01:01:46 2021 | 布拉格调 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 148 | adh        |  adh | adh | Fri Jan 01 01:01:47 2021 | 01:01:47 | Fri Jan 01 01:01:47 2021 | 清幽别院 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 149 | adi        |  adi | adi | Fri Jan 01 01:01:48 2021 | 01:01:48 | Fri Jan 01 01:01:48 2021 | 璀璨天城 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 132 | acb        |  acb | acb | Fri Jan 01 01:01:31 2021 | 01:01:31 | Fri Jan 01 01:01:31 2021 | 秣陵街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 133 | acc        |  acc | acc | Fri Jan 01 01:01:32 2021 | 01:01:32 | Fri Jan 01 01:01:32 2021 | 汤山街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 135 | ace        |  ace | ace | Fri Jan 01 01:01:34 2021 | 01:01:34 | Fri Jan 01 01:01:34 2021 | 禄口街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 134 | acd        |  acd | acd | Fri Jan 01 01:01:33 2021 | 01:01:33 | Fri Jan 01 01:01:33 2021 | 淳化街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 136 | acf        |  acf | acf | Fri Jan 01 01:01:35 2021 | 01:01:35 | Fri Jan 01 01:01:35 2021 | 江宁街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 137 | acg        |  acg | acg | Fri Jan 01 01:01:36 2021 | 01:01:36 | Fri Jan 01 01:01:36 2021 | 谷里街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 138 | ach        |  ach | ach | Fri Jan 01 01:01:37 2021 | 01:01:37 | Fri Jan 01 01:01:37 2021 | 湖熟街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 139 | aci        |  aci | aci | Fri Jan 01 01:01:38 2021 | 01:01:38 | Fri Jan 01 01:01:38 2021 | 横溪街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 122 | abb        |  abb | abb | Fri Jan 01 01:01:21 2021 | 01:01:21 | Fri Jan 01 01:01:21 2021 | 雨花台   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 123 | abc        |  abc | abc | Fri Jan 01 01:01:22 2021 | 01:01:22 | Fri Jan 01 01:01:22 2021 | 鼓楼区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 124 | abd        |  abd | abd | Fri Jan 01 01:01:23 2021 | 01:01:23 | Fri Jan 01 01:01:23 2021 | 玄武区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 125 | abe        |  abe | abe | Fri Jan 01 01:01:24 2021 | 01:01:24 | Fri Jan 01 01:01:24 2021 | 建邺区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 126 | abf        |  abf | abf | Fri Jan 01 01:01:25 2021 | 01:01:25 | Fri Jan 01 01:01:25 2021 | 秦淮区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 127 | abg        |  abg | abg | Fri Jan 01 01:01:26 2021 | 01:01:26 | Fri Jan 01 01:01:26 2021 | 浦口区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 128 | abh        |  abh | abh | Fri Jan 01 01:01:27 2021 | 01:01:27 | Fri Jan 01 01:01:27 2021 | 浦口区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 129 | abi        |  abi | abi | Fri Jan 01 01:01:28 2021 | 01:01:28 | Fri Jan 01 01:01:28 2021 | 六合区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 112 | aab        |  aab | aab | Fri Jan 01 01:01:11 2021 | 01:01:11 | Fri Jan 01 01:01:11 2021 | 宿迁市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 113 | aac        |  aac | aac | Fri Jan 01 01:01:12 2021 | 01:01:12 | Fri Jan 01 01:01:12 2021 | 徐州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 114 | aad        |  aad | aad | Fri Jan 01 01:01:13 2021 | 01:01:13 | Fri Jan 01 01:01:13 2021 | 苏州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 115 | aae        |  aae | aae | Fri Jan 01 01:01:14 2021 | 01:01:14 | Fri Jan 01 01:01:14 2021 | 盐城市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 117 | aag        |  aag | aag | Fri Jan 01 01:01:16 2021 | 01:01:16 | Fri Jan 01 01:01:16 2021 | 常州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 116 | aaf        |  aaf | aaf | Fri Jan 01 01:01:15 2021 | 01:01:15 | Fri Jan 01 01:01:15 2021 | 无锡市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 118 | aah        |  aah | aah | Fri Jan 01 01:01:17 2021 | 01:01:17 | Fri Jan 01 01:01:17 2021 | 连云港   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 119 | aai        |  aai | aai | Fri Jan 01 01:01:18 2021 | 01:01:18 | Fri Jan 01 01:01:18 2021 | 泰州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
(55 rows)

SELECT t1.id,t1.pid,t1.name,level FROM test_hcb_ptb t1,test_hcb_ptb t2 WHERE t1.id=t2.id START WITH t1.id=141 CONNECT BY PRIOR t1.id=t1.pid FOR UPDATE OF t2 NOWAIT;
ERROR:  Syntax error found.
LINE 1: ...TART WITH t1.id=141 CONNECT BY PRIOR t1.id=t1.pid FOR UPDATE...
                                                             ^
DETAIL:  FOR UPDATE/SHARE cannot be used with START WITH CONNECT BY clauses
SELECT t1.id, t1.pid,t1.name,level FROM core_066 t1 START WITH id = 117 CONNECT BY PRIOR id=pid FOR UPDATE;
ERROR:  Syntax error found.
LINE 1: ...66 t1 START WITH id = 117 CONNECT BY PRIOR id=pid FOR UPDATE...
                                                             ^
DETAIL:  FOR UPDATE/SHARE cannot be used with START WITH CONNECT BY clauses
/* connect by root scenarios */
select pid x,id,CONNECT_BY_ROOT ID from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | connect_by_rootid 
-----+-----+-------------------
   1 |  11 | 11
  11 | 111 | 11
 111 | 121 | 11
 121 | 131 | 11
 131 | 141 | 11
 141 | 151 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT ID alias_id from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | alias_id 
-----+-----+----------
   1 |  11 | 11
  11 | 111 | 11
 111 | 121 | 11
 121 | 131 | 11
 131 | 141 | 11
 141 | 151 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT t1.ID from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | connect_by_roott1.id 
-----+-----+----------------------
   1 |  11 | 11
  11 | 111 | 11
 111 | 121 | 11
 121 | 131 | 11
 131 | 141 | 11
 141 | 151 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT t1.ID alias_id from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | alias_id 
-----+-----+----------
   1 |  11 | 11
  11 | 111 | 11
 111 | 121 | 11
 121 | 131 | 11
 131 | 141 | 11
 141 | 151 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
(55 rows)

/* connect by union */
explain(costs off) select level as le,t.* from test_hcb_ptb t start with id=141 connect by prior pid=id union (select 1 as lv,t2.* from test_hcb_ptb t2);
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate
   Group By Key: tmp_reuslt.level, tmp_reuslt."t@id", tmp_reuslt."t@cha", tmp_reuslt."t@vch", tmp_reuslt."t@tex", tmp_reuslt."t@dat", tmp_reuslt."t@tim", tmp_reuslt."t@tis", tmp_reuslt."t@name", tmp_reuslt."t@pid", tmp_reuslt."t@pcha", tmp_reuslt."t@pvch", tmp_reuslt."t@ptex", tmp_reuslt."t@pdat", tmp_reuslt."t@ptim", tmp_reuslt."t@ptis"
   ->  Append
         ->  CTE Scan on tmp_reuslt
               CTE tmp_reuslt
                 ->  StartWith Operator
                       Start With pseudo atts: RUITR, array_key_9
                       ->  Recursive Union
                             ->  Seq Scan on test_hcb_ptb t
                                   Filter: (id = 141)
                             ->  Hash Join
                                   Hash Cond: (t.id = tmp_reuslt."t@pid")
                                   ->  Seq Scan on test_hcb_ptb t
                                   ->  Hash
                                         ->  WorkTable Scan on tmp_reuslt
         ->  Seq Scan on test_hcb_ptb t2
(16 rows)

/* infinite loop issues */
SELECT LEVEL,NAME,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME, '/'),CONNECT_BY_ROOT(ID)
FROM test_swcb_a
START WITH ID='00118'
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY NAME;
ERROR:  START WITH .. CONNECT BY statement runs into cycle exception
/* fromlist startwith for single table  */
select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id start with t1.id=1 CONNECT BY PRIOR t1.id = t1.pid;
 id | vch | pid | name | ptex 
----+-----+-----+------+------
(0 rows)

explain (costs off) select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id start with t1.id=1 CONNECT BY PRIOR t1.id = t1.pid;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Nested Loop
                       ->  Seq Scan on test_hcb_fqb t1
                             Filter: (id = 1)
                       ->  Seq Scan on test_sublink t2
                             Filter: (id = 1)
                 ->  Hash Join
                       Hash Cond: (t2.id = t1.id)
                       ->  Seq Scan on test_sublink t2
                       ->  Hash
                             ->  Hash Join
                                   Hash Cond: (tmp_reuslt."t1@id" = t1.pid)
                                   ->  WorkTable Scan on tmp_reuslt
                                   ->  Hash
                                         ->  Seq Scan on test_hcb_fqb t1
(19 rows)

CREATE OR REPLACE FUNCTION test_hcb_pro1(i_id in int) return int
AS
o_out int;
BEGIN
select count(*) into o_out from TEST_HCB_FQB t1 START WITH t1.id = i_id
CONNECT BY PRIOR t1.id = t1.pid;
return o_out;
END;
/
select test_hcb_pro1(11);
 test_hcb_pro1 
---------------
            28
(1 row)

drop PROCEDURE test_hcb_pro1;
/* startwith dealing with subqueries */
select tt.id,tt.name from (select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id) tt
start with tt.id=1 CONNECT BY PRIOR tt.id = tt.pid ;
 id | name 
----+------
(0 rows)

explain (costs off) select tt.id,tt.name from (select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id) tt
start with tt.id=1 CONNECT BY PRIOR tt.id = tt.pid ;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Nested Loop
                       ->  Seq Scan on test_hcb_fqb t1
                             Filter: (id = 1)
                       ->  Seq Scan on test_sublink t2
                             Filter: (id = 1)
                 ->  Hash Join
                       Hash Cond: (t2.id = t1.id)
                       ->  Seq Scan on test_sublink t2
                       ->  Hash
                             ->  Hash Join
                                   Hash Cond: (tmp_reuslt."tt@id" = t1.pid)
                                   ->  WorkTable Scan on tmp_reuslt
                                   ->  Hash
                                         ->  Seq Scan on test_hcb_fqb t1
(19 rows)

select test.id,test.pid,test.name
from
(select t1.id id, t1.pid pid, t1.name name from TEST_HCB_FQB t1
 union
 select t2.id id, t2.pid pid, t2.name name from TEST_HCB_FQB t2) test
start with test.id = 12
connect by prior test.id = test.pid;
 id | pid |  name  
----+-----+--------
 12 |   1 | 山东省
(1 row)

/* startwith dealing with subqueries without alias  */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY NAME;
   name   | level | connect_by_isleaf | connect_by_root | sys_connect_by_path 
----------+-------+-------------------+-----------------+---------------------
 第七单元 |     1 |                 1 | 第七单元        | /第七单元
 第九单元 |     1 |                 1 | 第九单元        | /第九单元
 第八单元 |     1 |                 1 | 第八单元        | /第八单元
(3 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1;
   name   | level | connect_by_isleaf | connect_by_root | sys_connect_by_path 
----------+-------+-------------------+-----------------+---------------------
 第七单元 |     1 |                 1 | 第七单元        | /第七单元
 第九单元 |     1 |                 1 | 第九单元        | /第九单元
 第八单元 |     1 |                 1 | 第八单元        | /第八单元
(3 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 999;
ERROR:  Order siblings by tlistIdx 999 exceed length of targetList.
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1, LEVEL;
ERROR:  Siblings sort entry not found
DETAIL:  Column level not found or not allowed here
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1, HUAWEI;
ERROR:  Siblings sort entry not found
DETAIL:  Column huawei not found or not allowed here
/* check siblings ordering */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(NAME)
FROM test_hcb_ptb
START WITH (ID=168 or ID=169)
CONNECT BY ID = PRIOR PID
ORDER SIBLINGS BY NAME ASC;
   name   | level | connect_by_isleaf |                     sys_connect_by_path                      | connect_by_root 
----------+-------+-------------------+--------------------------------------------------------------+-----------------
 第九单元 |     1 |                 0 | |第九单元                                                    | 第九单元
 江南一楼 |     2 |                 0 | |第九单元|江南一楼                                           | 第九单元
 江南摩卡 |     3 |                 0 | |第九单元|江南一楼|江南摩卡                                  | 第九单元
 东山街   |     4 |                 0 | |第九单元|江南一楼|江南摩卡|东山街                           | 第九单元
 江宁区   |     5 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区                    | 第九单元
 南京市   |     6 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市             | 第九单元
 江苏省   |     7 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省      | 第九单元
 中国     |     8 |                 1 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省|中国 | 第九单元
 第八单元 |     1 |                 0 | |第八单元                                                    | 第八单元
 江南一楼 |     2 |                 0 | |第八单元|江南一楼                                           | 第八单元
 江南摩卡 |     3 |                 0 | |第八单元|江南一楼|江南摩卡                                  | 第八单元
 东山街   |     4 |                 0 | |第八单元|江南一楼|江南摩卡|东山街                           | 第八单元
 江宁区   |     5 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区                    | 第八单元
 南京市   |     6 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市             | 第八单元
 江苏省   |     7 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省      | 第八单元
 中国     |     8 |                 1 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省|中国 | 第八单元
(16 rows)

-- connect_by_root/sys_connect_by_path() unsupported cases
explain
SELECT *, LEVEL, connect_by_isleaf, connect_by_iscycle, connect_by_root name_desc, sys_connect_by_path(level, '@')
FROM test_area
START WITH name = '中国'
CONNECT BY PRIOR id = fatherid;
ERROR:  only base table column can be specified in connect_by_root/sys_connect_by_path()
-- sys_connect_by_path() only supports char type
explain
SELECT *, LEVEL, connect_by_isleaf, connect_by_iscycle, connect_by_root name_desc, sys_connect_by_path(id, '@')
FROM test_area
START WITH name = '中国'
CONNECT BY PRIOR id = fatherid;
ERROR:  only text type(CHAR/VARCHAR/NVARCHAR2/TEXT) is allow for sys_connect_by_path()
/* sys_connect_by_path & connect_by_root can support char(xx) */
SELECT name,LEVEL,connect_by_root(CHA)
FROM test_hcb_fqb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
  name  | level | connect_by_root 
--------+-------+-----------------
 中国   |     1 | a         
 江苏省 |     2 | a         
 山东省 |     2 | a         
 安徽省 |     2 | a         
 河南省 |     2 | a         
 河北省 |     2 | a         
 湖南省 |     2 | a         
 湖北省 |     2 | a         
 贵州省 |     2 | a         
 武汉省 |     2 | a         
 南京市 |     3 | a         
 宿迁市 |     3 | a         
 徐州市 |     3 | a         
 苏州市 |     3 | a         
 盐城市 |     3 | a         
 无锡市 |     3 | a         
 常州市 |     3 | a         
 连云港 |     3 | a         
 泰州市 |     3 | a         
 江宁区 |     4 | a         
 雨花台 |     4 | a         
 鼓楼区 |     4 | a         
 玄武区 |     4 | a         
 建邺区 |     4 | a         
 秦淮区 |     4 | a         
 浦口区 |     4 | a         
 浦口区 |     4 | a         
 六合区 |     4 | a         
 东山街 |     5 | a         
 秣陵街 |     5 | a         
 汤山街 |     5 | a         
 淳化街 |     5 | a         
 禄口街 |     5 | a         
 江宁街 |     5 | a         
 谷里街 |     5 | a         
 湖熟街 |     5 | a         
 横溪街 |     5 | a         
(37 rows)

SELECT name,level,connect_by_root t1.cha as cha_col
FROM test_hcb_fqb t1
START WITH id = 1
CONNECT BY PRIOR cha = pcha
ORDER BY id ASC;
  name  | level |  cha_col   
--------+-------+------------
 中国   |     1 | a         
 江苏省 |     2 | a         
 山东省 |     2 | a         
 安徽省 |     2 | a         
 河南省 |     2 | a         
 河北省 |     2 | a         
 湖南省 |     2 | a         
 湖北省 |     2 | a         
 贵州省 |     2 | a         
 武汉省 |     2 | a         
 南京市 |     3 | a         
 宿迁市 |     3 | a         
 徐州市 |     3 | a         
 苏州市 |     3 | a         
 盐城市 |     3 | a         
 无锡市 |     3 | a         
 常州市 |     3 | a         
 连云港 |     3 | a         
 泰州市 |     3 | a         
 江宁区 |     4 | a         
 雨花台 |     4 | a         
 鼓楼区 |     4 | a         
 玄武区 |     4 | a         
 建邺区 |     4 | a         
 秦淮区 |     4 | a         
 浦口区 |     4 | a         
 浦口区 |     4 | a         
 六合区 |     4 | a         
 东山街 |     5 | a         
 秣陵街 |     5 | a         
 汤山街 |     5 | a         
 淳化街 |     5 | a         
 禄口街 |     5 | a         
 江宁街 |     5 | a         
 谷里街 |     5 | a         
 湖熟街 |     5 | a         
 横溪街 |     5 | a         
(37 rows)

SELECT name,LEVEL,sys_connect_by_path(CHA, '==》')
FROM test_hcb_fqb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
  name  | level |                        sys_connect_by_path                        
--------+-------+-------------------------------------------------------------------
 中国   |     1 | ==》a         
 江苏省 |     2 | ==》a         ==》aa        
 山东省 |     2 | ==》a         ==》ab        
 安徽省 |     2 | ==》a         ==》ac        
 河南省 |     2 | ==》a         ==》ad        
 河北省 |     2 | ==》a         ==》ae        
 湖南省 |     2 | ==》a         ==》af        
 湖北省 |     2 | ==》a         ==》ag        
 贵州省 |     2 | ==》a         ==》ah        
 武汉省 |     2 | ==》a         ==》ai        
 南京市 |     3 | ==》a         ==》aa        ==》aaa       
 宿迁市 |     3 | ==》a         ==》aa        ==》aab       
 徐州市 |     3 | ==》a         ==》aa        ==》aac       
 苏州市 |     3 | ==》a         ==》aa        ==》aad       
 盐城市 |     3 | ==》a         ==》aa        ==》aae       
 无锡市 |     3 | ==》a         ==》aa        ==》aaf       
 常州市 |     3 | ==》a         ==》aa        ==》aag       
 连云港 |     3 | ==》a         ==》aa        ==》aah       
 泰州市 |     3 | ==》a         ==》aa        ==》aai       
 江宁区 |     4 | ==》a         ==》aa        ==》aaa       ==》aba       
 雨花台 |     4 | ==》a         ==》aa        ==》aaa       ==》abb       
 鼓楼区 |     4 | ==》a         ==》aa        ==》aaa       ==》abc       
 玄武区 |     4 | ==》a         ==》aa        ==》aaa       ==》abd       
 建邺区 |     4 | ==》a         ==》aa        ==》aaa       ==》abe       
 秦淮区 |     4 | ==》a         ==》aa        ==》aaa       ==》abf       
 浦口区 |     4 | ==》a         ==》aa        ==》aaa       ==》abg       
 浦口区 |     4 | ==》a         ==》aa        ==》aaa       ==》abh       
 六合区 |     4 | ==》a         ==》aa        ==》aaa       ==》abi       
 东山街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》aca       
 秣陵街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acb       
 汤山街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acc       
 淳化街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acd       
 禄口街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》ace       
 江宁街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acf       
 谷里街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acg       
 湖熟街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》ach       
 横溪街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》aci       
(37 rows)

/* empty delimiter in sys_connect_by_path(VCH,'') should be rejected */
SELECT name,LEVEL,sys_connect_by_path(VCH,'')
FROM test_hcb_ptb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
ERROR:  illegal parameter in SYS_CONNECT_BY_PATH function
CONTEXT:  referenced column: sys_connect_by_path
/* start with null must not cause core-dump error */
SELECT *
FROM test_hcb_ptb
START WITH NULL
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
 id | cha | vch | tex | dat | tim | tis | name | pid | pcha | pvch | ptex | pdat | ptim | ptis 
----+-----+-----+-----+-----+-----+-----+------+-----+------+------+------+------+------+------
(0 rows)

/* start with pbe */
PREPARE sthpt(int) AS SELECT t1.id,t1.pid,t1.name FROM test_hcb_ptb t1 START WITH id = $1 CONNECT BY PRIOR pid=id;
EXECUTE sthpt(141);
 id  | pid |   name   
-----+-----+----------
 141 | 131 | 江南摩卡
 131 | 121 | 东山街
 121 | 111 | 江宁区
 111 |  11 | 南京市
  11 |   1 | 江苏省
   1 |   0 | 中国
(6 rows)

/* with-clause used in startwith rewrite */
explain (costs off) with subquery (id,pid,name) as
(
select t1.id,t1.pid,t1.name, LEVEL from test_hcb_ptb t1 where level>=1
    start with id = 141 connect by prior pid=id
)
select t1.id,t1.pid,t1.name,LEVEL from subquery t1
start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union
                 ->  CTE Scan on tmp_reuslt
                       Filter: ((level >= 1) AND ("t1@id" = 141))
                       CTE tmp_reuslt
                         ->  StartWith Operator
                               Start With pseudo atts: RUITR, array_key_9
                               ->  Recursive Union
                                     ->  Seq Scan on test_hcb_ptb t1
                                           Filter: (id = 141)
                                     ->  Hash Join
                                           Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                                           ->  Seq Scan on test_hcb_ptb t1
                                           ->  Hash
                                                 ->  WorkTable Scan on tmp_reuslt
                 ->  Hash Join
                       Hash Cond: (tmp_reuslt."t1@id" = tmp_reuslt."t1@pid")
                       ->  Materialize
                             ->  CTE Scan on tmp_reuslt
                                   Filter: (level >= 1)
                                   CTE tmp_reuslt
                                     ->  StartWith Operator
                                           Start With pseudo atts: RUITR, array_key_9
                                           ->  Recursive Union
                                                 ->  Seq Scan on test_hcb_ptb t1
                                                       Filter: (id = 141)
                                                 ->  Hash Join
                                                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                                                       ->  Seq Scan on test_hcb_ptb t1
                                                       ->  Hash
                                                             ->  WorkTable Scan on tmp_reuslt
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(36 rows)

explain (costs off) select t1.id,t1.pid,t1.name,LEVEL
from (select t2.id,t2.pid,t2.name,LEVEL from test_hcb_ptb t2 where level>=1 start with t2.id = 141 connect by prior pid=id) t1
where level>=1 start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   Filter: (level >= 1)
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union
                 ->  CTE Scan on tmp_reuslt
                       Filter: ((level >= 1) AND ("t2@id" = 141))
                       CTE tmp_reuslt
                         ->  StartWith Operator
                               Start With pseudo atts: RUITR, array_key_9
                               ->  Recursive Union
                                     ->  Seq Scan on test_hcb_ptb t2
                                           Filter: (id = 141)
                                     ->  Hash Join
                                           Hash Cond: (t2.id = tmp_reuslt."t2@pid")
                                           ->  Seq Scan on test_hcb_ptb t2
                                           ->  Hash
                                                 ->  WorkTable Scan on tmp_reuslt
                 ->  Hash Join
                       Hash Cond: (tmp_reuslt."t2@id" = tmp_reuslt."t1@pid")
                       ->  Materialize
                             ->  CTE Scan on tmp_reuslt
                                   Filter: (level >= 1)
                                   CTE tmp_reuslt
                                     ->  StartWith Operator
                                           Start With pseudo atts: RUITR, array_key_9
                                           ->  Recursive Union
                                                 ->  Seq Scan on test_hcb_ptb t2
                                                       Filter: (id = 141)
                                                 ->  Hash Join
                                                       Hash Cond: (t2.id = tmp_reuslt."t2@pid")
                                                       ->  Seq Scan on test_hcb_ptb t2
                                                       ->  Hash
                                                             ->  WorkTable Scan on tmp_reuslt
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(37 rows)

explain select sysdate from test_hcb_ptb t1 start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=37.11..39.89 rows=101 width=0)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
(12 rows)

select count(sysdate) from test_hcb_ptb t1 start with id = 141 connect by prior pid=id;
 count 
-------
     6
(1 row)

select t1.id,t1.pid,LEVEL,sys_connect_by_path(null, '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |         pa         |   name   
-----+-----+-------+--------------------+----------
 141 | 131 |     1 | ->null             | 江南摩卡
 151 | 141 |     2 | ->null->null       | 江南一楼
 161 | 151 |     3 | ->null->null->null | 第一单元
 162 | 151 |     3 | ->null->null->null | 第二单元
 163 | 151 |     3 | ->null->null->null | 第三单元
 164 | 151 |     3 | ->null->null->null | 第四单元
 165 | 151 |     3 | ->null->null->null | 第五单元
 166 | 151 |     3 | ->null->null->null | 第六单元
 167 | 151 |     3 | ->null->null->null | 第七单元
 168 | 151 |     3 | ->null->null->null | 第八单元
 169 | 151 |     3 | ->null->null->null | 第九单元
 152 | 141 |     2 | ->null->null       | 江南二楼
 153 | 141 |     2 | ->null->null       | 江南三楼
 154 | 141 |     2 | ->null->null       | 江南四楼
 155 | 141 |     2 | ->null->null       | 江南五楼
 156 | 141 |     2 | ->null->null       | 江南六楼
 157 | 141 |     2 | ->null->null       | 江南七楼
 158 | 141 |     2 | ->null->null       | 江南八楼
 159 | 141 |     2 | ->null->null       | 江南九楼
(19 rows)

select t1.id,t1.pid,LEVEL,sys_connect_by_path('id', '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |      pa      |   name   
-----+-----+-------+--------------+----------
 141 | 131 |     1 | ->id         | 江南摩卡
 151 | 141 |     2 | ->id->id     | 江南一楼
 161 | 151 |     3 | ->id->id->id | 第一单元
 162 | 151 |     3 | ->id->id->id | 第二单元
 163 | 151 |     3 | ->id->id->id | 第三单元
 164 | 151 |     3 | ->id->id->id | 第四单元
 165 | 151 |     3 | ->id->id->id | 第五单元
 166 | 151 |     3 | ->id->id->id | 第六单元
 167 | 151 |     3 | ->id->id->id | 第七单元
 168 | 151 |     3 | ->id->id->id | 第八单元
 169 | 151 |     3 | ->id->id->id | 第九单元
 152 | 141 |     2 | ->id->id     | 江南二楼
 153 | 141 |     2 | ->id->id     | 江南三楼
 154 | 141 |     2 | ->id->id     | 江南四楼
 155 | 141 |     2 | ->id->id     | 江南五楼
 156 | 141 |     2 | ->id->id     | 江南六楼
 157 | 141 |     2 | ->id->id     | 江南七楼
 158 | 141 |     2 | ->id->id     | 江南八楼
 159 | 141 |     2 | ->id->id     | 江南九楼
(19 rows)

select t1.id,t1.pid,LEVEL,sys_connect_by_path(' ', '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |    pa     |   name   
-----+-----+-------+-----------+----------
 141 | 131 |     1 | ->        | 江南摩卡
 151 | 141 |     2 | -> ->     | 江南一楼
 161 | 151 |     3 | -> -> ->  | 第一单元
 162 | 151 |     3 | -> -> ->  | 第二单元
 163 | 151 |     3 | -> -> ->  | 第三单元
 164 | 151 |     3 | -> -> ->  | 第四单元
 165 | 151 |     3 | -> -> ->  | 第五单元
 166 | 151 |     3 | -> -> ->  | 第六单元
 167 | 151 |     3 | -> -> ->  | 第七单元
 168 | 151 |     3 | -> -> ->  | 第八单元
 169 | 151 |     3 | -> -> ->  | 第九单元
 152 | 141 |     2 | -> ->     | 江南二楼
 153 | 141 |     2 | -> ->     | 江南三楼
 154 | 141 |     2 | -> ->     | 江南四楼
 155 | 141 |     2 | -> ->     | 江南五楼
 156 | 141 |     2 | -> ->     | 江南六楼
 157 | 141 |     2 | -> ->     | 江南七楼
 158 | 141 |     2 | -> ->     | 江南八楼
 159 | 141 |     2 | -> ->     | 江南九楼
(19 rows)

explain select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid Order By NLSSORT ( id, ' NLS_SORT = SCHINESE_PINYIN_M ' );
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=99.22..100.82 rows=641 width=190)
   Sort Key: (nlssort((tmp_reuslt."t1@id")::text, ' NLS_SORT = SCHINESE_PINYIN_M '::text))
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..53.31 rows=641 width=102)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..53.31 rows=641 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.77 rows=64 width=102)
                       Hash Cond: (t1.pid = tmp_reuslt."t1@id")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  CTE Scan on tmp_reuslt  (cost=0.00..16.02 rows=641 width=190)
(14 rows)

select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid Order By NLSSORT ( id, ' NLS_SORT = SCHINESE_PINYIN_M ' );
 id  | pid |   name   | level 
-----+-----+----------+-------
 141 | 131 | 江南摩卡 |     1
 151 | 141 | 江南一楼 |     2
 152 | 141 | 江南二楼 |     2
 153 | 141 | 江南三楼 |     2
 154 | 141 | 江南四楼 |     2
 155 | 141 | 江南五楼 |     2
 156 | 141 | 江南六楼 |     2
 157 | 141 | 江南七楼 |     2
 158 | 141 | 江南八楼 |     2
 159 | 141 | 江南九楼 |     2
 161 | 151 | 第一单元 |     3
 162 | 151 | 第二单元 |     3
 163 | 151 | 第三单元 |     3
 164 | 151 | 第四单元 |     3
 165 | 151 | 第五单元 |     3
 166 | 151 | 第六单元 |     3
 167 | 151 | 第七单元 |     3
 168 | 151 | 第八单元 |     3
 169 | 151 | 第九单元 |     3
(19 rows)

drop table if exists region cascade;
create table region
(
    region_cd varchar(50) primary key ,
    REGION_MGR_ASSOCIATE_ID number(18,9),
    c1 serial
);
select region_mgr_associate_id from region;
 region_mgr_associate_id 
-------------------------
(0 rows)

drop table if exists item_price_history cascade;
create table item_price_history
(
    ITEM_ID number(39,10) primary key ,
    LOCATION_ID number(2,0) NULL,c1 serial
);
SELECT (MIN(region_cd)) Column_001, length(CAST('B' AS bytea), 'UTF8') Column_002
FROM region , item_price_history
WHERE REGION_MGR_ASSOCIATE_ID = ITEM_ID
START WITH REGION_MGR_ASSOCIATE_ID NOT LIKE '_W_'
CONNECT BY PRIOR LOCATION_ID = REGION_MGR_ASSOCIATE_ID
GROUP BY 2;
 column_001 | column_002 
------------+------------
(0 rows)

drop table item_price_history;
drop table region;
create table test1(id int,pid int,name text, level int);
create table test2(id int,pid int,name text, connect_by_iscycle int);
create table test3(id int,pid int,name text, connect_by_isleaf int);
create table test4(id int,pid int,name text, c4 int);
insert into test1 select id,pid,name,id%10 from test_hcb_ptb;
insert into test2 select id,pid,name,id%10 from test_hcb_ptb;
insert into test3 select id,pid,name,id%10 from test_hcb_ptb;
insert into test4 select id,pid,name,id%10 from test_hcb_ptb;
/* level/connect_by_iscycle/connect_by_isleaf is for connect by's level value */
select id,pid,name,test1.level, level from test1 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | level | level 
-----+-----+----------+-------+-------
 141 | 131 | 江南摩卡 |     1 |     1
 131 | 121 | 东山街   |     1 |     2
 121 | 111 | 江宁区   |     1 |     3
 111 |  11 | 南京市   |     1 |     4
  11 |   1 | 江苏省   |     1 |     5
   1 |   0 | 中国     |     1 |     6
(6 rows)

select id,pid,name,test2.connect_by_iscycle, connect_by_iscycle from test2 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | connect_by_iscycle | connect_by_iscycle 
-----+-----+----------+--------------------+--------------------
 141 | 131 | 江南摩卡 |                  1 |                  0
 131 | 121 | 东山街   |                  1 |                  0
 121 | 111 | 江宁区   |                  1 |                  0
 111 |  11 | 南京市   |                  1 |                  0
  11 |   1 | 江苏省   |                  1 |                  0
   1 |   0 | 中国     |                  1 |                  0
(6 rows)

select id,pid,name,test3.connect_by_isleaf, connect_by_isleaf from test3 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | connect_by_isleaf | connect_by_isleaf 
-----+-----+----------+-------------------+-------------------
 141 | 131 | 江南摩卡 |                 1 |                 0
 131 | 121 | 东山街   |                 1 |                 0
 121 | 111 | 江宁区   |                 1 |                 0
 111 |  11 | 南京市   |                 1 |                 0
  11 |   1 | 江苏省   |                 1 |                 0
   1 |   0 | 中国     |                 1 |                 1
(6 rows)

drop table test1;
drop table test2;
drop table test3;
drop table test4;
/* 查询1 */
SELECT TRAIT_VALUE_CD
FROM trait_value
START WITH TRAIT_VALUE_CD=TRAIT_VALUE_CD
CONNECT BY PRIOR UOM_CD LIKE '_E_';
 trait_value_cd 
----------------
 A
 B
 C
 D
 E
 F
(6 rows)

create table region
(
    region_cd varchar(50) primary key ,
    REGION_MGR_ASSOCIATE_ID number(18,9),c1 serial
);
create table item_price_history
(
    ITEM_ID number(39,10) primary key ,
    LOCATION_ID number(2,0) NULL,c1 serial
);
INSERT INTO REGION VALUES ('A', 0.123433);
INSERT INTO REGION VALUES ('B', NULL);
INSERT INTO REGION VALUES ('C', 2.232008908);
INSERT INTO REGION VALUES ('D', 3.878789);
INSERT INTO REGION VALUES ('E', 4.89060603);
INSERT INTO REGION VALUES ('F', 5.82703827);
INSERT INTO REGION VALUES ('G', NULL);
INSERT INTO REGION VALUES ('H', 7.3829083);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.12, 4);
INSERT INTO ITEM_PRICE_HISTORY VALUES (1.3, 1);
INSERT INTO ITEM_PRICE_HISTORY VALUES (2.23, NULL);
INSERT INTO ITEM_PRICE_HISTORY VALUES (3.33, 3);
INSERT INTO ITEM_PRICE_HISTORY VALUES (4.98, 4);
INSERT INTO ITEM_PRICE_HISTORY VALUES (5.01, 5);
INSERT INTO ITEM_PRICE_HISTORY VALUES (6, 6);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.7, 7);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.08, 8);
INSERT INTO ITEM_PRICE_HISTORY VALUES (9.12, 9);
/* 查询2 */
SELECT 1
FROM region , item_price_history
WHERE REGION_MGR_ASSOCIATE_ID = ITEM_ID
START WITH REGION_MGR_ASSOCIATE_ID NOT LIKE '_W_'
CONNECT BY PRIOR LOCATION_ID = REGION_MGR_ASSOCIATE_ID;
 ?column? 
----------
(0 rows)

drop table region;
drop table item_price_history;
create table test1(c1 int, c2 int, c3 int);
insert into test1 values(1,1,1);
insert into test1 values(2,2,2);
-- encountered with 200 iteration limit
select * from test1 t1 start with c1=1 connect by prior c2<>c3;
ERROR:  START WITH .. CONNECT BY statement runs into cycle exception
-- will return result when cycle is met
select * from test1 t1 start with c1=1 connect by NOCYCLE prior c2<>c3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
(2 rows)

select * from test1 t1 connect by NOCYCLE prior c2<>c3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  2 |  2 |  2
  1 |  1 |  1
(4 rows)

select *,connect_by_isleaf is_leaf from test1 t1 connect by NOCYCLE c2<>c3;
 c1 | c2 | c3 | is_leaf 
----+----+----+---------
  1 |  1 |  1 |       1
  2 |  2 |  2 |       1
(2 rows)

drop table test1;
-- error out a case when NOCYCLE is not specify and use connect_by_iscycle
select t1.id, LEVEL, connect_by_iscycle from test_hcb_ptb t1 start with id = 1 connect by  prior id = pid;
 id  | level | connect_by_iscycle 
-----+-------+--------------------
   1 |     1 |                  0
  11 |     2 |                  0
 111 |     3 |                  0
 121 |     4 |                  0
 131 |     5 |                  0
 141 |     6 |                  0
 151 |     7 |                  0
 161 |     8 |                  0
 162 |     8 |                  0
 163 |     8 |                  0
 164 |     8 |                  0
 165 |     8 |                  0
 166 |     8 |                  0
 167 |     8 |                  0
 168 |     8 |                  0
 169 |     8 |                  0
 152 |     7 |                  0
 153 |     7 |                  0
 154 |     7 |                  0
 155 |     7 |                  0
 156 |     7 |                  0
 157 |     7 |                  0
 158 |     7 |                  0
 159 |     7 |                  0
 142 |     6 |                  0
 143 |     6 |                  0
 144 |     6 |                  0
 145 |     6 |                  0
 146 |     6 |                  0
 147 |     6 |                  0
 148 |     6 |                  0
 149 |     6 |                  0
 132 |     5 |                  0
 133 |     5 |                  0
 135 |     5 |                  0
 134 |     5 |                  0
 136 |     5 |                  0
 137 |     5 |                  0
 138 |     5 |                  0
 139 |     5 |                  0
 122 |     4 |                  0
 123 |     4 |                  0
 124 |     4 |                  0
 125 |     4 |                  0
 126 |     4 |                  0
 127 |     4 |                  0
 128 |     4 |                  0
 129 |     4 |                  0
 112 |     3 |                  0
 113 |     3 |                  0
 114 |     3 |                  0
 115 |     3 |                  0
 117 |     3 |                  0
 116 |     3 |                  0
 118 |     3 |                  0
 119 |     3 |                  0
  12 |     2 |                  0
  13 |     2 |                  0
  14 |     2 |                  0
  15 |     2 |                  0
  16 |     2 |                  0
  17 |     2 |                  0
  18 |     2 |                  0
  19 |     2 |                  0
(64 rows)

create table mag_area
(
    area_code varchar(10),
    area_name varchar(120),
    area_short_name  varchar(120),
    local_name      varchar(80),
    belong_area_code    varchar(10),
    bank_level      varchar(8),
    contry_code     varchar(5),
    part_code       varchar(5),
    time_zone       varchar(9),
    bank_code           varchar(10),
    group_code          varchar(5),
    mag_area_grade      varchar(3),
    mag_area_status     varchar(1),
    mag_area_broad      varchar(1)
);
create table mag_image_tpl
(
    seq         varchar(20),
    area_code   varchar(10),
    archive_type varchar(3),
    busitype     varchar(8),
    image_type   varchar(8),
    app_type     varchar(10),
    rule_id      varchar(10),
    valid_flag   varchar(1),
    modify_branch varchar(10),
    modify_user   varchar(9),
    modify_time   varchar(14)
);
explain
select a.rule_id, b.mag_area_grade,
       max(b.mag_area_grade) OVER (PARTITION BY archive_type, busitype,image_type,app_type) max_level
FROM  mag_image_tpl a, mag_area b
WHERE a.AREA_CODE IN (
    SELECT area_code
    FROM mag_area
    START WITH area_code = '1'
    CONNECT BY PRIOR belong_area_code = area_code
)
AND a.archive_type = 'A'
AND a.BUSITYPE = 'B'
AND a.area_code = b.area_code;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg  (cost=156.54..156.56 rows=1 width=176)
   ->  Sort  (cost=156.54..156.54 rows=1 width=176)
         Sort Key: a.image_type, a.app_type
         ->  Nested Loop Semi Join  (cost=127.46..156.53 rows=1 width=176)
               Join Filter: ((a.area_code)::text = (tmp_reuslt."mag_area@area_code")::text)
               ->  Nested Loop  (cost=0.00..24.78 rows=1 width=252)
                     Join Filter: ((a.area_code)::text = (b.area_code)::text)
                     ->  Seq Scan on mag_image_tpl a  (cost=0.00..12.96 rows=1 width=198)
                           Filter: (((archive_type)::text = 'A'::text) AND ((busitype)::text = 'B'::text))
                     ->  Seq Scan on mag_area b  (cost=0.00..10.81 rows=81 width=54)
               ->  CTE Scan on tmp_reuslt  (cost=127.46..129.48 rows=101 width=38)
                     CTE tmp_reuslt
                       ->  StartWith Operator  (cost=0.00..127.46 rows=101 width=982)
                             Start With pseudo atts: RUITR, array_key_5
                             ->  Recursive Union  (cost=0.00..127.46 rows=101 width=982)
                                   ->  Seq Scan on mag_area  (cost=0.00..11.01 rows=1 width=982)
                                         Filter: ((area_code)::text = '1'::text)
                                   ->  Hash Join  (cost=0.33..11.44 rows=10 width=982)
                                         Hash Cond: ((swtest.mag_area.area_code)::text = (tmp_reuslt."mag_area@belong_area_code")::text)
                                         ->  Seq Scan on mag_area  (cost=0.00..10.81 rows=81 width=982)
                                         ->  Hash  (cost=0.20..0.20 rows=10 width=38)
                                               ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=38)
(22 rows)

select a.rule_id, b.mag_area_grade,
       max(b.mag_area_grade) OVER (PARTITION BY archive_type, busitype,image_type,app_type) max_level
FROM  mag_image_tpl a, mag_area b
WHERE a.AREA_CODE IN (
    SELECT area_code
    FROM mag_area
    START WITH area_code = '1'
    CONNECT BY PRIOR belong_area_code = area_code
)
AND a.archive_type = 'A'
AND a.BUSITYPE = 'B'
AND a.area_code = b.area_code;
 rule_id | mag_area_grade | max_level 
---------+----------------+-----------
(0 rows)

drop table mag_area;
drop table mag_image_tpl;
SELECT id, sys_connect_by_path(name_desc, '@') || id
FROM test_area
START WITH name = '耒阳市'
CONNECT BY id = PRIOR fatherid;
 id |            ?column?            
----+--------------------------------
 14 | @Leiyang14
 13 | @Leiyang@Hengyang13
  2 | @Leiyang@Hengyang@Hunan2
  1 | @Leiyang@Hengyang@Hunan@China1
(4 rows)

explain
SELECT table_name || NVL('test','_B$') AS table_name
            FROM (SELECT TRIM(SUBSTR(txt,
                                INSTR(txt, ',', 1, LEVEL) + 1,
                                INSTR(txt, ',', 1, LEVEL + 1) -
                                INSTR(txt, ',', 1, LEVEL) - 1)) AS table_name
                  FROM (SELECT ',' || REPLACE('test' , ' ', '') || ',' txt FROM sys_dummy)
                  CONNECT BY LEVEL <= LENGTH(REPLACE('test', ' ', '')) - LENGTH(REPLACE(REPLACE('test', ' ', ''), ',', '')) + 1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on __unnamed_subquery__  (cost=5.24..10.79 rows=101 width=32)
   ->  CTE Scan on tmp_reuslt  (cost=5.24..9.53 rows=101 width=36)
         CTE tmp_reuslt
           ->  StartWith Operator  (cost=0.00..5.24 rows=101 width=0)
                 Start With pseudo atts: RUITR
                 ->  Recursive Union  (cost=0.00..5.24 rows=101 width=0)
                       ->  Subquery Scan on sys_dummy  (cost=0.00..0.02 rows=1 width=0)
                             ->  Result  (cost=0.00..0.01 rows=1 width=0)
                       ->  Nested Loop  (cost=0.00..0.32 rows=10 width=0)
                             ->  Result  (cost=0.00..0.01 rows=1 width=0)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=0)
(11 rows)

SELECT table_name || NVL('test','_B$') AS table_name
            FROM (SELECT TRIM(SUBSTR(txt,
                                INSTR(txt, ',', 1, LEVEL) + 1,
                                INSTR(txt, ',', 1, LEVEL + 1) -
                                INSTR(txt, ',', 1, LEVEL) - 1)) AS table_name
                  FROM (SELECT ',' || REPLACE('test' , ' ', '') || ',' txt FROM sys_dummy)
                  CONNECT BY LEVEL <= LENGTH(REPLACE('test', ' ', '')) - LENGTH(REPLACE(REPLACE('test', ' ', ''), ',', '')) + 1);
 table_name 
------------
 testtest
(1 row)

-- fix infinite recursive
explain select * from t1 start with id = 1 connect by prior id != pid;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=43.96..60.18 rows=811 width=40)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..43.96 rows=811 width=10)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..43.96 rows=811 width=10)
                 ->  Seq Scan on t1  (cost=0.00..1.11 rows=1 width=10)
                       Filter: (id = 1)
                 ->  Nested Loop  (cost=0.00..2.66 rows=81 width=10)
                       Join Filter: (tmp_reuslt."t1@id" <> swtest.t1.pid)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
                       ->  Materialize  (cost=0.00..1.14 rows=9 width=10)
                             ->  Seq Scan on t1  (cost=0.00..1.09 rows=9 width=10)
(12 rows)

-- test keywords
CREATE TABLE start(connect int, prior int);
CREATE TABLE connect(start int, prior int);
CREATE TABLE prior(start int, connect int);
CREATE TABLE siblings(start int, connect int, prior int);
INSERT INTO start VALUES(1,2);
INSERT INTO start VALUES(1,3);
INSERT INTO start VALUES(3,4);
INSERT INTO start VALUES(3,5);
INSERT INTO start VALUES(5,6);
INSERT INTO start VALUES(6,7);
INSERT INTO connect VALUES(1,2);
INSERT INTO connect VALUES(1,3);
INSERT INTO connect VALUES(3,4);
INSERT INTO connect VALUES(3,5);
INSERT INTO connect VALUES(5,6);
INSERT INTO connect VALUES(6,7);
EXPLAIN SELECT * FROM START START /* GAUSSDB */ WITH connect = 1 CONNECT
/*GAUSS*/BY PRIOR prior = prior;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=810.83..1047.45 rows=11831 width=8)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..810.83 rows=11831 width=8)
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union  (cost=0.00..810.83 rows=11831 width=8)
                 ->  Seq Scan on start  (cost=0.00..36.86 rows=11 width=8)
                       Filter: (connect = 1)
                 ->  Hash Join  (cost=3.58..53.74 rows=1182 width=8)
                       Hash Cond: (swtest.start.prior = tmp_reuslt."start@prior")
                       ->  Seq Scan on start  (cost=0.00..31.49 rows=2149 width=8)
                       ->  Hash  (cost=2.20..2.20 rows=110 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..2.20 rows=110 width=4)
(12 rows)

EXPLAIN SELECT prior AS start, connect AS prior, prior FROM START START
START        WITH connect = 1 CONNECT BY PRIOR /* test prior */ prior = prior;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=810.83..1047.45 rows=11831 width=8)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..810.83 rows=11831 width=8)
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union  (cost=0.00..810.83 rows=11831 width=8)
                 ->  Seq Scan on start  (cost=0.00..36.86 rows=11 width=8)
                       Filter: (connect = 1)
                 ->  Hash Join  (cost=3.58..53.74 rows=1182 width=8)
                       Hash Cond: (start.prior = tmp_reuslt."start@prior")
                       ->  Seq Scan on start  (cost=0.00..31.49 rows=2149 width=8)
                       ->  Hash  (cost=2.20..2.20 rows=110 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..2.20 rows=110 width=4)
(12 rows)

EXPLAIN SELECT start AS connect, prior AS start FROM CONNECT
CONNECT CONNECT     BY ROWNUM <5;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=15013894.35..24250339.33 rows=461822249 width=8)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..15013894.35 rows=461822249 width=8)
           Start With pseudo atts: RUITR
           ->  Recursive Union  (cost=0.00..15013894.35 rows=461822249 width=8)
                 ->  Seq Scan on connect  (cost=0.00..31.49 rows=2149 width=8)
                 ->  Nested Loop  (cost=0.00..577741.79 rows=46182010 width=8)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..429.80 rows=21490 width=0)
                       ->  Materialize  (cost=0.00..42.23 rows=2149 width=8)
                             ->  Seq Scan on connect  (cost=0.00..31.49 rows=2149 width=8)
(10 rows)

SELECT * FROM START START /*GAUSSDB*/
 WITH connect = 1 CONNECT
/*DB*/ BY PRIOR prior = connect;
 connect | prior 
---------+-------
       1 |     2
       1 |     3
       3 |     4
       3 |     5
       5 |     6
       6 |     7
(6 rows)

SELECT prior AS start, connect AS prior, prior FROM START START START WITH connect = 1 CONNECT BY PRIOR prior = connect;
 start | prior | prior 
-------+-------+-------
     2 |     1 |     2
     3 |     1 |     3
     4 |     3 |     4
     5 |     3 |     5
     6 |     5 |     6
     7 |     6 |     7
(6 rows)

SELECT start AS connect, prior AS start FROM CONNECT CONNECT CONNECT BY ROWNUM <5;
 connect | start 
---------+-------
       1 |     2
       1 |     2
       1 |     2
       1 |     2
       1 |     3
       3 |     4
       3 |     5
       5 |     6
       6 |     7
(9 rows)

DROP TABLE IF EXISTS start;
DROP TABLE IF EXISTS connect;
DROP TABLE IF EXISTS siblings;
DROP TABLE IF EXISTS prior;
-- test where clause pushdown result correctness
create table xt1(id int, lid int, name text);
create table xt2(idd int, lidd int, name text);
insert into xt1 values(1,null,'A'),(2,1,'B'),(3,2,'C');
insert into xt2 values(1,null,'A'),(2,1,'B'),(3,2,'C'), (4,3,'D');
select * from xt2,xt1 where xt1.id=xt2.idd and xt1.id!=2 start with id=2 connect by prior id=lid;
 idd | lidd | name | id | lid | name 
-----+------+------+----+-----+------
   3 |    2 | C    |  3 |   2 | C
(1 row)

select * from xt2,xt1 where xt1.id=xt2.idd and xt1.id=3 start with id=2 connect by prior id=lid;
 idd | lidd | name | id | lid | name 
-----+------+------+----+-----+------
   3 |    2 | C    |  3 |   2 | C
(1 row)

drop table if exists xt1;
drop table if exists xt2;
-- test NVL support
CREATE TABLE T_CLOB_SUBSELECT(ID CLOB);
INSERT INTO T_CLOB_SUBSELECT VALUES('abc');
INSERT INTO T_CLOB_SUBSELECT VALUES('abc');
SELECT ID FROM T_CLOB_SUBSELECT CONNECT BY NVL(id,'000')='123';
 id  
-----
 abc
 abc
(2 rows)

DROP TABLE T_CLOB_SUBSELECT;
create table a(a1 int, a2 int);
create table b(b1 int, b2 int);
insert into a values(1,3),(2,4);
insert into b values(2,1),(3,1);
select * from a, b where a1+1=b1 and a1<10 start with a1=1 connect by a1=prior b1;
 a1 | a2 | b1 | b2 
----+----+----+----
  1 |  3 |  2 |  1
  2 |  4 |  3 |  1
(2 rows)

drop table a;
drop table b;
-- test array expr support
create table t_test_array_base (id int,c_int int[],c_bigint bigint[],c_varchar varchar(200)[],c_char char(5)[],c_bool bool[],c_date date[],c_iym interval year to month[]) WITH (STORAGE_TYPE=USTORE);
insert into t_test_array_base values(2,array[1,2,null,10,11],array[1001,1002,1003,null,1004],array['abce','efgg','1233'],array['abcc','efgf','1233'],array[TRUE,FALSE,'f','t'],
array['2013-10-01 10:10:10','2014-10-01 10:10:10'],array[age(timestamp '2001-04-10', timestamp '1957-06-13')]);
insert into t_test_array_base values(2,array[1,2,2,10],array[2001,2002,1003,null,1004],array['abc','efg','123'],array['abc','efg','123'],
array[TRUE,FALSE,'f','t'],array['2011-10-01 10:10:10','2012-10-01 10:10:10'],array[age(timestamp '2001-04-10', timestamp '1957-06-13')]);
insert into t_test_array_base values(2,array[1,2,2,10],array[2001,2002,1003,null,1004],array['abc','efg','123'],array['abc','efg','123'],
array[TRUE,FALSE,'f','t'],array['2011-10-01 10:10:10','2012-10-01 10:10:10'],array[age(timestamp '2001-04-10', timestamp '1957-06-13')]);
select c_int from t_test_array_base connect by c_int[1:2]=array[1,2] and rownum < 5;
      c_int       
------------------
 {1,2,NULL,10,11}
 {1,2,NULL,10,11}
 {1,2,NULL,10,11}
 {1,2,NULL,10,11}
 {1,2,2,10}
 {1,2,2,10}
(6 rows)

drop table t_test_array_base;
-- test invalid columnref
create table test2(id int,pid int);
create table test1(a int not null primary key, b text, c int);
insert into test1(a, b, c) values (generate_series(1,10), repeat('x',(generate_series(1,10))), generate_series(1,10));
explain select t2.id, t2.pid
from test2 t2
where exists(select id from test1 start with id = 1 connect by prior id = t2.id);
ERROR:  Invalid column reference in START WITH / CONNECT BY clause.
DETAIL:  The column referred to may not exist.
--test connectby level bug
select * from (select 'test111' col from sys_dummy) connect by rownum < length(translate(col, '$' || col, '$'));
   col   
---------
 test111
(1 row)

--test find siblings target name bug
select test1.a, cast (min(1) OVER (PARTITION BY test1.a ORDER BY test1.b) as integer) from test1 where test1.b is NULL connect by exists(select test2.id from test2 where false limit 40) order siblings by test1.ctid;
ERROR:  Siblings sort entry not found
DETAIL:  Column ctid not found or not allowed here
--test swcb func with aggregate
create table test3(id text, name text, parentid text);
insert into test3 values('001', 'root', '0');
insert into test3 values('001001', 'a', '001');
insert into test3 values('001002', 'b', '001');
insert into test3 values('001003', 'c', '001');
insert into test3 values('001001001', 'a1', '001001');
insert into test3 values('001001002', 'a2', '001001');
insert into test3 values('001001003', 'a3', '001001');
insert into test3 values('001001003001', 'a31', '001001003');
insert into test3 values('001002001', 'b1', '001002');
insert into test3 values('001002002', 'b2', '001002');
insert into test3 values('001003001', 'c1', '001003');
explain(verbose on, costs off) select sys_connect_by_path(min(name || 'hahaha'), '/') from test3 connect by parentid = prior id;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sys_connect_by_path(min((tmp_reuslt."test3@name" || 'hahaha'::text)), '/'::text)
   CTE tmp_reuslt
     ->  StartWith Operator
           Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
           Start With pseudo atts: RUITR, array_key_1, array_col_2
           ->  Recursive Union
                 ->  Seq Scan on swtest.test3
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                 ->  Hash Join
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                       Hash Cond: (tmp_reuslt."test3@id" = swtest.test3.parentid)
                       ->  WorkTable Scan on tmp_reuslt
                             Output: tmp_reuslt."test3@id", tmp_reuslt."test3@name", tmp_reuslt."test3@parentid"
                       ->  Hash
                             Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                             ->  Seq Scan on swtest.test3
                                   Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
   ->  CTE Scan on tmp_reuslt
         Output: tmp_reuslt."test3@id", tmp_reuslt."test3@name", tmp_reuslt."test3@parentid"
(20 rows)

select sys_connect_by_path(min(name || 'hahaha'), '/') from test3 connect by parentid = prior id;
ERROR:  node value is not in path (value:a1hahaha path:/root)
CONTEXT:  referenced column: sys_connect_by_path
explain(verbose on, costs off) select max(sys_connect_by_path(name, '/')) from test3 connect by parentid = prior id;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: max(sys_connect_by_path(tmp_reuslt."test3@name", '/'::text))
   CTE tmp_reuslt
     ->  StartWith Operator
           Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
           Start With pseudo atts: RUITR, array_key_1, array_col_2
           ->  Recursive Union
                 ->  Seq Scan on swtest.test3
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                 ->  Hash Join
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                       Hash Cond: (tmp_reuslt."test3@id" = swtest.test3.parentid)
                       ->  WorkTable Scan on tmp_reuslt
                             Output: tmp_reuslt."test3@id", tmp_reuslt."test3@name", tmp_reuslt."test3@parentid"
                       ->  Hash
                             Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                             ->  Seq Scan on swtest.test3
                                   Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
   ->  CTE Scan on tmp_reuslt
         Output: tmp_reuslt."test3@id", tmp_reuslt."test3@name", tmp_reuslt."test3@parentid"
(20 rows)

select max(sys_connect_by_path(name, '/')) from test3 connect by parentid = prior id;
    max     
------------
 /root/c/c1
(1 row)

explain(verbose on, costs off) select sys_connect_by_path(name, '/') from test3 connect by parentid = prior id group by 1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 HashAggregate
   Output: (sys_connect_by_path(tmp_reuslt."test3@name", '/'::text))
   Group By Key: sys_connect_by_path(tmp_reuslt."test3@name", '/'::text)
   CTE tmp_reuslt
     ->  StartWith Operator
           Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
           Start With pseudo atts: RUITR, array_key_1, array_col_2
           ->  Recursive Union
                 ->  Seq Scan on swtest.test3
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                 ->  Hash Join
                       Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                       Hash Cond: (tmp_reuslt."test3@id" = swtest.test3.parentid)
                       ->  WorkTable Scan on tmp_reuslt
                             Output: tmp_reuslt."test3@id", tmp_reuslt."test3@name", tmp_reuslt."test3@parentid"
                       ->  Hash
                             Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
                             ->  Seq Scan on swtest.test3
                                   Output: swtest.test3.id, swtest.test3.name, swtest.test3.parentid
   ->  CTE Scan on tmp_reuslt
         Output: sys_connect_by_path(tmp_reuslt."test3@name", '/'::text)
(21 rows)

select sys_connect_by_path(name, '/') from test3 connect by parentid = prior id group by 1;
 sys_connect_by_path 
---------------------
 /root
 /a/a2
 /root/a/a1
 /root/a
 /b
 /root/b/b2
 /root/c/c1
 /c/c1
 /c1
 /b/b1
 /b1
 /a3
 /c
 /b/b2
 /a/a3
 /a
 /root/b
 /root/a/a2
 /a1
 /a3/a31
 /root/a/a3
 /b2
 /root/b/b1
 /root/c
 /a/a3/a31
 /a/a1
 /a2
 /a31
 /root/a/a3/a31
(29 rows)

explain select max(name) from test3 where sys_connect_by_path(name,'/') > 'dasdsa' connect by parentid = prior id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate  (cost=13715.19..13715.20 rows=1 width=64)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..8274.74 rows=210598 width=96)
           Start With pseudo atts: RUITR, array_key_1, array_col_2
           ->  Recursive Union  (cost=0.00..8274.74 rows=210598 width=96)
                 ->  Seq Scan on test3  (cost=0.00..16.48 rows=648 width=96)
                 ->  Hash Join  (cost=24.58..404.63 rows=20995 width=96)
                       Hash Cond: (tmp_reuslt."test3@id" = swtest.test3.parentid)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..129.60 rows=6480 width=32)
                       ->  Hash  (cost=16.48..16.48 rows=648 width=96)
                             ->  Seq Scan on test3  (cost=0.00..16.48 rows=648 width=96)
   ->  CTE Scan on tmp_reuslt  (cost=0.00..5264.95 rows=70199 width=32)
         Filter: (sys_connect_by_path("test3@name", '/'::text) > 'dasdsa'::text)
(13 rows)

select max(name) from test3 where sys_connect_by_path(name,'/') > 'dasdsa' connect by parentid = prior id;
 max  
------
 root
(1 row)

explain select max(name) from test3 connect by parentid = prior id order by sys_connect_by_path(name,'/');
ERROR:  column "tmp_reuslt.name" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: ... parentid = prior id order by sys_connect_by_path(name,'/');
                                                             ^
DETAIL:  Please check your start with rewrite table's column.
select max(name) from test3 connect by parentid = prior id order by sys_connect_by_path(name,'/');
ERROR:  column "tmp_reuslt.name" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: ... parentid = prior id order by sys_connect_by_path(name,'/');
                                                             ^
DETAIL:  Please check your start with rewrite table's column.
explain select max(name) from test3 connect by parentid = prior id group by sys_connect_by_path(name,'/');
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 HashAggregate  (cost=14066.18..14068.68 rows=200 width=64)
   Group By Key: sys_connect_by_path(tmp_reuslt."test3@name", '/'::text)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..8274.74 rows=210598 width=96)
           Start With pseudo atts: RUITR, array_key_1, array_col_2
           ->  Recursive Union  (cost=0.00..8274.74 rows=210598 width=96)
                 ->  Seq Scan on test3  (cost=0.00..16.48 rows=648 width=96)
                 ->  Hash Join  (cost=24.58..404.63 rows=20995 width=96)
                       Hash Cond: (tmp_reuslt."test3@id" = swtest.test3.parentid)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..129.60 rows=6480 width=32)
                       ->  Hash  (cost=16.48..16.48 rows=648 width=96)
                             ->  Seq Scan on test3  (cost=0.00..16.48 rows=648 width=96)
   ->  CTE Scan on tmp_reuslt  (cost=0.00..4738.45 rows=210598 width=32)
(13 rows)

select max(name) from test3 connect by parentid = prior id group by sys_connect_by_path(name,'/');
 max  
------
 root
 a2
 a1
 a
 b
 b2
 c1
 c1
 c1
 b1
 b1
 a3
 c
 b2
 a3
 a
 b
 a2
 a1
 a31
 a3
 b2
 b1
 c
 a31
 a1
 a2
 a31
 a31
(29 rows)

drop table test3;
drop table test2;
drop table test1;
drop table if exists left_table;
drop table if exists right_table;
create table left_table(id int);
create table right_table(id int);
declare
i int:=0;
begin
for i in 1..5 loop
insert into left_table values(i);
insert into right_table values(i+1);
end loop;
commit;
end;
/
select left_table.id as id1,right_table.id as id2 from left_table,right_table where left_table.id+1=right_table.id start with left_table.id=1 connect by prior right_table.id=left_table.id;
 id1 | id2 
-----+-----
   1 |   2
   2 |   3
   3 |   4
   4 |   5
   5 |   6
(5 rows)

drop table left_table;
drop table right_table;
