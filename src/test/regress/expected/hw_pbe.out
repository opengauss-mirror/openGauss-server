--
-- HW_PBE
--
-- Testset 1 dynamic datanode reduction for single table
create table t1_xc_fqs(id1 int, id2 int, num int);
-- only params
prepare s as select * from t1_xc_fqs where id1=$1 and id2=$2;
prepare i as insert into t1_xc_fqs values ($1, $2, $3);
prepare u as update t1_xc_fqs set num=0 where id1=$1 and id2=$2;
prepare d as delete from t1_xc_fqs where id1=$1 and id2=$2;
set enable_pbe_optimization to false;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1,1);
                       QUERY PLAN                        
---------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = 1) AND (t1_xc_fqs.id2 = 1))
(3 rows)

explain (costs off, verbose on) execute i (6,6,6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: 6, 6, 6
(3 rows)

explain (costs off, verbose on) execute u (2,2);
                          QUERY PLAN                           
---------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 0, ctid
         Filter: ((t1_xc_fqs.id1 = 2) AND (t1_xc_fqs.id2 = 2))
(4 rows)

explain (costs off, verbose on) execute d (3,3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = 3) AND (t1_xc_fqs.id2 = 3))
(4 rows)

execute s (1,1);
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
(1 row)

execute i (6,6,6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute u (2,2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute d (3,3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(5 rows)

set enable_pbe_optimization to true;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1,1);
                        QUERY PLAN                         
-----------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(3 rows)

explain (costs off, verbose on) execute i (6,6,6);
         QUERY PLAN         
----------------------------
 [Bypass]
 Insert on public.t1_xc_fqs
   ->  Result
         Output: $1, $2, $3
(4 rows)

explain (costs off, verbose on) execute u (2,2);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 0, ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(4 rows)

explain (costs off, verbose on) execute d (3,3);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(4 rows)

execute s (1,1);
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
(1 row)

execute i (6,6,6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute u (2,2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute d (3,3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(5 rows)

deallocate s;
deallocate i;
deallocate u;
deallocate d;
-- const and params
prepare s as select * from t1_xc_fqs where id1=$1 and id2=2;
prepare i as insert into t1_xc_fqs values ($1, 2, 3);
prepare u as update t1_xc_fqs set num=1 where id1=$1 and id2=2;
prepare d as delete from t1_xc_fqs where id1=$1 and id2=2;
set enable_pbe_optimization to false;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                       QUERY PLAN                        
---------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = 1) AND (t1_xc_fqs.id2 = 2))
(3 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: 6, 2, 3
(3 rows)

explain (costs off, verbose on) execute u (2);
                          QUERY PLAN                           
---------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 1, ctid
         Filter: ((t1_xc_fqs.id1 = 2) AND (t1_xc_fqs.id2 = 2))
(4 rows)

explain (costs off, verbose on) execute d (3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = 3) AND (t1_xc_fqs.id2 = 2))
(4 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

set enable_pbe_optimization to true;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(3 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 [Bypass]
 Insert on public.t1_xc_fqs
   ->  Result
         Output: $1, 2, 3
(4 rows)

explain (costs off, verbose on) execute u (2);
                           QUERY PLAN                           
----------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 1, ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(4 rows)

explain (costs off, verbose on) execute d (3);
                           QUERY PLAN                           
----------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(4 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

deallocate s;
deallocate i;
deallocate u;
deallocate d;
drop table t1_xc_fqs;
-- Testset 2 dynamic datanode reduction for multi-table join
create table t1_xc_fqs(id1 int, id2 int, num int);
insert into t1_xc_fqs values (1,1,11), (2,2,21), (3,3,31), (4,4,41), (5,5,51);
create table t2_xc_fqs(id1 int, id2 int, num int);
insert into t2_xc_fqs values (1,2,12), (2,3,22), (3,4,32), (4,5,42), (5,6,52);
create table t3_xc_fqs(id11 int, id22 int, num int);
insert into t3_xc_fqs values (1,13,13), (2,23,23), (3,33,33), (4,43,43), (5,53,53);
-- implicit join
prepare s0 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=$1 and t2.id1=$2 and t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id1 and t1.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id2 and t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 5)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $2)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
-- explicit join
prepare s0 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2 join t3_xc_fqs t3 on t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id2 where t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 5)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $2)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
-- outer join
prepare s0 as select * from t1_xc_fqs t1 left join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t1.id1;
prepare s1 as select * from t1_xc_fqs t1 right join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t2.id1;
prepare s2 as select * from t1_xc_fqs t1 full join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t1.id1, t2.id1;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1);
                            QUERY PLAN                            
------------------------------------------------------------------
 Merge Left Join
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1
   Merge Cond: (t1.id1 = t2.id1)
   ->  Sort
         Output: t1.id1, t1.id2, t1.num
         Sort Key: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
   ->  Sort
         Output: t2.id1, t2.id2, t2.num
         Sort Key: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(14 rows)

explain (costs off, verbose on) execute s1 (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
   Sort Key: t2.id1
   ->  Hash Left Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
         Hash Cond: (t2.id1 = t1.id1)
         Join Filter: (t2.id1 = 1)
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Hash
               Output: t1.id1, t1.id2, t1.num
               ->  Seq Scan on public.t1_xc_fqs t1
                     Output: t1.id1, t1.id2, t1.num
(13 rows)

explain (costs off, verbose on) execute s2 (1);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
   Sort Key: t1.id1, t2.id1
   ->  Hash Full Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
         Hash Cond: (t1.id1 = t2.id1)
         Join Filter: (t2.id1 = 1)
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Hash
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
(13 rows)

execute s0 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
(5 rows)

execute s1 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(5 rows)

execute s2 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(9 rows)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1);
                            QUERY PLAN                            
------------------------------------------------------------------
 Merge Left Join
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1
   Merge Cond: (t1.id1 = t2.id1)
   ->  Sort
         Output: t1.id1, t1.id2, t1.num
         Sort Key: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
   ->  Sort
         Output: t2.id1, t2.id2, t2.num
         Sort Key: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(14 rows)

explain (costs off, verbose on) execute s1 (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
   Sort Key: t2.id1
   ->  Hash Left Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
         Hash Cond: (t2.id1 = t1.id1)
         Join Filter: (t2.id1 = $1)
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Hash
               Output: t1.id1, t1.id2, t1.num
               ->  Seq Scan on public.t1_xc_fqs t1
                     Output: t1.id1, t1.id2, t1.num
(13 rows)

explain (costs off, verbose on) execute s2 (1);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
   Sort Key: t1.id1, t2.id1
   ->  Hash Full Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
         Hash Cond: (t1.id1 = t2.id1)
         Join Filter: (t2.id1 = $1)
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Hash
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
(13 rows)

execute s0 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
(5 rows)

execute s1 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(5 rows)

execute s2 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(9 rows)

deallocate s0;
deallocate s1;
deallocate s2;
prepare s0 as select * from t1_xc_fqs t1 left join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t1.id1;
prepare s1 as select * from t1_xc_fqs t1 right join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t2.id1;
prepare s2 as select * from t1_xc_fqs t1 full join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1 order by t1.id1, t2.id1;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1);
                            QUERY PLAN                            
------------------------------------------------------------------
 Merge Left Join
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1
   Merge Cond: (t1.id1 = t2.id1)
   ->  Sort
         Output: t1.id1, t1.id2, t1.num
         Sort Key: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
   ->  Sort
         Output: t2.id1, t2.id2, t2.num
         Sort Key: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(14 rows)

explain (costs off, verbose on) execute s1 (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
   Sort Key: t2.id1
   ->  Hash Left Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
         Hash Cond: (t2.id1 = t1.id1)
         Join Filter: (t2.id1 = 1)
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Hash
               Output: t1.id1, t1.id2, t1.num
               ->  Seq Scan on public.t1_xc_fqs t1
                     Output: t1.id1, t1.id2, t1.num
(13 rows)

explain (costs off, verbose on) execute s2 (1);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
   Sort Key: t1.id1, t2.id1
   ->  Hash Full Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
         Hash Cond: (t1.id1 = t2.id1)
         Join Filter: (t2.id1 = 1)
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Hash
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
(13 rows)

execute s0 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
(5 rows)

execute s1 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(5 rows)

execute s2 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(9 rows)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1);
                            QUERY PLAN                            
------------------------------------------------------------------
 Merge Left Join
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1
   Merge Cond: (t1.id1 = t2.id1)
   ->  Sort
         Output: t1.id1, t1.id2, t1.num
         Sort Key: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
   ->  Sort
         Output: t2.id1, t2.id2, t2.num
         Sort Key: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(14 rows)

explain (costs off, verbose on) execute s1 (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
   Sort Key: t2.id1
   ->  Hash Left Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t2.id1
         Hash Cond: (t2.id1 = t1.id1)
         Join Filter: (t2.id1 = $1)
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Hash
               Output: t1.id1, t1.id2, t1.num
               ->  Seq Scan on public.t1_xc_fqs t1
                     Output: t1.id1, t1.id2, t1.num
(13 rows)

explain (costs off, verbose on) execute s2 (1);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
   Sort Key: t1.id1, t2.id1
   ->  Hash Full Join
         Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num, t1.id1, t2.id1
         Hash Cond: (t1.id1 = t2.id1)
         Join Filter: (t2.id1 = $1)
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Hash
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
(13 rows)

execute s0 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
(5 rows)

execute s1 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(5 rows)

execute s2 (1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
   2 |   2 |  21 |     |     |    
   3 |   3 |  31 |     |     |    
   4 |   4 |  41 |     |     |    
   5 |   5 |  51 |     |     |    
     |     |     |   2 |   3 |  22
     |     |     |   3 |   4 |  32
     |     |     |   4 |   5 |  42
     |     |     |   5 |   6 |  52
(9 rows)

deallocate s0;
deallocate s1;
deallocate s2;
drop table t1_xc_fqs;
drop table t2_xc_fqs;
drop table t3_xc_fqs;
-- Testset 3 dynamic datanode reduction for single table (column)
create table t1_xc_fqs(id1 int, id2 int, num int) with (orientation = column);
-- only params
prepare s as select * from t1_xc_fqs where id1=$1 and id2=$2;
prepare i as insert into t1_xc_fqs values ($1, $2, $3);
prepare u as update t1_xc_fqs set num=0 where id1=$1 and id2=$2;
prepare d as delete from t1_xc_fqs where id1=$1 and id2=$2;
set enable_pbe_optimization to false;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1,1);
                          QUERY PLAN                           
---------------------------------------------------------------
 Row Adapter
   Output: id1, id2, num
   ->  CStore Scan on public.t1_xc_fqs
         Output: id1, id2, num
         Filter: ((t1_xc_fqs.id1 = 1) AND (t1_xc_fqs.id2 = 1))
(5 rows)

explain (costs off, verbose on) execute i (6,6,6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: 6, 6, 6
(3 rows)

explain (costs off, verbose on) execute u (2,2);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: id1, id2, 0, ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = 2) AND (t1_xc_fqs.id2 = 2))
(5 rows)

explain (costs off, verbose on) execute d (3,3);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = 3) AND (t1_xc_fqs.id2 = 3))
(5 rows)

execute s (1,1);
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
(1 row)

execute i (6,6,6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute u (2,2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute d (3,3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(5 rows)

set enable_pbe_optimization to true;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1,1);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Row Adapter
   Output: id1, id2, num
   ->  CStore Scan on public.t1_xc_fqs
         Output: id1, id2, num
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(5 rows)

explain (costs off, verbose on) execute i (6,6,6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: $1, $2, $3
(3 rows)

explain (costs off, verbose on) execute u (2,2);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: id1, id2, 0, ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(5 rows)

explain (costs off, verbose on) execute d (3,3);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = $2))
(5 rows)

execute s (1,1);
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
(1 row)

execute i (6,6,6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute u (2,2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(6 rows)

execute d (3,3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   4 |   4 |   4
   5 |   5 |   5
   6 |   6 |   6
(5 rows)

deallocate s;
deallocate i;
deallocate u;
deallocate d;
-- const and params
prepare s as select * from t1_xc_fqs where id1=$1 and id2=2;
prepare i as insert into t1_xc_fqs values ($1, 2, 3);
prepare u as update t1_xc_fqs set num=1 where id1=$1 and id2=2;
prepare d as delete from t1_xc_fqs where id1=$1 and id2=2;
set enable_pbe_optimization to false;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                          QUERY PLAN                           
---------------------------------------------------------------
 Row Adapter
   Output: id1, id2, num
   ->  CStore Scan on public.t1_xc_fqs
         Output: id1, id2, num
         Filter: ((t1_xc_fqs.id1 = 1) AND (t1_xc_fqs.id2 = 2))
(5 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: 6, 2, 3
(3 rows)

explain (costs off, verbose on) execute u (2);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: id1, id2, 1, ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = 2) AND (t1_xc_fqs.id2 = 2))
(5 rows)

explain (costs off, verbose on) execute d (3);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = 3) AND (t1_xc_fqs.id2 = 2))
(5 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

set enable_pbe_optimization to true;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                           QUERY PLAN                           
----------------------------------------------------------------
 Row Adapter
   Output: id1, id2, num
   ->  CStore Scan on public.t1_xc_fqs
         Output: id1, id2, num
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(5 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: $1, 2, 3
(3 rows)

explain (costs off, verbose on) execute u (2);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: id1, id2, 1, ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(5 rows)

explain (costs off, verbose on) execute d (3);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.t1_xc_fqs
         ->  CStore Scan on public.t1_xc_fqs
               Output: ctid, tableoid
               Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(5 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1, id2;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   1
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

deallocate s;
deallocate i;
deallocate u;
deallocate d;
drop table t1_xc_fqs;
-- Testset 4 dynamic datanode reduction for multi-table join (column and row)
create table t1_xc_fqs(id1 int, id2 int, num int) with (orientation = column);
insert into t1_xc_fqs values (1,1,11), (2,2,21), (3,3,31), (4,4,41), (5,5,51);
create table t2_xc_fqs(id1 int, id2 int, num int);
insert into t2_xc_fqs values (1,2,12), (2,3,22), (3,4,32), (4,5,42), (5,6,52);
create table t3_xc_fqs(id11 int, id22 int, num int);
insert into t3_xc_fqs values (1,13,13), (2,23,23), (3,33,33), (4,43,43), (5,53,53);
-- implicit join
prepare s0 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=$1 and t2.id1=$2 and t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id1 and t1.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id2 and t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(12 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(12 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Row Adapter
               Output: ('Dummy')
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: 'Dummy'
                     Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(18 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(12 rows)

explain (costs off, verbose on) execute s3 (4);
                      QUERY PLAN                      
------------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t2.id1 = t1.id1)
   ->  Nested Loop
         Output: t3.id11, t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
(18 rows)

explain (costs off, verbose on) execute s4 (5);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
                     Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(19 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
(10 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(12 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(12 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Row Adapter
               Output: ('Dummy')
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: 'Dummy'
                     Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(18 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(12 rows)

explain (costs off, verbose on) execute s3 (4);
                      QUERY PLAN                      
------------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t2.id1 = t1.id1)
   ->  Nested Loop
         Output: t3.id11, t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
(18 rows)

explain (costs off, verbose on) execute s4 (5);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
                     Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(19 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $2)
(10 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
-- explicit join
prepare s0 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2 join t3_xc_fqs t3 on t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id2 where t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(12 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(12 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Row Adapter
               Output: ('Dummy')
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: 'Dummy'
                     Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(18 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(12 rows)

explain (costs off, verbose on) execute s3 (4);
                      QUERY PLAN                      
------------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t2.id1 = t1.id1)
   ->  Nested Loop
         Output: t3.id11, t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
(18 rows)

explain (costs off, verbose on) execute s4 (5);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
                     Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(19 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
(10 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(12 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(12 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Row Adapter
               Output: ('Dummy')
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: 'Dummy'
                     Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(18 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(12 rows)

explain (costs off, verbose on) execute s3 (4);
                      QUERY PLAN                      
------------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t2.id1 = t1.id1)
   ->  Nested Loop
         Output: t3.id11, t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
(18 rows)

explain (costs off, verbose on) execute s4 (5);
                      QUERY PLAN                      
------------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Row Adapter
               Output: t1.id1
               ->  CStore Scan on public.t1_xc_fqs t1
                     Output: t1.id1
                     Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(19 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Row Adapter
         Output: t1.id1, t1.id2, t1.num
         ->  CStore Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $2)
(10 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
drop table t1_xc_fqs;
drop table t2_xc_fqs;
drop table t3_xc_fqs;
-- Testset 5 dynamic datanode reduction for single table (replication)
create table t1_xc_fqs(id1 int, id2 int, num int);
prepare s as select * from t1_xc_fqs where id1=$1 and id2=2;
prepare i as insert into t1_xc_fqs values ($1, 2, 3);
prepare u as update t1_xc_fqs set num=0 where id1=$1 and id2=2;
prepare d as delete from t1_xc_fqs where id1=$1 and id2=2;
set enable_pbe_optimization to false;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                       QUERY PLAN                        
---------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = 1) AND (t1_xc_fqs.id2 = 2))
(3 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 Insert on public.t1_xc_fqs
   ->  Result
         Output: 6, 2, 3
(3 rows)

explain (costs off, verbose on) execute u (2);
                          QUERY PLAN                           
---------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 0, ctid
         Filter: ((t1_xc_fqs.id1 = 2) AND (t1_xc_fqs.id2 = 2))
(4 rows)

explain (costs off, verbose on) execute d (3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = 3) AND (t1_xc_fqs.id2 = 2))
(4 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

set enable_pbe_optimization to true;
truncate t1_xc_fqs;
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
explain (costs off, verbose on) execute s (1);
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on public.t1_xc_fqs
   Output: id1, id2, num
   Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(3 rows)

explain (costs off, verbose on) execute i (6);
         QUERY PLAN         
----------------------------
 [Bypass]
 Insert on public.t1_xc_fqs
   ->  Result
         Output: $1, 2, 3
(4 rows)

explain (costs off, verbose on) execute u (2);
                           QUERY PLAN                           
----------------------------------------------------------------
 Update on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: id1, id2, 0, ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(4 rows)

explain (costs off, verbose on) execute d (3);
                           QUERY PLAN                           
----------------------------------------------------------------
 Delete on public.t1_xc_fqs
   ->  Seq Scan on public.t1_xc_fqs
         Output: ctid
         Filter: ((t1_xc_fqs.id1 = $1) AND (t1_xc_fqs.id2 = 2))
(4 rows)

execute s (1);
 id1 | id2 | num 
-----+-----+-----
(0 rows)

execute i (6);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   2
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute u (2);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

execute d (3);
select * from t1_xc_fqs order by id1;
 id1 | id2 | num 
-----+-----+-----
   1 |   1 |   1
   2 |   2 |   0
   3 |   3 |   3
   4 |   4 |   4
   5 |   5 |   5
   6 |   2 |   3
(6 rows)

deallocate s;
deallocate i;
deallocate u;
deallocate d;
drop table t1_xc_fqs;
-- Testset 6 dynamic datanode reduction for multi-table join (replication and distribute)
create table t1_xc_fqs(id1 int, id2 int, num int);
insert into t1_xc_fqs values (1,1,11), (2,2,21), (3,3,31), (4,4,41), (5,5,51);
create table t2_xc_fqs(id1 int, id2 int, num int);
insert into t2_xc_fqs values (1,2,12), (2,3,22), (3,4,32), (4,5,42), (5,6,52);
create table t3_xc_fqs(id11 int, id22 int, num int);
insert into t3_xc_fqs values (1,13,13), (2,23,23), (3,33,33), (4,43,43), (5,53,53);
-- implicit join
prepare s0 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=$1 and t2.id1=$2 and t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id1 and t1.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1,t2_xc_fqs t2,t3_xc_fqs t3 where t1.id1=t2.id1 and t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=t2.id2 and t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 5)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $2)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
-- explicit join
prepare s0 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2;
prepare s1 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=$1 and t2.id1=$2 join t3_xc_fqs t3 on t3.id11=$3;
prepare s2 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 and t2.id1=$1;
prepare s3 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t3.id11=$1;
prepare s4 as select id11 from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id1 join t3_xc_fqs t3 on t1.id1=t3.id11 and t3.id11=$1;
prepare s5 as select * from t1_xc_fqs t1 join t2_xc_fqs t2 on t1.id1=t2.id2 where t2.id1=$1 and t2.id2=$2;
set enable_pbe_optimization to false;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 1)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 2)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = 2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 2)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 3)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = 3)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = 4)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = 5)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = 5)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = 5)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = 5) AND (t2.id1 = 4))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 5)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

set enable_pbe_optimization to true;
explain (costs off, verbose on) execute s0 (1,1);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s0 (1,3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $2)
(10 rows)

explain (costs off, verbose on) execute s1 (2,2,2);
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1, t2.id2, t2.num
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1, t2.id2, t2.num
                     Filter: (t2.id1 = $2)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $3)
(16 rows)

explain (costs off, verbose on) execute s2 (3);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
   ->  Materialize
         Output: t2.id1, t2.id2, t2.num
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1, t2.id2, t2.num
               Filter: (t2.id1 = $1)
(10 rows)

explain (costs off, verbose on) execute s3 (4);
                    QUERY PLAN                     
---------------------------------------------------
 Hash Join
   Output: t3.id11
   Hash Cond: (t1.id1 = t2.id1)
   ->  Nested Loop
         Output: t3.id11, t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
         ->  Materialize
               Output: t3.id11
               ->  Seq Scan on public.t3_xc_fqs t3
                     Output: t3.id11
                     Filter: (t3.id11 = $1)
   ->  Hash
         Output: t2.id1
         ->  Seq Scan on public.t2_xc_fqs t2
               Output: t2.id1
(16 rows)

explain (costs off, verbose on) execute s4 (5);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Output: t3.id11
   ->  Nested Loop
         Output: t1.id1
         ->  Seq Scan on public.t1_xc_fqs t1
               Output: t1.id1, t1.id2, t1.num
               Filter: (t1.id1 = $1)
         ->  Materialize
               Output: t2.id1
               ->  Seq Scan on public.t2_xc_fqs t2
                     Output: t2.id1
                     Filter: (t2.id1 = $1)
   ->  Materialize
         Output: t3.id11
         ->  Seq Scan on public.t3_xc_fqs t3
               Output: t3.id11
               Filter: (t3.id11 = $1)
(17 rows)

explain (costs off, verbose on) execute s5 (4,5);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id2 = $2) AND (t2.id1 = $1))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $2)
(8 rows)

execute s0 (1,1);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   1 |   2 |  12
(1 row)

execute s0 (1,3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |   1 |  11 |   3 |   4 |  32
(1 row)

execute s1 (2,2,2);
 id11 
------
    2
(1 row)

execute s2 (3);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   3 |   3 |  31 |   3 |   4 |  32
(1 row)

execute s3 (4);
 id11 
------
    4
    4
    4
    4
    4
(5 rows)

execute s4 (5);
 id11 
------
    5
(1 row)

execute s5 (4,5);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   5 |   5 |  51 |   4 |   5 |  42
(1 row)

deallocate s0;
deallocate s1;
deallocate s2;
deallocate s3;
deallocate s4;
deallocate s5;
drop table t1_xc_fqs;
drop table t2_xc_fqs;
drop table t3_xc_fqs;
--Optimization
create table t1_xc_fqs(id1 int, id2 int, num int);
insert into t1_xc_fqs values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
prepare a as select num from t1_xc_fqs where id1=$1 order by id2;
set enable_pbe_optimization to false;
explain verbose execute a (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort  (cost=34.48..34.50 rows=10 width=8)
   Output: num, id2
   Sort Key: t1_xc_fqs.id2
   ->  Seq Scan on public.t1_xc_fqs  (cost=0.00..34.31 rows=10 width=8)
         Output: num, id2
         Filter: (t1_xc_fqs.id1 = 1)
(6 rows)

execute a (1);
 num 
-----
   1
(1 row)

set enable_pbe_optimization to true;
explain verbose execute a (1);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort  (cost=34.48..34.50 rows=10 width=8)
   Output: num, id2
   Sort Key: t1_xc_fqs.id2
   ->  Seq Scan on public.t1_xc_fqs  (cost=0.00..34.31 rows=10 width=8)
         Output: num, id2
         Filter: (t1_xc_fqs.id1 = $1)
(6 rows)

execute a (1);
 num 
-----
   1
(1 row)

deallocate a;
drop table t1_xc_fqs;
-- Testset bug fixing
create table distribute_by_int (int1 int,numeric1 numeric(7,3));
prepare a as insert into distribute_by_int values ($1,$2);
explain verbose execute a(51,1111);
                              QUERY PLAN                              
----------------------------------------------------------------------
 [Bypass]
 Insert on public.distribute_by_int  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
         Output: $1, $2
(4 rows)

execute a(51,1111);
explain verbose execute a(51,1111);
                              QUERY PLAN                              
----------------------------------------------------------------------
 [Bypass]
 Insert on public.distribute_by_int  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
         Output: $1, $2
(4 rows)

deallocate a;
drop table distribute_by_int;
create table distribute_by_date (col_date date, c_ts_without timestamp  without time zone, c_ts_with  timestamp with time zone);
insert into distribute_by_date values ('2014-09-12 00:00:00','2014-09-12 00:00:00');
prepare a as select * from distribute_by_date where col_date=$1;
explain verbose execute a('2014-09-12 00:00:00');
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Seq Scan on public.distribute_by_date  (cost=0.00..28.91 rows=8 width=24)
   Output: col_date, c_ts_without, c_ts_with
   Filter: (distribute_by_date.col_date = $1)
(3 rows)

deallocate a;
drop table distribute_by_date;
create table distribute_by_varchar (char1 char(4),varchar1 varchar(50));
insert into distribute_by_varchar values ('10','10');
prepare a as delete from distribute_by_varchar where varchar1=$1;
explain verbose execute a('10');
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Delete on public.distribute_by_varchar  (cost=0.00..16.07 rows=2 width=6)
   ->  Seq Scan on public.distribute_by_varchar  (cost=0.00..16.07 rows=2 width=6)
         Output: ctid
         Filter: ((distribute_by_varchar.varchar1)::text = $1)
(4 rows)

deallocate a;
drop table distribute_by_varchar;
CREATE TABLE pbe_prunning_000(id INT,part INT, c_bigint bigint, c_text text);
insert into pbe_prunning_000 values (10,10,10,'abcdefghijklmn0010');
CREATE TABLE pbe_prunning_tmp (id INT,part INT, c_bigint bigint, c_text text);
SET enable_pbe_optimization to false;
PREPARE pa AS INSERT into pbe_prunning_tmp(id,part,c_bigint, c_text) SELECT id,part,c_bigint, c_text FROM pbe_prunning_000 pp0 WHERE pp0.c_bigint=$1 AND pp0.c_text=$2;
EXECUTE pa(10,'abcdefghijklmn0010');
SELECT * FROM pbe_prunning_tmp pp1 WHERE pp1.c_bigint=10 AND pp1.c_text='abcdefghijklmn0010';
 id | part | c_bigint |       c_text       
----+------+----------+--------------------
 10 |   10 |       10 | abcdefghijklmn0010
(1 row)

DEALLOCATE PREPARE pa;
PREPARE pa AS UPDATE pbe_prunning_tmp pp1 SET id=999 WHERE pp1.c_bigint=$1 AND pp1.c_text=$2;
EXECUTE pa(10,'abcdefghijklmn0010');
SELECT * FROM pbe_prunning_tmp pp1 WHERE pp1.c_bigint=10 AND pp1.c_text='abcdefghijklmn0010';
 id  | part | c_bigint |       c_text       
-----+------+----------+--------------------
 999 |   10 |       10 | abcdefghijklmn0010
(1 row)

DEALLOCATE PREPARE pa;
drop table pbe_prunning_tmp;
drop table pbe_prunning_000;
SET enable_pbe_optimization to false;
create table t_TESTTABLE (id int,name text);
insert into t_TESTTABLE values (1,'a'),(2,'b'),(3,'c'), (4,'d'),(5,'e');
prepare a as select * from t_TESTTABLE where id=$1;
execute a (1);
 id | name 
----+------
  1 | a
(1 row)

execute a (2);
 id | name 
----+------
  2 | b
(1 row)

execute a (3);
 id | name 
----+------
  3 | c
(1 row)

execute a (4);
 id | name 
----+------
  4 | d
(1 row)

execute a (5);
 id | name 
----+------
  5 | e
(1 row)

execute a (1);
 id | name 
----+------
  1 | a
(1 row)

deallocate a;
drop table t_TESTTABLE;
-- Bugfix for FQS multi-table join
create table t1(id1 int, id2 int, num int);
insert into t1 values (1,11,11), (2,21,21), (3,31,31), (4,41,41), (5,51,51);
create table t2(id1 int, id2 int, num int);
insert into t2 values (1,12,12), (2,22,22), (3,32,32), (4,42,42), (5,52,52);
create table t3(id11 int, id22 int, num int);
insert into t3 values (1,13,13), (2,23,23), (3,33,33), (4,43,43), (5,53,53);
prepare a as select id11 from t1, t2, t3 where t1.id1=$1 and t2.id1=$2 and t3.id11=$3;
prepare b as select id11 from t1, t2, t3 where t1.id1=t2.id1 and t3.id11=$1;
prepare c as select id11 from t1,t2,t3 where t1.id1=t2.id1 and t1.id1=t3.id11 and t1.id1=$1;
SET enable_pbe_optimization to false;
execute a (1,1,1);
 id11 
------
    1
(1 row)

execute b (1);
 id11 
------
    1
    1
    1
    1
    1
(5 rows)

execute c (1);
 id11 
------
    1
(1 row)

SET enable_pbe_optimization to true;
execute a (1,1,1);
 id11 
------
    1
(1 row)

execute b (1);
 id11 
------
    1
    1
    1
    1
    1
(5 rows)

execute c (1);
 id11 
------
    1
(1 row)

drop table t1;
drop table t2;
drop table t3;
CREATE TABLE pbe_prunning_001 (id INT, c_int INT, c_numeric NUMERIC(7,3));
CREATE TABLE pbe_prunning_002 (id INT, c_int INT, c_numeric NUMERIC(7,3));
INSERT INTO pbe_prunning_001 values (1, 1, 1);
INSERT INTO pbe_prunning_002 values (1, 1, 1);
PREPARE pa AS SELECT * FROM pbe_prunning_001 pp1 RIGHT OUTER JOIN pbe_prunning_002 pp2 ON pp1.c_int=pp2.c_int WHERE (pp1.c_int=$1 AND pp1.c_numeric=$2 AND pp2.c_int=$3 AND pp2.c_numeric=$4) or pp1.id=$5;
EXPLAIN(COSTS FALSE) EXECUTE pa(10,10,10,10,11);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (pp1.c_int = pp2.c_int)
   Join Filter: (((pp1.c_int = $1) AND (pp1.c_numeric = $2) AND (pp2.c_int = $3) AND (pp2.c_numeric = $4)) OR (pp1.id = $5))
   ->  Seq Scan on pbe_prunning_001 pp1
   ->  Hash
         ->  Seq Scan on pbe_prunning_002 pp2
(6 rows)

DEALLOCATE PREPARE pa;
DROP TABLE pbe_prunning_001;
DROP TABLE pbe_prunning_002;
create table pbe_prunning_000(id INT,part INT, c_int INT, c_numeric NUMERIC(7,3));
insert into pbe_prunning_000 values(1,1,10,10);
CREATE TABLE pbe_prunning_tmp (id INT,part INT, c_int INT, c_numeric NUMERIC(7,3));
set enable_pbe_optimization to false;
PREPARE pa AS INSERT INTO pbe_prunning_tmp (id, part, c_int, c_numeric) SELECT id, part, c_int, c_numeric FROM pbe_prunning_000 pp0 WHERE pp0.c_int=$1 AND pp0.c_numeric=$2;
explain(costs off)execute pa(10,10);
                          QUERY PLAN                          
--------------------------------------------------------------
 Insert on pbe_prunning_tmp
   ->  Seq Scan on pbe_prunning_000 pp0
         Filter: ((c_int = 10) AND (c_numeric = 10::numeric))
(3 rows)

EXECUTE pa(10,10);
deallocate pa;
PREPARE pa AS INSERT INTO pbe_prunning_tmp (id, part, c_int, c_numeric) SELECT id, part, c_int, c_numeric FROM pbe_prunning_000 pp0 WHERE pp0.c_int=$1;
explain(costs off)execute pa(10);
               QUERY PLAN               
----------------------------------------
 Insert on pbe_prunning_tmp
   ->  Seq Scan on pbe_prunning_000 pp0
         Filter: (c_int = 10)
(3 rows)

EXECUTE pa(10);
select * from pbe_prunning_tmp;
 id | part | c_int | c_numeric 
----+------+-------+-----------
  1 |    1 |    10 |    10.000
  1 |    1 |    10 |    10.000
(2 rows)

deallocate pa;
drop table pbe_prunning_000;
drop table pbe_prunning_tmp;
CREATE TABLE pbe_prunning_001 (id INT,part INT, c_int INT, c_numeric NUMERIC(7,3));
insert into pbe_prunning_001 values(1937,1937,1937.000);
insert into pbe_prunning_001 values(1938,1938,1938.000);
CREATE TABLE pbe_prunning_002 (id INT,part INT, c_int INT, c_numeric NUMERIC(7,3));
set enable_pbe_optimization to false;
PREPARE pa AS SELECT * FROM pbe_prunning_001 pp1 CROSS JOIN pbe_prunning_002 pp2 WHERE pp1.c_int=$1 OR pp1.c_numeric=$2 OR pp2.c_int=$3 OR pp2.c_numeric=$4 order by 1,2,3,4,5,6;
explain(costs off) execute pa(10,10,10,10);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: pp1.id, pp1.part, pp1.c_int, pp1.c_numeric, pp2.id, pp2.part
   ->  Nested Loop
         Join Filter: ((pp1.c_int = 10) OR (pp1.c_numeric = 10::numeric) OR (pp2.c_int = 10) OR (pp2.c_numeric = 10::numeric))
         ->  Seq Scan on pbe_prunning_001 pp1
         ->  Materialize
               ->  Seq Scan on pbe_prunning_002 pp2
(7 rows)

EXECUTE pa(10,10,10,10);
 id | part | c_int | c_numeric | id | part | c_int | c_numeric 
----+------+-------+-----------+----+------+-------+-----------
(0 rows)

deallocate pa;
PREPARE pa AS SELECT * FROM pbe_prunning_001 pp1 CROSS JOIN pbe_prunning_002 pp2 WHERE pp1.c_int=$1 OR pp1.c_numeric=$2 OR pp2.c_int=$3 order by 1,2,3,4,5,6;
explain(costs off) execute pa(10,10,10);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort
   Sort Key: pp1.id, pp1.part, pp1.c_int, pp1.c_numeric, pp2.id, pp2.part
   ->  Nested Loop
         Join Filter: ((pp1.c_int = 10) OR (pp1.c_numeric = 10::numeric) OR (pp2.c_int = 10))
         ->  Seq Scan on pbe_prunning_001 pp1
         ->  Materialize
               ->  Seq Scan on pbe_prunning_002 pp2
(7 rows)

EXECUTE pa(10,10,10);
 id | part | c_int | c_numeric | id | part | c_int | c_numeric 
----+------+-------+-----------+----+------+-------+-----------
(0 rows)

deallocate pa;
drop table pbe_prunning_001;
drop table pbe_prunning_002;
--mix options: custom, generic, stream
create table t1_xc_fqs(id1 int, id2 int, num int);
insert into t1_xc_fqs values (1,11,11), (2,21,21);
create table t2_xc_fqs(id1 int, id2 int, num int);
insert into t2_xc_fqs values (1,12,12), (1,22,22), (2,22,22);
prepare s0 as select * from t1_xc_fqs t1,t2_xc_fqs t2 where t1.id1=$1 and t2.id1=$2 and t2.id2=$3;
set enable_pbe_optimization to false;
explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = 1) AND (t2.id2 = 12))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = 1) AND (t2.id2 = 22))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = 1) AND (t2.id2 = 12))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = 1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

set enable_pbe_optimization to true;
explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

set enable_pbe_optimization to false;
explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

explain(costs off, verbose on) execute s0 (1,1,12);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,12);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  12 |  12
(1 row)

explain(costs off, verbose on) execute s0 (1,1,22);
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.id1, t1.id2, t1.num, t2.id1, t2.id2, t2.num
   ->  Seq Scan on public.t2_xc_fqs t2
         Output: t2.id1, t2.id2, t2.num
         Filter: ((t2.id1 = $2) AND (t2.id2 = $3))
   ->  Seq Scan on public.t1_xc_fqs t1
         Output: t1.id1, t1.id2, t1.num
         Filter: (t1.id1 = $1)
(8 rows)

execute s0 (1,1,22);
 id1 | id2 | num | id1 | id2 | num 
-----+-----+-----+-----+-----+-----
   1 |  11 |  11 |   1 |  22 |  22
(1 row)

deallocate s0;
drop table t1_xc_fqs;
drop table t2_xc_fqs;
set enable_pbe_optimization to true;
create table TESTTABLE_t1 (id int, num int);
insert into TESTTABLE_t1 values (1,1),(20,20);
explain analyze create table TESTTABLE_t2 as select * from TESTTABLE_t1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
--?Insert on testtable_t2  (cost=0.00..31.49 rows=2149 width=8) (actual time=.* rows=2 loops=1)
--?  ->  Seq Scan on testtable_t1  (cost=0.00..31.49 rows=2149 width=8) (actual time=.* rows=2 loops=1)
--? Total runtime: .* ms
(3 rows)

drop table TESTTABLE_t2;
drop table TESTTABLE_t1;
create table cs_his(segment1 varchar(15), period_name varchar(15), currency_code varchar(15), frequency_code varchar(15), segment3 varchar(15), segment3_desc varchar(200), end_balance_dr numeric, end_balance_cr numeric) with (orientation=column);
create table bs_his(row_desc varchar(800),row_id numeric,amount1 numeric, amount2 numeric, period_name varchar(80), frequency_code varchar(80), currency_code varchar(80), segment1 varchar(80)) with (orientation=column);
insert into cs_his values('11','20190227','22','33','44','55',1.3,3.5);
insert into cs_his values('11','20181231','22','33','44','55',1.3,3.5);
CREATE OR REPLACE FUNCTION test_func(v_date character varying, OUT ret integer)
 RETURNS integer
 LANGUAGE plpgsql
 NOT FENCED
AS $$DECLARE 
V_DT             VARCHAR2(10);
V_LY_END         VARCHAR2(10) := '20181231';
BEGIN
insert into bs_his
    (row_desc,
     row_id,
     amount1,
     amount2,
     period_name,
     frequency_code,
     currency_code,
     segment1)
    select '  ',
           '1',
           '' qc,
           '' qm,
           b.period_name,
           b.frequency_code,
           b.currency_code,
           b.segment1
      from cs_his b
     where b.period_name in (v_date, V_LY_END);
END $$;
select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

select test_func(20190227);
 test_func 
-----------
          
(1 row)

--14 rows
select * from bs_his order by period_name;
 row_desc | row_id | amount1 | amount2 | period_name | frequency_code | currency_code | segment1 
----------+--------+---------+---------+-------------+----------------+---------------+----------
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20181231    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
    |      1 |         |         | 20190227    | 33             | 22            | 11
(14 rows)

drop FUNCTION test_func;
drop table bs_his;
drop table cs_his;
