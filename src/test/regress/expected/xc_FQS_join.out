--
-- XC_FQS_JOIN
--
-- This file contains testcases for JOINs, it does not test the expressions
-- create the tables first
CREATE TABLE tab1_rep (val int, val2 int);
ALTER TABLE tab1_rep ADD PRIMARY KEY(val, val2);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tab1_rep_pkey" for table "tab1_rep"
insert into tab1_rep (select * from generate_series(1, 5) a, generate_series(1, 5) b);
CREATE TABLE tab2_rep as select * from tab1_rep;
CREATE TABLE tab3_rep as select * from tab1_rep;
CREATE TABLE tab4_rep as select * from tab1_rep;
CREATE TABLE tab1_mod as select * from tab1_rep;
CREATE TABLE tab2_mod as select * from tab1_rep;
CREATE TABLE tab3_mod as select * from tab1_rep;
CREATE TABLE single_node_rep_tab as select * from tab1_rep limit 0;
CREATE TABLE single_node_mod_tab as select * from tab1_rep limit 0;
-- populate single node tables specially
insert into single_node_rep_tab values (1, 2), (3, 4);
insert into single_node_mod_tab values (1, 2), (5, 6);
-- Join involving replicated tables only, all of them should be shippable
select * from tab1_rep, tab2_rep where tab1_rep.val = tab2_rep.val and
										tab1_rep.val2 = tab2_rep.val2 and
										tab1_rep.val > 1 and tab1_rep.val < 4;
 val | val2 | val | val2 
-----+------+-----+------
   2 |    1 |   2 |    1
   2 |    2 |   2 |    2
   2 |    3 |   2 |    3
   2 |    4 |   2 |    4
   2 |    5 |   2 |    5
   3 |    1 |   3 |    1
   3 |    2 |   3 |    2
   3 |    3 |   3 |    3
   3 |    4 |   3 |    4
   3 |    5 |   3 |    5
(10 rows)

explain (costs off, verbose on) select * from tab1_rep, tab2_rep where tab1_rep.val = tab2_rep.val and
										tab1_rep.val2 = tab2_rep.val2 and
										tab1_rep.val > 3 and tab1_rep.val < 5;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab1_rep.val, tab1_rep.val2, tab2_rep.val, tab2_rep.val2
   Hash Cond: ((tab2_rep.val = tab1_rep.val) AND (tab2_rep.val2 = tab1_rep.val2))
   ->  Seq Scan on public.tab2_rep
         Output: tab2_rep.val, tab2_rep.val2
         Filter: ((tab2_rep.val > 3) AND (tab2_rep.val < 5))
   ->  Hash
         Output: tab1_rep.val, tab1_rep.val2
         ->  Bitmap Heap Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Recheck Cond: ((tab1_rep.val > 3) AND (tab1_rep.val < 5))
               ->  Bitmap Index Scan on tab1_rep_pkey
                     Index Cond: ((tab1_rep.val > 3) AND (tab1_rep.val < 5))
(13 rows)

select * from tab1_rep natural join tab2_rep 
			where tab2_rep.val > 2 and tab2_rep.val < 5;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
   4 |    1
   4 |    2
   4 |    3
   4 |    4
   4 |    5
(10 rows)

explain (costs off, verbose on) select * from tab1_rep natural join tab2_rep
			where tab2_rep.val > 2 and tab2_rep.val < 5;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab1_rep.val, tab1_rep.val2
   Hash Cond: ((tab2_rep.val = tab1_rep.val) AND (tab2_rep.val2 = tab1_rep.val2))
   ->  Seq Scan on public.tab2_rep
         Output: tab2_rep.val, tab2_rep.val2
         Filter: ((tab2_rep.val > 2) AND (tab2_rep.val < 5))
   ->  Hash
         Output: tab1_rep.val, tab1_rep.val2
         ->  Bitmap Heap Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Recheck Cond: ((tab1_rep.val > 2) AND (tab1_rep.val < 5))
               ->  Bitmap Index Scan on tab1_rep_pkey
                     Index Cond: ((tab1_rep.val > 2) AND (tab1_rep.val < 5))
(13 rows)

select * from tab1_rep join tab2_rep using (val, val2) join tab3_rep using (val, val2)
									where tab1_rep.val > 0 and tab2_rep.val < 3; 
 val | val2 
-----+------
   1 |    1
   1 |    2
   1 |    3
   1 |    4
   1 |    5
   2 |    1
   2 |    2
   2 |    3
   2 |    4
   2 |    5
(10 rows)

explain (costs off, verbose on) select * from tab1_rep join tab2_rep using (val, val2) join tab3_rep using (val, val2)
							where tab1_rep.val > 0 and tab2_rep.val < 3; 
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: tab1_rep.val, tab1_rep.val2
   ->  Hash Join
         Output: tab2_rep.val, tab2_rep.val2, tab3_rep.val, tab3_rep.val2
         Hash Cond: ((tab2_rep.val = tab3_rep.val) AND (tab2_rep.val2 = tab3_rep.val2))
         ->  Seq Scan on public.tab2_rep
               Output: tab2_rep.val, tab2_rep.val2
               Filter: ((tab2_rep.val < 3) AND (tab2_rep.val > 0))
         ->  Hash
               Output: tab3_rep.val, tab3_rep.val2
               ->  Seq Scan on public.tab3_rep
                     Output: tab3_rep.val, tab3_rep.val2
                     Filter: ((tab3_rep.val > 0) AND (tab3_rep.val < 3))
   ->  Index Only Scan using tab1_rep_pkey on public.tab1_rep
         Output: tab1_rep.val, tab1_rep.val2
         Index Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val > 0) AND (tab1_rep.val < 3) AND (tab1_rep.val2 = tab2_rep.val2))
(16 rows)

select * from tab1_rep natural join tab2_rep natural join tab3_rep
			where tab1_rep.val > 0 and tab2_rep.val < 3;
 val | val2 
-----+------
   1 |    1
   1 |    2
   1 |    3
   1 |    4
   1 |    5
   2 |    1
   2 |    2
   2 |    3
   2 |    4
   2 |    5
(10 rows)

explain (costs off, verbose on) select * from tab1_rep natural join tab2_rep natural join tab3_rep
			where tab1_rep.val > 0 and tab2_rep.val < 3;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: tab1_rep.val, tab1_rep.val2
   ->  Hash Join
         Output: tab2_rep.val, tab2_rep.val2, tab3_rep.val, tab3_rep.val2
         Hash Cond: ((tab2_rep.val = tab3_rep.val) AND (tab2_rep.val2 = tab3_rep.val2))
         ->  Seq Scan on public.tab2_rep
               Output: tab2_rep.val, tab2_rep.val2
               Filter: ((tab2_rep.val < 3) AND (tab2_rep.val > 0))
         ->  Hash
               Output: tab3_rep.val, tab3_rep.val2
               ->  Seq Scan on public.tab3_rep
                     Output: tab3_rep.val, tab3_rep.val2
                     Filter: ((tab3_rep.val > 0) AND (tab3_rep.val < 3))
   ->  Index Only Scan using tab1_rep_pkey on public.tab1_rep
         Output: tab1_rep.val, tab1_rep.val2
         Index Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val > 0) AND (tab1_rep.val < 3) AND (tab1_rep.val2 = tab2_rep.val2))
(16 rows)

-- make sure in Joins which are shippable and involve only one node, aggregates
-- are shipped to
select avg(tab1_rep.val) from tab1_rep natural join tab2_rep natural join tab3_rep
			where tab1_rep.val > 0 and tab2_rep.val < 3;
        avg         
--------------------
 1.5000000000000000
(1 row)

explain (costs off, verbose on) select avg(tab1_rep.val) from tab1_rep natural join tab2_rep natural join tab3_rep
			where tab1_rep.val > 0 and tab2_rep.val < 3;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: avg(tab1_rep.val)
   ->  Nested Loop
         Output: tab1_rep.val
         ->  Hash Join
               Output: tab2_rep.val, tab2_rep.val2, tab3_rep.val, tab3_rep.val2
               Hash Cond: ((tab2_rep.val = tab3_rep.val) AND (tab2_rep.val2 = tab3_rep.val2))
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.val, tab2_rep.val2
                     Filter: ((tab2_rep.val < 3) AND (tab2_rep.val > 0))
               ->  Hash
                     Output: tab3_rep.val, tab3_rep.val2
                     ->  Seq Scan on public.tab3_rep
                           Output: tab3_rep.val, tab3_rep.val2
                           Filter: ((tab3_rep.val > 0) AND (tab3_rep.val < 3))
         ->  Index Only Scan using tab1_rep_pkey on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Index Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val > 0) AND (tab1_rep.val < 3) AND (tab1_rep.val2 = tab2_rep.val2))
(18 rows)

-- the two replicated tables being joined do not have any node in common, the
-- query is not shippable
select * from tab3_rep natural join tab4_rep
			where tab3_rep.val > 2 and tab4_rep.val < 5;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
   4 |    1
   4 |    2
   4 |    3
   4 |    4
   4 |    5
(10 rows)

explain (costs off, verbose on) select * from tab3_rep natural join tab4_rep
			where tab3_rep.val > 2 and tab4_rep.val < 5;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab3_rep.val, tab3_rep.val2
   Hash Cond: ((tab3_rep.val = tab4_rep.val) AND (tab3_rep.val2 = tab4_rep.val2))
   ->  Seq Scan on public.tab3_rep
         Output: tab3_rep.val, tab3_rep.val2
         Filter: ((tab3_rep.val > 2) AND (tab3_rep.val < 5))
   ->  Hash
         Output: tab4_rep.val, tab4_rep.val2
         ->  Seq Scan on public.tab4_rep
               Output: tab4_rep.val, tab4_rep.val2
               Filter: ((tab4_rep.val < 5) AND (tab4_rep.val > 2))
(11 rows)

-- Join involving one distributed and one replicated table, with replicated
-- table existing on all nodes where distributed table exists. should be
-- shippable
select * from tab1_mod natural join tab1_rep
			where tab1_mod.val > 2 and tab1_rep.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab1_mod natural join tab1_rep
			where tab1_mod.val > 2 and tab1_rep.val < 4;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab1_mod.val, tab1_mod.val2
   Hash Cond: ((tab1_mod.val = tab1_rep.val) AND (tab1_mod.val2 = tab1_rep.val2))
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
         Filter: ((tab1_mod.val > 2) AND (tab1_mod.val < 4))
   ->  Hash
         Output: tab1_rep.val, tab1_rep.val2
         ->  Bitmap Heap Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Recheck Cond: ((tab1_rep.val < 4) AND (tab1_rep.val > 2))
               ->  Bitmap Index Scan on tab1_rep_pkey
                     Index Cond: ((tab1_rep.val < 4) AND (tab1_rep.val > 2))
(13 rows)

-- Join involving one distributed and one replicated table, with replicated
-- table existing on only some of the nodes where distributed table exists.
-- should not be shippable
select * from tab1_mod natural join tab4_rep
			where tab1_mod.val > 2 and tab4_rep.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab1_mod natural join tab4_rep
			where tab1_mod.val > 2 and tab4_rep.val < 4;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab1_mod.val, tab1_mod.val2
   Hash Cond: ((tab1_mod.val = tab4_rep.val) AND (tab1_mod.val2 = tab4_rep.val2))
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
         Filter: ((tab1_mod.val > 2) AND (tab1_mod.val < 4))
   ->  Hash
         Output: tab4_rep.val, tab4_rep.val2
         ->  Seq Scan on public.tab4_rep
               Output: tab4_rep.val, tab4_rep.val2
               Filter: ((tab4_rep.val < 4) AND (tab4_rep.val > 2))
(11 rows)

-- Join involving two distributed tables, never shipped
select * from tab1_mod natural join tab2_mod
			where tab1_mod.val > 2 and tab2_mod.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab1_mod natural join tab2_mod
			where tab1_mod.val > 2 and tab2_mod.val < 4;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Hash Join
   Output: tab1_mod.val, tab1_mod.val2
   Hash Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
         Filter: ((tab1_mod.val > 2) AND (tab1_mod.val < 4))
   ->  Hash
         Output: tab2_mod.val, tab2_mod.val2
         ->  Seq Scan on public.tab2_mod
               Output: tab2_mod.val, tab2_mod.val2
               Filter: ((tab2_mod.val < 4) AND (tab2_mod.val > 2))
(11 rows)

-- Join involving a distributed table and two replicated tables, such that the
-- distributed table exists only on nodes common to replicated tables, try few
-- permutations
select * from tab2_rep natural join tab4_rep natural join tab2_mod
			where tab2_rep.val > 2 and tab4_rep.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab2_rep natural join tab4_rep natural join tab2_mod
			where tab2_rep.val > 2 and tab4_rep.val < 4;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Nested Loop
   Output: tab2_rep.val, tab2_rep.val2
   Join Filter: ((tab2_rep.val = tab2_mod.val) AND (tab2_rep.val2 = tab2_mod.val2))
   ->  Hash Join
         Output: tab2_rep.val, tab2_rep.val2, tab4_rep.val, tab4_rep.val2
         Hash Cond: ((tab2_rep.val = tab4_rep.val) AND (tab2_rep.val2 = tab4_rep.val2))
         ->  Seq Scan on public.tab2_rep
               Output: tab2_rep.val, tab2_rep.val2
               Filter: ((tab2_rep.val > 2) AND (tab2_rep.val < 4))
         ->  Hash
               Output: tab4_rep.val, tab4_rep.val2
               ->  Seq Scan on public.tab4_rep
                     Output: tab4_rep.val, tab4_rep.val2
                     Filter: ((tab4_rep.val < 4) AND (tab4_rep.val > 2))
   ->  Seq Scan on public.tab2_mod
         Output: tab2_mod.val, tab2_mod.val2
         Filter: ((tab2_mod.val > 2) AND (tab2_mod.val < 4))
(17 rows)

select * from tab4_rep natural join tab2_rep natural join tab2_mod
			where tab2_rep.val > 2 and tab4_rep.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab4_rep natural join tab2_rep natural join tab2_mod
			where tab2_rep.val > 2 and tab4_rep.val < 4;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Nested Loop
   Output: tab4_rep.val, tab4_rep.val2
   Join Filter: ((tab4_rep.val = tab2_mod.val) AND (tab4_rep.val2 = tab2_mod.val2))
   ->  Hash Join
         Output: tab4_rep.val, tab4_rep.val2, tab2_rep.val, tab2_rep.val2
         Hash Cond: ((tab4_rep.val = tab2_rep.val) AND (tab4_rep.val2 = tab2_rep.val2))
         ->  Seq Scan on public.tab4_rep
               Output: tab4_rep.val, tab4_rep.val2
               Filter: ((tab4_rep.val < 4) AND (tab4_rep.val > 2))
         ->  Hash
               Output: tab2_rep.val, tab2_rep.val2
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.val, tab2_rep.val2
                     Filter: ((tab2_rep.val > 2) AND (tab2_rep.val < 4))
   ->  Seq Scan on public.tab2_mod
         Output: tab2_mod.val, tab2_mod.val2
         Filter: ((tab2_mod.val < 4) AND (tab2_mod.val > 2))
(17 rows)

select * from tab2_rep natural join tab2_mod natural join tab4_rep
			where tab2_rep.val > 2 and tab4_rep.val < 4;
 val | val2 
-----+------
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(5 rows)

explain (costs off, verbose on) select * from tab2_rep natural join tab2_mod natural join tab4_rep
			where tab2_rep.val > 2 and tab4_rep.val < 4;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Nested Loop
   Output: tab2_rep.val, tab2_rep.val2
   Join Filter: ((tab2_rep.val = tab4_rep.val) AND (tab2_rep.val2 = tab4_rep.val2))
   ->  Hash Join
         Output: tab2_rep.val, tab2_rep.val2, tab2_mod.val, tab2_mod.val2
         Hash Cond: ((tab2_rep.val = tab2_mod.val) AND (tab2_rep.val2 = tab2_mod.val2))
         ->  Seq Scan on public.tab2_rep
               Output: tab2_rep.val, tab2_rep.val2
               Filter: ((tab2_rep.val > 2) AND (tab2_rep.val < 4))
         ->  Hash
               Output: tab2_mod.val, tab2_mod.val2
               ->  Seq Scan on public.tab2_mod
                     Output: tab2_mod.val, tab2_mod.val2
                     Filter: ((tab2_mod.val > 2) AND (tab2_mod.val < 4))
   ->  Seq Scan on public.tab4_rep
         Output: tab4_rep.val, tab4_rep.val2
         Filter: ((tab4_rep.val < 4) AND (tab4_rep.val > 2))
(17 rows)

-- qualifications on distributed tables
-- In case of 2,3,4 datanodes following join should get shipped completely
select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
 val | val2 
-----+------
   1 |    1
   1 |    2
   1 |    3
   1 |    4
   1 |    5
(5 rows)

explain (costs off, verbose on) select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Output: tab1_mod.val, tab1_mod.val2, tab1_mod.val2
   Sort Key: tab1_mod.val2
   ->  Hash Join
         Output: tab1_mod.val, tab1_mod.val2, tab1_mod.val2
         Hash Cond: (tab1_mod.val2 = tab4_rep.val2)
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.val2
               Filter: (tab1_mod.val = 1)
         ->  Hash
               Output: tab4_rep.val, tab4_rep.val2
               ->  Seq Scan on public.tab4_rep
                     Output: tab4_rep.val, tab4_rep.val2
                     Filter: (tab4_rep.val = 1)
(14 rows)

-- following join between distributed tables should get FQSed because both of
-- them reduce to a single node
select * from tab1_mod join tab2_mod using (val2)
		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val2;
 val2 | val | val 
------+-----+-----
    1 |   1 |   2
    2 |   1 |   2
    3 |   1 |   2
    4 |   1 |   2
    5 |   1 |   2
(5 rows)

explain (costs off, verbose on) select * from tab1_mod join tab2_mod using (val2)
		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Hash Join
   Output: tab1_mod.val2, tab1_mod.val, tab2_mod.val, tab1_mod.val
   Hash Cond: (tab1_mod.val2 = tab2_mod.val2)
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
         Filter: (tab1_mod.val = 1)
   ->  Hash
         Output: tab2_mod.val, tab2_mod.val2
         ->  Seq Scan on public.tab2_mod
               Output: tab2_mod.val, tab2_mod.val2
               Filter: (tab2_mod.val = 2)
(11 rows)

-- JOIN involving the distributed table with equi-JOIN on the distributed column
-- with same kind of distribution on same nodes.
select * from tab1_mod, tab3_mod where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
 val | val2 | val | val2 
-----+------+-----+------
   1 |    1 |   1 |    1
   1 |    1 |   1 |    2
   1 |    1 |   1 |    3
   1 |    1 |   1 |    4
   1 |    1 |   1 |    5
   1 |    2 |   1 |    1
   1 |    2 |   1 |    2
   1 |    2 |   1 |    3
   1 |    2 |   1 |    4
   1 |    2 |   1 |    5
   1 |    3 |   1 |    1
   1 |    3 |   1 |    2
   1 |    3 |   1 |    3
   1 |    3 |   1 |    4
   1 |    3 |   1 |    5
   1 |    4 |   1 |    1
   1 |    4 |   1 |    2
   1 |    4 |   1 |    3
   1 |    4 |   1 |    4
   1 |    4 |   1 |    5
   1 |    5 |   1 |    1
   1 |    5 |   1 |    2
   1 |    5 |   1 |    3
   1 |    5 |   1 |    4
   1 |    5 |   1 |    5
(25 rows)

explain (costs off, verbose on) select * from tab1_mod, tab3_mod
			where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   Output: tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
         Filter: (tab1_mod.val = 1)
   ->  Materialize
         Output: tab3_mod.val, tab3_mod.val2
         ->  Seq Scan on public.tab3_mod
               Output: tab3_mod.val, tab3_mod.val2
               Filter: (tab3_mod.val = 1)
(10 rows)

-- JOIN between relations which are results of subqueries should obey same rules
-- as normal tables
-- replicated subqueries 
select * from (select * from tab1_rep) t1 natural join (select * from tab2_rep) t2
			where t1.val > 1 and t1.val < 4
			order by t1.val, t1.val2;
 val | val2 
-----+------
   2 |    1
   2 |    2
   2 |    3
   2 |    4
   2 |    5
   3 |    1
   3 |    2
   3 |    3
   3 |    4
   3 |    5
(10 rows)

explain (costs off, verbose on)
	select * from (select * from tab1_rep) t1 natural join (select * from tab2_rep) t2
				where t1.val > 1 and t1.val < 4
				order by t1.val, t1.val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Sort
   Output: tab1_rep.val, tab1_rep.val2, tab1_rep.val, tab1_rep.val2
   Sort Key: tab1_rep.val, tab1_rep.val2
   ->  Hash Join
         Output: tab1_rep.val, tab1_rep.val2, tab1_rep.val, tab1_rep.val2
         Hash Cond: ((tab2_rep.val = tab1_rep.val) AND (tab2_rep.val2 = tab1_rep.val2))
         ->  Seq Scan on public.tab2_rep
               Output: tab2_rep.val, tab2_rep.val2
               Filter: ((tab2_rep.val > 1) AND (tab2_rep.val < 4))
         ->  Hash
               Output: tab1_rep.val, tab1_rep.val2
               ->  Bitmap Heap Scan on public.tab1_rep
                     Output: tab1_rep.val, tab1_rep.val2
                     Recheck Cond: ((tab1_rep.val > 1) AND (tab1_rep.val < 4))
                     ->  Bitmap Index Scan on tab1_rep_pkey
                           Index Cond: ((tab1_rep.val > 1) AND (tab1_rep.val < 4))
(16 rows)

select * from (select avg(val2), val from tab1_rep group by val) t1 natural join
				(select avg(val2), val from tab2_rep group by val) t2
			order by 1, 2;
        avg         | val 
--------------------+-----
 3.0000000000000000 |   1
 3.0000000000000000 |   2
 3.0000000000000000 |   3
 3.0000000000000000 |   4
 3.0000000000000000 |   5
(5 rows)

explain (costs off, verbose on)
	select * from (select avg(val2), val from tab1_rep group by val) t1 natural join
					(select avg(val2), val from tab2_rep group by val) t2
				order by 1, 2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Sort
   Output: (avg(tab1_rep.val2)), tab1_rep.val
   Sort Key: (avg(tab1_rep.val2)), tab1_rep.val
   ->  Hash Join
         Output: (avg(tab1_rep.val2)), tab1_rep.val
         Hash Cond: (((avg(tab1_rep.val2)) = (avg(tab2_rep.val2))) AND (tab1_rep.val = tab2_rep.val))
         ->  HashAggregate
               Output: avg(tab1_rep.val2), tab1_rep.val
               Group By Key: tab1_rep.val
               ->  Seq Scan on public.tab1_rep
                     Output: tab1_rep.val, tab1_rep.val2
         ->  Hash
               Output: (avg(tab2_rep.val2)), tab2_rep.val
               ->  HashAggregate
                     Output: avg(tab2_rep.val2), tab2_rep.val
                     Group By Key: tab2_rep.val
                     ->  Seq Scan on public.tab2_rep
                           Output: tab2_rep.val, tab2_rep.val2
(18 rows)

-- replicated and distributed subqueries 
select * from (select avg(val2), val from tab1_mod group by val) t1 natural join
				(select avg(val2), val from tab1_rep group by val) t2
			where t1.val = 3;
        avg         | val 
--------------------+-----
 3.0000000000000000 |   3
(1 row)

explain (costs off, verbose on)
	select * from (select avg(val2), val from tab1_mod group by val) t1 natural join
					(select avg(val2), val from tab1_rep group by val) t2
				where t1.val = 3;
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop
   Output: (avg(tab1_mod.val2)), tab1_mod.val
   Join Filter: ((avg(tab1_mod.val2)) = (avg(tab1_rep.val2)))
   ->  GroupAggregate
         Output: avg(tab1_mod.val2), tab1_mod.val
         Group By Key: tab1_mod.val
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.val2
               Filter: (tab1_mod.val = 3)
   ->  Materialize
         Output: (avg(tab1_rep.val2)), tab1_rep.val
         ->  GroupAggregate
               Output: avg(tab1_rep.val2), tab1_rep.val
               Group By Key: tab1_rep.val
               ->  Bitmap Heap Scan on public.tab1_rep
                     Output: tab1_rep.val, tab1_rep.val2
                     Recheck Cond: (tab1_rep.val = 3)
                     ->  Bitmap Index Scan on tab1_rep_pkey
                           Index Cond: (tab1_rep.val = 3)
(19 rows)

-- distributed subqueries
select * from (select avg(val2), val from tab1_mod group by val) t1 natural join
				(select avg(val2), val from tab3_mod group by val) t2
			where t1.val = 3;
        avg         | val 
--------------------+-----
 3.0000000000000000 |   3
(1 row)

explain (costs off, verbose on)
	select * from (select avg(val2), val from tab1_mod group by val) t1 natural join
					(select avg(val2), val from tab3_mod group by val) t2
			where t1.val = 3;
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop
   Output: (avg(tab1_mod.val2)), tab1_mod.val
   Join Filter: ((avg(tab1_mod.val2)) = (avg(tab3_mod.val2)))
   ->  GroupAggregate
         Output: avg(tab1_mod.val2), tab1_mod.val
         Group By Key: tab1_mod.val
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.val2
               Filter: (tab1_mod.val = 3)
   ->  Materialize
         Output: (avg(tab3_mod.val2)), tab3_mod.val
         ->  GroupAggregate
               Output: avg(tab3_mod.val2), tab3_mod.val
               Group By Key: tab3_mod.val
               ->  Seq Scan on public.tab3_mod
                     Output: tab3_mod.val, tab3_mod.val2
                     Filter: (tab3_mod.val = 3)
(17 rows)

-- OUTER joins, we insert some data in existing tables for testing OUTER join
-- OUTER join between two replicated tables is shippable if they have a common
-- datanode.
insert into tab1_rep values (100, 200);
insert into tab2_rep values (3000, 4000);
select * from tab1_rep left join tab2_rep on (tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2)
			where tab2_rep.val = tab2_rep.val2 or tab2_rep.val is null
			order by tab1_rep.val, tab1_rep.val2;
 val | val2 | val | val2 
-----+------+-----+------
   1 |    1 |   1 |    1
   2 |    2 |   2 |    2
   3 |    3 |   3 |    3
   4 |    4 |   4 |    4
   5 |    5 |   5 |    5
 100 |  200 |     |     
(6 rows)

explain (costs off, verbose on)
select * from tab1_rep left join tab2_rep on (tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2)
			where tab1_rep.val = tab1_rep.val2 or tab2_rep.val is null
			order by tab1_rep.val, tab1_rep.val2;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_rep.val, tab1_rep.val2, tab2_rep.val, tab2_rep.val2, tab1_rep.val, tab1_rep.val2
   Sort Key: tab1_rep.val, tab1_rep.val2
   ->  Hash Left Join
         Output: tab1_rep.val, tab1_rep.val2, tab2_rep.val, tab2_rep.val2, tab1_rep.val, tab1_rep.val2
         Hash Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val2 = tab2_rep.val2))
         Filter: ((tab1_rep.val = tab1_rep.val2) OR (tab2_rep.val IS NULL))
         ->  Seq Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
         ->  Hash
               Output: tab2_rep.val, tab2_rep.val2
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.val, tab2_rep.val2
(13 rows)

-- FULL OUTER join
select * from tab1_rep full join tab2_rep on (tab1_rep.val < tab2_rep.val and tab1_rep.val2 = tab2_rep.val2) 
					where tab1_rep.val > 5 or tab2_rep.val > 5
					order by tab1_rep.val, tab2_rep.val, tab1_rep.val2, tab2_rep.val2;
 val | val2 | val  | val2 
-----+------+------+------
 100 |  200 |      |     
     |      | 3000 | 4000
(2 rows)

explain (costs off, verbose on)
select * from tab1_rep full join tab2_rep on (tab1_rep.val < tab2_rep.val and tab1_rep.val2 = tab2_rep.val2)
					where tab1_rep.val > 5 or tab2_rep.val > 5
					order by tab1_rep.val, tab2_rep.val, tab1_rep.val2, tab2_rep.val2;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_rep.val, tab1_rep.val2, tab2_rep.val, tab2_rep.val2, tab1_rep.val, tab2_rep.val, tab1_rep.val2, tab2_rep.val2
   Sort Key: tab1_rep.val, tab2_rep.val, tab1_rep.val2, tab2_rep.val2
   ->  Hash Full Join
         Output: tab1_rep.val, tab1_rep.val2, tab2_rep.val, tab2_rep.val2, tab1_rep.val, tab2_rep.val, tab1_rep.val2, tab2_rep.val2
         Hash Cond: (tab1_rep.val2 = tab2_rep.val2)
         Join Filter: (tab1_rep.val < tab2_rep.val)
         Filter: ((tab1_rep.val > 5) OR (tab2_rep.val > 5))
         ->  Seq Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
         ->  Hash
               Output: tab2_rep.val, tab2_rep.val2
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.val, tab2_rep.val2
(14 rows)

-- OUTER join between two distributed tables is shippable if it's an equi-join
-- on the distribution columns, such that distribution columns are of same type
-- and the relations are distributed on same set of nodes
insert into tab1_mod values (100, 200);
insert into tab3_mod values (3000, 4000);
select * from tab1_mod left join tab3_mod on (tab1_mod.val = tab3_mod.val and tab1_mod.val2 = tab3_mod.val2)
			where tab3_mod.val = tab3_mod.val2 or tab3_mod.val is null
			order by tab1_mod.val, tab1_mod.val2;
 val | val2 | val | val2 
-----+------+-----+------
   1 |    1 |   1 |    1
   2 |    2 |   2 |    2
   3 |    3 |   3 |    3
   4 |    4 |   4 |    4
   5 |    5 |   5 |    5
 100 |  200 |     |     
(6 rows)

explain (costs off, verbose on)
select * from tab1_mod left join tab3_mod on (tab1_mod.val = tab3_mod.val and tab1_mod.val2 = tab3_mod.val2)
			where tab3_mod.val = tab3_mod.val2 or tab3_mod.val is null
			order by  tab1_mod.val, tab1_mod.val2;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2, tab1_mod.val, tab1_mod.val2
   Sort Key: tab1_mod.val, tab1_mod.val2
   ->  Hash Left Join
         Output: tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2, tab1_mod.val, tab1_mod.val2
         Hash Cond: ((tab1_mod.val = tab3_mod.val) AND (tab1_mod.val2 = tab3_mod.val2))
         Filter: ((tab3_mod.val = tab3_mod.val2) OR (tab3_mod.val IS NULL))
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.val2
         ->  Hash
               Output: tab3_mod.val, tab3_mod.val2
               ->  Seq Scan on public.tab3_mod
                     Output: tab3_mod.val, tab3_mod.val2
(13 rows)

-- JOIN condition is not equi-join on distribution column, join is not shippable
select * from tab1_mod left join tab3_mod using (val2)
			where (tab1_mod.val = tab1_mod.val2 and tab3_mod.val = tab3_mod.val2) or tab3_mod.val is null
			order by tab1_mod.val, tab1_mod.val2, tab3_mod.val2;
 val2 | val | val 
------+-----+-----
    1 |   1 |   1
    2 |   2 |   2
    3 |   3 |   3
    4 |   4 |   4
    5 |   5 |   5
  200 | 100 |    
(6 rows)

explain (costs off, verbose on)
select * from tab1_mod left join tab3_mod using (val2)
			where (tab1_mod.val = tab1_mod.val2 and tab3_mod.val = tab3_mod.val2) or tab3_mod.val is null
			order by  tab1_mod.val, tab1_mod.val2, tab3_mod.val2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_mod.val2, tab1_mod.val, tab3_mod.val, tab1_mod.val, tab1_mod.val2, tab3_mod.val2
   Sort Key: tab1_mod.val, tab1_mod.val2, tab3_mod.val2
   ->  Hash Left Join
         Output: tab1_mod.val2, tab1_mod.val, tab3_mod.val, tab1_mod.val, tab1_mod.val2, tab3_mod.val2
         Hash Cond: (tab1_mod.val2 = tab3_mod.val2)
         Filter: (((tab1_mod.val = tab1_mod.val2) AND (tab3_mod.val = tab3_mod.val2)) OR (tab3_mod.val IS NULL))
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.val2
         ->  Hash
               Output: tab3_mod.val, tab3_mod.val2
               ->  Seq Scan on public.tab3_mod
                     Output: tab3_mod.val, tab3_mod.val2
(13 rows)

-- OUTER join between replicated and distributed tables is shippable if the
-- the replicated table is available on all the datanodes where outer side is
-- distributed
select * from tab1_mod left join tab1_rep on (tab1_mod.val < tab1_rep.val and tab1_mod.val2 = tab1_rep.val2)
			where tab1_mod.val >= 5
			order by tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2;
 val | val2 | val | val2 
-----+------+-----+------
   5 |    1 |     |     
   5 |    2 |     |     
   5 |    3 |     |     
   5 |    4 |     |     
   5 |    5 |     |     
 100 |  200 |     |     
(6 rows)

explain (costs off, verbose on)
select * from tab1_mod left join tab1_rep on (tab1_mod.val < tab1_rep.val and tab1_mod.val2 = tab1_rep.val2)
			where tab1_mod.val >= 5
			order by tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2, tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2
   Sort Key: tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2
   ->  Hash Right Join
         Output: tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2, tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2
         Hash Cond: (tab1_rep.val2 = tab1_mod.val2)
         Join Filter: (tab1_mod.val < tab1_rep.val)
         ->  Seq Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
         ->  Hash
               Output: tab1_mod.val, tab1_mod.val2
               ->  Seq Scan on public.tab1_mod
                     Output: tab1_mod.val, tab1_mod.val2
                     Filter: (tab1_mod.val >= 5)
(14 rows)

-- OUTER side is replicated and inner is distributed, join is not shippable,
-- just check the EXPLAIN outputs.
explain (costs off, verbose on)
select * from tab1_mod right join tab1_rep on (tab1_mod.val > tab1_rep.val and tab1_mod.val2 = tab1_rep.val2)
			where tab1_rep.val >= 5;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Right Join
   Output: tab1_mod.val, tab1_mod.val2, tab1_rep.val, tab1_rep.val2
   Hash Cond: (tab1_mod.val2 = tab1_rep.val2)
   Join Filter: (tab1_mod.val > tab1_rep.val)
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
   ->  Hash
         Output: tab1_rep.val, tab1_rep.val2
         ->  Bitmap Heap Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Recheck Cond: (tab1_rep.val >= 5)
               ->  Bitmap Index Scan on tab1_rep_pkey
                     Index Cond: (tab1_rep.val >= 5)
(13 rows)

explain (costs off, verbose on)
select * from tab1_rep left join tab1_mod on (tab1_mod.val > tab1_rep.val and tab1_mod.val2 = tab1_rep.val2)
			where tab1_rep.val >= 5;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Right Join
   Output: tab1_rep.val, tab1_rep.val2, tab1_mod.val, tab1_mod.val2
   Hash Cond: (tab1_mod.val2 = tab1_rep.val2)
   Join Filter: (tab1_mod.val > tab1_rep.val)
   ->  Seq Scan on public.tab1_mod
         Output: tab1_mod.val, tab1_mod.val2
   ->  Hash
         Output: tab1_rep.val, tab1_rep.val2
         ->  Bitmap Heap Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.val2
               Recheck Cond: (tab1_rep.val >= 5)
               ->  Bitmap Index Scan on tab1_rep_pkey
                     Index Cond: (tab1_rep.val >= 5)
(13 rows)

-- Any join involving a distributed and replicated node each located on a single
-- and same node should be shippable
select * from single_node_rep_tab natural full outer join single_node_mod_tab order by val, val2;
 val | val2 
-----+------
   1 |    2
   3 |    4
   5 |    6
(3 rows)

explain (costs off, verbose on)
select * from single_node_rep_tab natural full outer join single_node_mod_tab order by val, val2;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (COALESCE(single_node_rep_tab.val, single_node_mod_tab.val)), (COALESCE(single_node_rep_tab.val2, single_node_mod_tab.val2))
   Sort Key: (COALESCE(single_node_rep_tab.val, single_node_mod_tab.val)), (COALESCE(single_node_rep_tab.val2, single_node_mod_tab.val2))
   ->  Hash Full Join
         Output: COALESCE(single_node_rep_tab.val, single_node_mod_tab.val), COALESCE(single_node_rep_tab.val2, single_node_mod_tab.val2)
         Hash Cond: ((single_node_rep_tab.val = single_node_mod_tab.val) AND (single_node_rep_tab.val2 = single_node_mod_tab.val2))
         ->  Seq Scan on public.single_node_rep_tab
               Output: single_node_rep_tab.val, single_node_rep_tab.val2
         ->  Hash
               Output: single_node_mod_tab.val, single_node_mod_tab.val2
               ->  Seq Scan on public.single_node_mod_tab
                     Output: single_node_mod_tab.val, single_node_mod_tab.val2
(12 rows)

-- DMLs involving JOINs are not FQSed
-- We need to just make sure that FQS is not kicking in. But the JOINs can still
-- be reduced by JOIN reduction optimization. Turn this optimization off so as
-- to generate plans independent of number of nodes in the cluster.
explain (costs off, verbose on) update tab1_mod set val2 = 1000 from tab2_mod 
		where tab1_mod.val = tab2_mod.val and tab1_mod. val2 = tab2_mod.val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Update on public.tab1_mod
   ->  Hash Join
         Output: tab1_mod.val, 1000, tab1_mod.ctid, tab2_mod.ctid
         Hash Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.val, tab1_mod.ctid, tab1_mod.val2
         ->  Hash
               Output: tab2_mod.ctid, tab2_mod.val, tab2_mod.val2
               ->  Seq Scan on public.tab2_mod
                     Output: tab2_mod.ctid, tab2_mod.val, tab2_mod.val2
(10 rows)

explain (costs off, verbose on) delete from tab1_mod using tab2_mod
		where tab1_mod.val = tab2_mod.val and tab1_mod.val2 = tab2_mod.val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Delete on public.tab1_mod
   ->  Hash Join
         Output: tab1_mod.ctid, tab2_mod.ctid
         Hash Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
         ->  Seq Scan on public.tab1_mod
               Output: tab1_mod.ctid, tab1_mod.val, tab1_mod.val2
         ->  Hash
               Output: tab2_mod.ctid, tab2_mod.val, tab2_mod.val2
               ->  Seq Scan on public.tab2_mod
                     Output: tab2_mod.ctid, tab2_mod.val, tab2_mod.val2
(10 rows)

explain (costs off, verbose on) update tab1_rep set val2 = 1000 from tab2_rep
		where tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Update on public.tab1_rep
   ->  Hash Join
         Output: tab1_rep.val, 1000, tab1_rep.ctid, tab2_rep.ctid
         Hash Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val2 = tab2_rep.val2))
         ->  Seq Scan on public.tab1_rep
               Output: tab1_rep.val, tab1_rep.ctid, tab1_rep.val2
         ->  Hash
               Output: tab2_rep.ctid, tab2_rep.val, tab2_rep.val2
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.ctid, tab2_rep.val, tab2_rep.val2
(10 rows)

explain (costs off, verbose on) delete from tab1_rep using tab2_rep 
		where tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Delete on public.tab1_rep
   ->  Hash Join
         Output: tab1_rep.ctid, tab2_rep.ctid
         Hash Cond: ((tab1_rep.val = tab2_rep.val) AND (tab1_rep.val2 = tab2_rep.val2))
         ->  Seq Scan on public.tab1_rep
               Output: tab1_rep.ctid, tab1_rep.val, tab1_rep.val2
         ->  Hash
               Output: tab2_rep.ctid, tab2_rep.val, tab2_rep.val2
               ->  Seq Scan on public.tab2_rep
                     Output: tab2_rep.ctid, tab2_rep.val, tab2_rep.val2
(10 rows)

drop table tab1_rep;
drop table tab2_rep;
drop table tab3_rep;
drop table tab4_rep;
drop table tab1_mod;
drop table tab2_mod;
drop table tab3_mod;
drop table single_node_mod_tab;
drop table single_node_rep_tab;
-- unshippable qual check during "path" phase
create table t1 (a int, b int, c int, d int);
create table rt1 (a int, b int, c int, d int);
explain (costs off, verbose on)
SELECT a
FROM rt1
WHERE EXISTS (
SELECT 1
);
--?.*
--?.*
 Result
   Output: rt1.a
   One-Time Filter: $0
   InitPlan 1 (returns $0)
     ->  Result
   ->  Seq Scan on public.rt1
         Output: rt1.a, rt1.b, rt1.c, rt1.d
(7 rows)

SELECT a
FROM rt1
WHERE EXISTS (
SELECT 1
);
 a 
---
(0 rows)

explain (costs off, verbose on)
SELECT *
FROM t1
LEFT OUTER JOIN (
SELECT a
FROM rt1
WHERE EXISTS (
SELECT 1
)
) dt ON 1 = 1;
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Left Join
   Output: t1.a, t1.b, t1.c, t1.d, rt1.a
   InitPlan 1 (returns $0)
     ->  Result
   ->  Seq Scan on public.t1
         Output: t1.a, t1.b, t1.c, t1.d
   ->  Materialize
         Output: rt1.a
         ->  Result
               Output: rt1.a
               One-Time Filter: $0
               ->  Seq Scan on public.rt1
                     Output: rt1.a, rt1.b, rt1.c, rt1.d
(13 rows)

SELECT *
FROM t1
LEFT OUTER JOIN (
SELECT a
FROM rt1
WHERE EXISTS (
SELECT 1
)
) dt ON 1 = 1;
 a | b | c | d | a 
---+---+---+---+---
(0 rows)

explain (costs off, verbose on)
SELECT *
FROM t1
LEFT OUTER JOIN (
SELECT rt1.a
FROM rt1, rt1 as rt2
WHERE EXISTS (
SELECT 1
)
) dt ON 1 = 1;
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop Left Join
   Output: t1.a, t1.b, t1.c, t1.d, rt1.a
   InitPlan 1 (returns $0)
     ->  Result
   ->  Seq Scan on public.t1
         Output: t1.a, t1.b, t1.c, t1.d
   ->  Result
         Output: rt1.a
         One-Time Filter: $0
         ->  Nested Loop
               Output: rt1.a
               ->  Seq Scan on public.rt1
                     Output: rt1.a, rt1.b, rt1.c, rt1.d
               ->  Materialize
                     Output: rt2.a, rt2.b, rt2.c, rt2.d
                     ->  Seq Scan on public.rt1 rt2
                           Output: rt2.a, rt2.b, rt2.c, rt2.d
(17 rows)

SELECT *
FROM t1
LEFT OUTER JOIN (
SELECT rt1.a
FROM rt1, rt1 as rt2
WHERE EXISTS (
SELECT 1
)
) dt ON 1 = 1;
 a | b | c | d | a 
---+---+---+---+---
(0 rows)

drop table t1;
drop table rt1;
--test inner unique + smp
set query_dop=32;
set enable_inner_unique_opt=true;
set enable_material=off;
create table test_a(a int, b int);
create table test_b(c int, d int);
insert into test_a values(1,2),(1,3),(1,4);
insert into test_b values(1,2),(1,2),(1,3),(1,3),(1,4),(1,4);
create unique index test_inner_idx on test_a(b);
--merge join
explain (verbose ,costs off)
select /*+ mergejoin(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d;
                       QUERY PLAN                       
--------------------------------------------------------
 Merge Join
   Output: test_a.a, test_a.b, test_b.c, test_b.d
   Inner Unique: true
   Merge Cond: (test_b.d = test_a.b)
   ->  Sort
         Output: test_b.c, test_b.d
         Sort Key: test_b.d
         ->  Seq Scan on public.test_b
               Output: test_b.c, test_b.d
   ->  Index Scan using test_inner_idx on public.test_a
         Output: test_a.a, test_a.b
(11 rows)

select /*+ mergejoin(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d;
 a | b | c | d 
---+---+---+---
 1 | 2 | 1 | 2
 1 | 2 | 1 | 2
 1 | 3 | 1 | 3
 1 | 3 | 1 | 3
 1 | 4 | 1 | 4
 1 | 4 | 1 | 4
(6 rows)

--hash join
explain (verbose ,costs off)
select /*+ hashjoin(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d order by a,b;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Output: test_a.a, test_a.b, test_b.c, test_b.d
   Sort Key: test_a.a, test_a.b
   ->  Hash Join
         Output: test_a.a, test_a.b, test_b.c, test_b.d
         Inner Unique: true
         Hash Cond: (test_b.d = test_a.b)
         ->  Seq Scan on public.test_b
               Output: test_b.c, test_b.d
         ->  Hash
               Output: test_a.a, test_a.b
               ->  Index Scan using test_inner_idx on public.test_a
                     Output: test_a.a, test_a.b
(13 rows)

select /*+ hashjoin(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d order by a,b;
 a | b | c | d 
---+---+---+---
 1 | 2 | 1 | 2
 1 | 2 | 1 | 2
 1 | 3 | 1 | 3
 1 | 3 | 1 | 3
 1 | 4 | 1 | 4
 1 | 4 | 1 | 4
(6 rows)

--nestloop
explain (verbose ,costs off)
select /*+ nestloop(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d order by a,b;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Output: test_a.a, test_a.b, test_b.c, test_b.d
   Sort Key: test_a.a, test_a.b
   ->  Nested Loop
         Output: test_a.a, test_a.b, test_b.c, test_b.d
         Inner Unique: true
         ->  Seq Scan on public.test_b
               Output: test_b.c, test_b.d
         ->  Index Scan using test_inner_idx on public.test_a
               Output: test_a.a, test_a.b
               Index Cond: (test_a.b = test_b.d)
(11 rows)

select /*+ nestloop(test_a test_b) leading((test_b test_a)) indexscan(test_a test_inner_idx)*/ * from test_a,test_b where b=d order by a,b;
 a | b | c | d 
---+---+---+---
 1 | 2 | 1 | 2
 1 | 2 | 1 | 2
 1 | 3 | 1 | 3
 1 | 3 | 1 | 3
 1 | 4 | 1 | 4
 1 | 4 | 1 | 4
(6 rows)

drop table test_a;
drop table test_b;
reset query_dop;
reset enable_inner_unique_opt;
reset enable_material;
