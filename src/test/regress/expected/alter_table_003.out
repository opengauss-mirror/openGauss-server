--
--FOR BLACKLIST FEATURE: REFERENCES/INHERITS/WITH OIDS/RULE/CREATE TYPE/DOMAIN is not supported.
--
-- test inheritance
create table dropColumn (a int, b int, e int);
create table dropColumnChild (c int) inherits (dropColumn);
create table dropColumnAnother (d int) inherits (dropColumnChild);
-- these two should fail
alter table dropColumnchild drop column a;
ERROR:  cannot drop inherited column "a"
alter table only dropColumnChild drop column b;
ERROR:  cannot drop inherited column "b"
-- these three should work
alter table only dropColumn drop column e;
alter table dropColumnChild drop column c;
alter table dropColumn drop column a;
create table renameColumn (a int);
create table renameColumnChild (b int) inherits (renameColumn);
create table renameColumnAnother (c int) inherits (renameColumnChild);
-- these three should fail
alter table renameColumnChild rename column a to d;
ERROR:  cannot rename inherited column "a"
alter table only renameColumnChild rename column a to d;
ERROR:  inherited column "a" must be renamed in child tables too
alter table only renameColumn rename column a to d;
ERROR:  inherited column "a" must be renamed in child tables too
-- these should work
alter table renameColumn rename column a to d;
alter table renameColumnChild rename column b to a;
-- these should work
alter table if exists doesnt_exist_tab rename column a to d;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
alter table if exists doesnt_exist_tab rename column b to a;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
-- this should work
alter table renameColumn add column w int;
-- this should fail
alter table only renameColumn add column x int;
ERROR:  column must be added to child tables too
-- Test corner cases in dropping of inherited columns
create table p1 (f1 int, f2 int);
create table c1 (f1 int not null) inherits(p1);
NOTICE:  merging column "f1" with inherited definition
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot drop inherited column "f1"
-- should work
alter table p1 drop column f1;
-- c1.f1 is still there, but no longer inherited
select f1 from c1;
 f1 
----
(0 rows)

alter table c1 drop column f1;
select f1 from c1;
ERROR:  column "f1" does not exist
LINE 1: select f1 from c1;
               ^
CONTEXT:  referenced column: f1
drop table p1 cascade;
NOTICE:  drop cascades to table c1
create table p1 (f1 int, f2 int);
create table c1 () inherits(p1);
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot drop inherited column "f1"
alter table p1 drop column f1;
-- c1.f1 is dropped now, since there is no local definition for it
select f1 from c1;
ERROR:  column "f1" does not exist
LINE 1: select f1 from c1;
               ^
CONTEXT:  referenced column: f1
drop table p1 cascade;
NOTICE:  drop cascades to table c1
create table p1 (f1 int, f2 int);
create table c1 () inherits(p1);
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot drop inherited column "f1"
alter table only p1 drop column f1;
-- c1.f1 is NOT dropped, but must now be considered non-inherited
alter table c1 drop column f1;
drop table p1 cascade;
NOTICE:  drop cascades to table c1
create table p1 (f1 int, f2 int);
create table c1 (f1 int not null) inherits(p1);
NOTICE:  merging column "f1" with inherited definition
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot drop inherited column "f1"
alter table only p1 drop column f1;
-- c1.f1 is still there, but no longer inherited
alter table c1 drop column f1;
drop table p1 cascade;
NOTICE:  drop cascades to table c1
create table p1(id int, name text);
create table p2(id2 int, name text, height int);
create table c1(age int) inherits(p1,p2);
NOTICE:  merging multiple inherited definitions of column "name"
create table gc1() inherits (c1);
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | name    |           2 | f
 c1      | id2     |           1 | f
 c1      | height  |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | name    |           1 | f
 gc1     | id2     |           1 | f
 gc1     | height  |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p1      | name    |           0 | t
 p2      | id2     |           0 | t
 p2      | name    |           0 | t
 p2      | height  |           0 | t
(15 rows)

-- should work
alter table only p1 drop column name;
-- should work. Now c1.name is local and inhcount is 0.
alter table p2 drop column name;
-- should be rejected since its inherited
alter table gc1 drop column name;
ERROR:  cannot drop inherited column "name"
-- should work, and drop gc1.name along
alter table c1 drop column name;
-- should fail: column does not exist
alter table gc1 drop column name;
ERROR:  column "name" of relation "gc1" does not exist
-- should work and drop the attribute in all tables
alter table p2 drop column height;
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | id2     |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | id2     |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p2      | id2     |           0 | t
(8 rows)

drop table p1, p2 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table c1
drop cascades to table gc1
--
-- Test the ALTER TABLE SET WITH/WITHOUT OIDS command
--
create table altstartwith (col integer) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
insert into altstartwith values (1);
ERROR:  relation "altstartwith" does not exist on datanode1
LINE 1: insert into altstartwith values (1);
                    ^
select oid > 0, * from altstartwith;
ERROR:  relation "altstartwith" does not exist on datanode1
LINE 1: select oid > 0, * from altstartwith;
                               ^
alter table altstartwith set without oids;
ERROR:  relation "altstartwith" does not exist
select oid > 0, * from altstartwith; -- fails
ERROR:  relation "altstartwith" does not exist on datanode1
LINE 1: select oid > 0, * from altstartwith;
                               ^
select * from altstartwith;
ERROR:  relation "altstartwith" does not exist on datanode1
LINE 1: select * from altstartwith;
                      ^
alter table altstartwith set with oids;
ERROR:  relation "altstartwith" does not exist
select oid > 0, * from altstartwith;
ERROR:  relation "altstartwith" does not exist on datanode1
LINE 1: select oid > 0, * from altstartwith;
                               ^
drop table altstartwith;
ERROR:  table "altstartwith" does not exist
-- Check inheritance cases
create table altwithoid (col integer) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
-- Inherits parents oid column anyway
create table altinhoid () inherits (altwithoid) without oids;
ERROR:  relation "altwithoid" does not exist
insert into altinhoid values (1);
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: insert into altinhoid values (1);
                    ^
select oid > 0, * from altwithoid;
ERROR:  relation "altwithoid" does not exist on datanode1
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
alter table altwithoid set without oids;
ERROR:  relation "altwithoid" does not exist
select oid > 0, * from altwithoid; -- fails
ERROR:  relation "altwithoid" does not exist on datanode1
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid; -- fails
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
select * from altwithoid;
ERROR:  relation "altwithoid" does not exist on datanode1
LINE 1: select * from altwithoid;
                      ^
select * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select * from altinhoid;
                      ^
alter table altwithoid set with oids;
ERROR:  relation "altwithoid" does not exist
select oid > 0, * from altwithoid;
ERROR:  relation "altwithoid" does not exist on datanode1
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
drop table altwithoid cascade;
ERROR:  table "altwithoid" does not exist
create table altwithoid (col integer) without oids;
-- child can have local oid column
create table altinhoid () inherits (altwithoid) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
insert into altinhoid values (1);
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: insert into altinhoid values (1);
                    ^
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
alter table altwithoid set with oids;
ERROR:  Un-support feature
DETAIL:  ALTER TABLE ... SET WITH OIDS is not yet supported.
select oid > 0, * from altwithoid;
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
-- the child's local definition should remain
alter table altwithoid set without oids;
ERROR:  Un-support feature
DETAIL:  ALTER TABLE ... SET WITHOUT OIDS is not yet supported.
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist on datanode1
LINE 1: select oid > 0, * from altinhoid;
                               ^
drop table altwithoid cascade;
-- test renumbering of child-table columns in inherited operations
create table p1 (f1 int);
create table c1 (f2 text, f3 int) inherits (p1);
alter table p1 add column a1 int check (a1 > 0);
alter table p1 add column f2 text;
NOTICE:  merging definition of column "f2" for child "c1"
insert into p1 values (1,2,'abc');
insert into c1 values(11,'xyz',33,0); -- should fail
ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
DETAIL:  N/A
insert into c1 values(11,'xyz',33,22);
select * from p1 order by f1;
 f1 | a1 | f2  
----+----+-----
  1 |  2 | abc
 11 | 22 | xyz
(2 rows)

update p1 set a1 = a1 + 1, f2 = upper(f2);
select * from p1 order by f1;
 f1 | a1 | f2  
----+----+-----
  1 |  3 | ABC
 11 | 23 | XYZ
(2 rows)

drop table p1 cascade;
NOTICE:  drop cascades to table c1
-- test that operations with a dropped column do not try to reference
-- its datatype
--create domain mytype as text;
--create table foo (f1 text, f2 mytype, f3 text);;
insert into foo values('bb','cc','dd');
ERROR:  relation "foo" does not exist on datanode1
LINE 1: insert into foo values('bb','cc','dd');
                    ^
select * from foo order by f1;
ERROR:  relation "foo" does not exist on datanode1
LINE 1: select * from foo order by f1;
                      ^
--drop domain mytype cascade;
--select * from foo order by f1;
--insert into foo values('qq','rr');
--select * from foo order by f1;
--update foo set f3 = 'zz';
--select * from foo order by f1;
--select f3,max(f1) from foo group by f3;
-- Simple tests for alter table column type
--delete from foo where f1 = 'qq';
--alter table foo alter f1 TYPE integer; -- fails
--alter table foo alter f1 TYPE varchar(10);
--drop table foo;
create table anothertab (atcol1 serial8, atcol2 boolean,
	constraint anothertab_chk check (atcol1 <= 3));;
NOTICE:  CREATE TABLE will create implicit sequence "anothertab_atcol1_seq" for serial column "anothertab.atcol1"
insert into anothertab (atcol1, atcol2) values (default, true);
insert into anothertab (atcol1, atcol2) values (default, false);
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

alter table anothertab alter column atcol1 type boolean; -- we cannot support this cast with numeric nextval
alter table anothertab alter column atcol1 type integer;
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | f
      1 | t
(2 rows)

insert into anothertab (atcol1, atcol2) values (45, null); -- fails
ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
DETAIL:  N/A
insert into anothertab (atcol1, atcol2) values (default, null);
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | f
      1 | t
      3 | 
(3 rows)

alter table anothertab alter column atcol2 type text
      using case when atcol2 is true then 'IT WAS TRUE'
                 when atcol2 is false then 'IT WAS FALSE'
                 else 'IT WAS NULL!' end;
select * from anothertab order by atcol1, atcol2;
 atcol1 |    atcol2    
--------+--------------
      1 | IT WAS FALSE
      1 | IT WAS TRUE
      3 | IT WAS NULL!
(3 rows)

alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
alter table anothertab alter column atcol1 drop default;
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
alter table anothertab drop constraint anothertab_chk;
alter table anothertab drop constraint anothertab_chk; -- fails
ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end;
select * from anothertab order by atcol1, atcol2;
 atcol1 |    atcol2    
--------+--------------
 f      | IT WAS FALSE
 f      | IT WAS NULL!
 f      | IT WAS TRUE
(3 rows)

drop table anothertab;
create table another (f1 int, f2 text);;
insert into another values(1, 'one');
insert into another values(2, 'two');
insert into another values(3, 'three');
select * from another order by f1, f2;
 f1 |  f2   
----+-------
  1 | one
  2 | two
  3 | three
(3 rows)

alter table another
  alter f1 type text using f2 || ' more',
  alter f2 type bigint using f1 * 10;
select * from another order by f1, f2;
     f1     | f2 
------------+----
 one more   | 10
 three more | 30
 two more   | 20
(3 rows)

drop table another;
-- table's row type
create table tab1 (a int, b text);
create table tab2 (x int, y tab1);
alter table tab1 alter column b type varchar; -- fails
ERROR:  cannot alter table "tab1" because column "tab2.y" uses its row type
-- disallow recursive containment of row types
create table recur1 (f1 int);
alter table recur1 add column f2 recur1; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 recur1[]; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
--create domain array_of_recur1 as recur1[];
--alter table recur1 add column f2 array_of_recur1; -- fails
create table recur2 (f1 int, f2 recur1);
alter table recur1 add column f2 recur2; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 int;
alter table recur1 alter column f2 type recur2; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
-- SET STORAGE may need to add a TOAST table
create table test_storage (a text);
alter table test_storage alter a set storage plain;
alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
alter table test_storage alter a set storage extended; -- re-add TOAST table
select reltoastrelid <> 0 as has_toast_table
from pg_class
where oid = 'test_storage'::regclass;
 has_toast_table 
-----------------
 t
(1 row)

-- ALTER TYPE with a check constraint and a child table (bug before Nov 2012)
CREATE TABLE test_inh_check (a float check (a > 10.2));
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
\d test_inh_check
Table "public.test_inh_check"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | numeric | 
Check constraints:
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
Number of child tables: 1 (Use \d+ to list them.)

\d test_inh_check_child
Table "public.test_inh_check_child"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | numeric | 
Check constraints:
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
Inherits: test_inh_check

--
-- lock levels
--
drop type lockmodes;
ERROR:  type "lockmodes" does not exist
create type lockmodes as enum (
 'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
drop view my_locks;
ERROR:  view "my_locks" does not exist
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
create table alterlock (f1 int primary key, f2 text);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "alterlock_pkey" for table "alterlock"
start transaction; alter table alterlock alter column f2 set statistics 150;
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
start transaction; alter table alterlock cluster on alterlock_pkey;
select * from my_locks order by 1;
    relname     |    max_lockmode     
----------------+---------------------
 alterlock      | AccessExclusiveLock
 alterlock_pkey | AccessExclusiveLock
(2 rows)

commit;
start transaction; alter table alterlock set without cluster;
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

commit;
start transaction; alter table alterlock set (fillfactor = 100);
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
start transaction; alter table alterlock reset (fillfactor);
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
start transaction; alter table alterlock set (toast.autovacuum_enabled = off);
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
start transaction; alter table alterlock set (autovacuum_enabled = off);
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
start transaction; alter table alterlock alter column f2 set (n_distinct = 1);
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
start transaction; alter table alterlock alter column f2 set storage extended;
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
start transaction; alter table alterlock alter column f2 set default 'x';
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
-- cleanup
drop table alterlock;
drop view my_locks;
drop type lockmodes;
--
-- alter function
--
create function test_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql returns null on null input;
select test_strict(NULL);
 test_strict 
-------------
 
(1 row)

alter function test_strict(text) called on null input;
select test_strict(NULL);
    test_strict    
-------------------
 got passed a null
(1 row)

create function non_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql called on null input;
select non_strict(NULL);
    non_strict     
-------------------
 got passed a null
(1 row)

alter function non_strict(text) returns null on null input;
select non_strict(NULL);
 non_strict 
------------
 
(1 row)

--
-- alter object set schema
--
create schema alter1;
create schema alter2;
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create view alter1.v1 as select * from alter1.t1;
create function alter1.plus1(int) returns int as 'select $1+1' language sql;
--create domain alter1.posint integer check (value > 0);
create type alter1.ctype as (f1 int, f2 text);
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
  operator 1 alter1.=(alter1.ctype, alter1.ctype);
create conversion alter1.ascii_to_utf8 for 'sql_ascii' to 'utf8' from ascii_to_utf8;
ERROR:  user defined conversion is not yet supported.
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ERROR:  user-defined text search parser is not yet supported.
create text search configuration alter1.cfg(parser = alter1.prs);
ERROR:  text search parser "alter1.prs" does not exist
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
ERROR:  user-defined text search template is not yet supported.
create text search dictionary alter1.dict(template = alter1.tmpl);
ERROR:  text search template "alter1.tmpl" does not exist
insert into alter1.t1(f2) values(11);
insert into alter1.t1(f2) values(12);
alter table alter1.t1 set schema alter2;
ERROR:  There's dependent sequence, but ALTER SEQUENCE SET SCHEMA is not yet supported.
alter table alter1.v1 set schema alter2;
alter function alter1.plus1(int) set schema alter2;
--alter domain alter1.posint set schema alter2;
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
alter type alter1.ctype set schema alter2;
alter conversion alter1.ascii_to_utf8 set schema alter2;
ERROR:  conversion "alter1.ascii_to_utf8" does not exist
alter text search parser alter1.prs set schema alter2;
ERROR:  TEXT SEARCH PARSER is not yet supported.
alter text search configuration alter1.cfg set schema alter2;
ERROR:  text search configuration "alter1.cfg" does not exist
alter text search template alter1.tmpl set schema alter2;
ERROR:  TEXT SEARCH TEMPLATE is not yet supported.
alter text search dictionary alter1.dict set schema alter2;
ERROR:  text search dictionary "alter1.dict" does not exist
-- this should succeed because nothing is left in alter1
drop schema alter1;
ERROR:  cannot drop schema alter1 because other objects depend on it
DETAIL:  table alter1.t1 depends on schema alter1
view alter2.v1 depends on table alter1.t1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
insert into alter2.t1(f2) values(13);
ERROR:  relation "alter2.t1" does not exist on datanode1
LINE 1: insert into alter2.t1(f2) values(13);
                    ^
insert into alter2.t1(f2) values(14);
ERROR:  relation "alter2.t1" does not exist on datanode1
LINE 1: insert into alter2.t1(f2) values(14);
                    ^
select * from alter2.t1 order by f1, f2;
ERROR:  relation "alter2.t1" does not exist on datanode1
LINE 1: select * from alter2.t1 order by f1, f2;
                      ^
select * from alter2.v1 order by f1, f2;
 f1 | f2 
----+----
  1 | 11
  2 | 12
(2 rows)

select alter2.plus1(41);
 plus1 
-------
    42
(1 row)

-- clean up
drop schema alter2 cascade;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to view alter2.v1
drop cascades to function alter2.plus1(integer)
drop cascades to operator family alter2.ctype_hash_ops for access method hash
drop cascades to type alter2.ctype
drop cascades to function alter2.same(alter2.ctype,alter2.ctype)
drop cascades to operator alter2.=(alter2.ctype,alter2.ctype)
drop schema alter1 cascade;
NOTICE:  drop cascades to table alter1.t1
--
-- composite types
--
CREATE TYPE test_type AS (a int);
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
ERROR:  relation "nosuchtype" does not exist
ALTER TYPE test_type ADD ATTRIBUTE b text;
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 

ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
ERROR:  column "b" of relation "test_type" already exists
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
\d test_type
   Composite type "public.test_type"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 

ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 

ALTER TYPE test_type DROP ATTRIBUTE b;
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
ERROR:  column "c" of relation "test_type" does not exist
ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
NOTICE:  column "c" of relation "test_type" does not exist, skipping
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ERROR:  must have at least one column
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
ERROR:  column "d" does not exist
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 

DROP TYPE test_type;
CREATE TYPE test_type1 AS (a int, b text);
CREATE TABLE test_tbl1 (x int, y test_type1);
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  cannot alter type "test_type1" because column "test_tbl1.y" uses it
CREATE TYPE test_type2 AS (a int, b text);
CREATE TABLE test_tbl2 OF test_type2;
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
Number of child tables: 1 (Use \d+ to list them.)
Typed table of type: test_type2

ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
ERROR:  cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
 c      | text    | 
Number of child tables: 1 (Use \d+ to list them.)
Typed table of type: test_type2

ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
\d test_type2
   Composite type "public.test_type2"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 
 c      | text              | 

\d test_tbl2
        Table "public.test_tbl2"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 
 c      | text              | 
Number of child tables: 1 (Use \d+ to list them.)
Typed table of type: test_type2

ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
ERROR:  cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 c      | text    | 
Number of child tables: 1 (Use \d+ to list them.)
Typed table of type: test_type2

ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
ERROR:  cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 
Number of child tables: 1 (Use \d+ to list them.)
Typed table of type: test_type2

\d test_tbl2_subclass
Table "public.test_tbl2_subclass"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 
Inherits: test_tbl2

DROP TABLE test_tbl2_subclass;
-- This test isn't that interesting on its own, but the purpose is to leave
-- behind a table to test pg_upgrade with. The table has a composite type
-- column in it, and the composite type has a dropped attribute.
CREATE TYPE test_type3 AS (a int);
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
ERROR:  must have at least one column
CREATE TYPE test_type_empty AS ();
--
-- typed tables: OF / NOT OF
--
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
CREATE TABLE tt4 (x int);							-- too few columns
CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
ALTER TABLE tt7 DROP q;								-- OK
ERROR:  relation "tt7" does not exist
ALTER TABLE tt0 OF tt_t0;
ALTER TABLE tt1 OF tt_t0;
ERROR:  table "tt1" has different type for column "y"
ALTER TABLE tt2 OF tt_t0;
ERROR:  table "tt2" has different type for column "y"
ALTER TABLE tt3 OF tt_t0;
ERROR:  table has column "y" where type requires "x"
ALTER TABLE tt4 OF tt_t0;
ERROR:  table is missing column "y"
ALTER TABLE tt5 OF tt_t0;
ERROR:  table has extra column "z"
ALTER TABLE tt6 OF tt_t0;
ERROR:  typed tables cannot inherit
ALTER TABLE tt7 OF tt_t0;
ERROR:  relation "tt7" does not exist
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
ERROR:  relation "tt7" does not exist
ALTER TABLE tt7 NOT OF;
ERROR:  relation "tt7" does not exist
\d tt7
-- make sure we can drop a constraint on the parent but it remains on the child
CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
-- should fail
INSERT INTO test_drop_constr_child (c) VALUES (NULL);
ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
DETAIL:  N/A
DROP TABLE test_drop_constr_parent CASCADE;
NOTICE:  drop cascades to table test_drop_constr_child
--
-- IF EXISTS test
--
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
NOTICE:  relation "tt8" does not exist, skipping
CREATE TABLE tt8(a int);
CREATE SCHEMA alter2;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "xxx" for table "tt8"
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
\d alter2.tt8
          Table "alter2.tt8"
 Column |  Type   |     Modifiers      
--------+---------+--------------------
 a      | integer | 
 f1     | integer | not null default 0
Indexes:
    "xxx" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Check constraints:
    "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)

DROP TABLE alter2.tt8;
DROP SCHEMA alter2;
create database test_first_after_A dbcompatibility 'A';
\c test_first_after_A
-- test add column ... first | after columnname
-- common scenatios
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 clob first, add f7 blob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f9     | text                        |           | extended |              | 
 f6     | clob                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f7     | blob                        |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f10    | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f8     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

-- 1 primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 blob first, add f7 clob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1;
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f7     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f8     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f6     | text                        |           | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 2 unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 3 default and generated column
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int default 1 first, add f7 float default 7 after f3;
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 |  7 | 01000001 | t
  1 | b  | Wed Nov 09 19:56:10.158564 2022 |  7 | 01000010 | f
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
insert into t1 values(1, 2, 3), (11, 22, 33);
alter table t1 add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f1 + f3) stored after f5;
select * from t1;
 f5 | f6 | f1 | f2 | f3 | f4 
----+----+----+----+----+----
  5 |  4 |  1 |  2 |  3 |  3
 55 | 44 | 11 | 22 | 33 | 33
(2 rows)

-- 5 NULL and NOT NULL
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
alter table t1 drop f1, drop f2, add f6 int null first, add f7 float not null after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | not null  | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 6 check constraint
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (1, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f2, add f6 text check (f1 > 0) first, add f7 int check(f7 - f1 > 0) after f3;
select * from t1;
 f6 | f1 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    |  1 | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  1 | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 7 foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
NOTICE:  table "t_pri1" does not exist, skipping
drop table if exists t_pri2 cascade;
NOTICE:  table "t_pri2" does not exist, skipping
create table t_pri1(f1 text, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t_pri2(f1 text, f2 bool, f4 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
insert into t_pri2 values('a', true, 1), ('b', false, 2);
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
insert into t1 values(1, 2, true), (2, 2, false);
alter table t1 drop f2, add f4 int references t_pri2(f4) first;
select * from t1;
 f4 | f1 | f3 
----+----+----
    |  1 | t
    |  2 | f
(2 rows)

alter table t1 drop f4, add f4 int references t_pri2(f4) after f1;
select * from t1;
 f1 | f4 | f3 
----+----+----
  1 |    | t
  2 |    | f
(2 rows)

-- partition table
drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int)
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 add f4 int first, add f5 int after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 4
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

-- subpartition table
drop table if exists range_range cascade;
NOTICE:  table "range_range" does not exist, skipping
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
-- test pg_partition
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range add f1 int default 1 first, add f2 text after id;
\d+ range_range
                                  Table "public.range_range"
  Column  |              Type              | Modifiers | Storage  | Stats target | Description 
----------+--------------------------------+-----------+----------+--------------+-------------
 f1       | integer                        | default 1 | plain    |              | 
 id       | integer                        |           | plain    |              | 
 f2       | text                           |           | extended |              | 
 gender   | character varying              | not null  | extended |              | 
 birthday | timestamp(0) without time zone | not null  | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 5
 p_2         | p        | 5
 p_3         | p        | 5
 range_range | r        | 2
(4 rows)

select * from range_range;
 f1 | id  | f2 | gender |         birthday         
----+-----+----+--------+--------------------------
  1 |  33 |    | boy    | Mon Aug 11 00:00:00 2003
  1 |  78 |    | girl   | Tue Jun 24 00:00:00 2014
  1 |  15 |    | girl   | Mon Jan 12 00:00:00 2009
  1 | 198 |    | boy    | Mon Feb 15 00:00:00 2010
  1 | 146 |    | girl   | Tue Mar 08 00:00:00 2005
  1 | 111 |    | girl   | Tue Nov 19 00:00:00 2013
  1 | 156 |    | boy    | Sat May 21 00:00:00 2011
  1 | 233 |    | girl   | Fri Jan 01 00:00:00 2010
  1 | 360 |    | boy    | Mon May 14 00:00:00 2007
(9 rows)

-- pg_constraint test
set enable_default_ustore_table = on;
drop table if exists t_pri cascade;
NOTICE:  table "t_pri" does not exist, skipping
drop table if exists t1 cascade;
create table t_pri(f1 int, f2 int, f3 int, primary key(f2, f3));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri_pkey" for table "t_pri"
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        foreign key(f1, f2) references t_pri(f2, f3),
        unique(f3, f4),
        check(f5 = 10),
        unique(f4, f5) include(f6, f7)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f3_f4_key" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f4_f5_f6_f7_key" for table "t1"
select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                 conbin                                                                                                                                                                                                                                                                  |  consrc   | conincluding 
--------------------+---------+--------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {1,2}  | {2,3}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f3_f4_key       | u       | {3,4}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f4_f5_f6_f7_key | u       | {4,5}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | {6,7}
 t1_f5_check        | c       | {5}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 182} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 187 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 185} | (f5 = 10) | 
(4 rows)

alter table t_pri add f4 int first, add f5 int after f2;
alter table t1 add f8 int primary key first, add f9 int unique after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f9_key" for table "t1"
\d+ t_pri
                        Table "public.t_pri"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f5     | integer |           | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "t_pri_pkey" PRIMARY KEY, ubtree (f2, f3) WITH (storage_type=USTORE) TABLESPACE pg_default
Referenced by:
    TABLE "t1" CONSTRAINT "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't_pri') order by conname;
  conname   | contype | conkey | confkey | conbin | consrc | conincluding 
------------+---------+--------+---------+--------+--------+--------------
 t_pri_pkey | p       | {3,5}  |         |        |        | 
(1 row)

\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f8     | integer               | not null  | plain    |              | 
 f1     | integer               |           | plain    |              | 
 f2     | integer               |           | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f9     | integer               |           | plain    |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f8) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f3_f4_key" UNIQUE CONSTRAINT, ubtree (f3, f4) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f4_f5_f6_f7_key" UNIQUE CONSTRAINT, ubtree (f4, f5) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f9_key" UNIQUE CONSTRAINT, ubtree (f9) WITH (storage_type=USTORE) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Foreign-key constraints:
    "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                 conbin                                                                                                                                                                                                                                                                  |  consrc   | conincluding 
--------------------+---------+--------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {2,3}  | {3,5}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f3_f4_key       | u       | {4,6}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f4_f5_f6_f7_key | u       | {6,7}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | {8,9}
 t1_f5_check        | c       | {7}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 182} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 187 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 185} | (f5 = 10) | 
 t1_f9_key          | u       | {5}    |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_pkey            | p       | {1}    |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
(6 rows)

set enable_default_ustore_table = off;
-- pg_index test
drop table if exists t1 cascade;
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        primary key(f1, f2),
        unique(f3, f4),
        check(f5 = 10)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f3_f4_key" for table "t1"
create unique index partial_t1_idx on t1(f5, abs(f6)) where f5 + f6 - abs(f7) > 0;
select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1') order by 1, 2, 3;
 indkey |                                                                                                                                          indexprs                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 1 2    |                                                                                                                                                                                                                                                                                            | 
 3 4    |                                                                                                                                                                                                                                                                                            | 
 5 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 49}) :location 45 :refSynOid 0}) | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 60} {VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 65}) :location 63} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 74}) :location 70 :refSynOid 0}) :location 68} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 80 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 78}
(3 rows)

alter table t1 add f8 int first, add f9 int unique after f1;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f9_key" for table "t1"
\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f8     | integer               |           | plain    |              | 
 f1     | integer               | not null  | plain    |              | 
 f9     | integer               |           | plain    |              | 
 f2     | integer               | not null  | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
    "partial_t1_idx" UNIQUE, btree (f5, abs(f6)) TABLESPACE pg_default WHERE (f5 + f6 - abs(f7)) > 0
    "t1_f3_f4_key" UNIQUE CONSTRAINT, btree (f3, f4) TABLESPACE pg_default
    "t1_f9_key" UNIQUE CONSTRAINT, btree (f9) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Has OIDs: no
Options: orientation=row, compression=no

select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1') order by 1, 2, 3;
 indkey |                                                                                                                                          indexprs                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 2 4    |                                                                                                                                                                                                                                                                                            | 
 3      |                                                                                                                                                                                                                                                                                            | 
 5 6    |                                                                                                                                                                                                                                                                                            | 
 7 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 8 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 8 :location 49}) :location 45 :refSynOid 0}) | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 60} {VAR :varno 1 :varattno 8 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 8 :location 65}) :location 63} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 9 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 9 :location 74}) :location 70 :refSynOid 0}) :location 68} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 80 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 78}
(4 rows)

-- pg_attribute test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f1      |      1 | f         | f
 f2      |      2 | f         | f
 f3      |      3 | f         | f
(3 rows)

alter table t1 add f4 int default 4 first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer | default 4 | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f4      |      1 | t         | f
 f1      |      2 | f         | f
 f2      |      3 | f         | f
 f3      |      4 | f         | f
(4 rows)

alter table t1 drop f2, add f5 int default 5 after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer | default 4 | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer | default 5 | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
           attname            | attnum | atthasdef | attisdropped 
------------------------------+--------+-----------+--------------
 f4                           |      1 | t         | f
 f1                           |      2 | f         | f
 f5                           |      3 | t         | f
 ........pg.dropped.4........ |      4 | f         | t
 f3                           |      5 | f         | f
(5 rows)

-- pg_attrdef test
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 int, f3 int default 3, f4 int generated always as (f2 + f3) stored);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |   adsrc   | adgencol 
-------+-----------+----------
     3 | 3         | 
     4 | (f2 + f3) | s
(2 rows)

alter table t1 add f5 text default 'aaa' first;
\d+ t1
                                         Table "public.t1"
 Column |  Type   |               Modifiers                | Storage  | Stats target | Description 
--------+---------+----------------------------------------+----------+--------------+-------------
 f5     | text    | default 'aaa'::text                    | extended |              | 
 f1     | integer | not null                               | plain    |              | 
 f2     | integer |                                        | plain    |              | 
 f3     | integer | default 3                              | plain    |              | 
 f4     | integer | generated always as ((f2 + f3)) stored | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |    adsrc    | adgencol 
-------+-------------+----------
     1 | 'aaa'::text | 
     4 | 3           | 
     5 | (f2 + f3)   | s
(3 rows)

alter table t1 drop f2, add f6 int generated always as (f1 + abs(f3)) stored after f1;
\d+ t1
                                           Table "public.t1"
 Column |  Type   |                  Modifiers                  | Storage  | Stats target | Description 
--------+---------+---------------------------------------------+----------+--------------+-------------
 f5     | text    | default 'aaa'::text                         | extended |              | 
 f1     | integer | not null                                    | plain    |              | 
 f6     | integer | generated always as ((f1 + abs(f3))) stored | plain    |              | 
 f3     | integer | default 3                                   | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |     adsrc      | adgencol 
-------+----------------+----------
     1 | 'aaa'::text    | 
     3 | (f1 + abs(f3)) | s
     5 | 3              | 
(3 rows)

-- pg_depend test
drop table if exists t1 cascade;
create table t1(f1 int default 10, f2 int primary key, f3 int generated always as (f1 + f2) stored);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select classid, objsubid, refclassid, refobjsubid, deptype from pg_depend
        where refobjid = (select oid from pg_class where relname='t1') or objid = (select oid from pg_class where relname='t1') order by 1, 2, 3, 4, 5;
 classid | objsubid | refclassid | refobjsubid | deptype 
---------+----------+------------+-------------+---------
    1247 |        0 |       1259 |           0 | i
    1259 |        0 |       2615 |           0 | n
    1259 |        3 |       1259 |           1 | a
    1259 |        3 |       1259 |           2 | a
    2604 |        0 |       1259 |           1 | a
    2604 |        0 |       1259 |           3 | a
    2606 |        0 |       1259 |           2 | a
(7 rows)

alter table t1 add t1 add f4 int first;
ERROR:  syntax error at or near "f4"
LINE 1: alter table t1 add t1 add f4 int first;
                                  ^
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f1     | integer | default 10                             | plain   |              | 
 f2     | integer | not null                               | plain   |              | 
 f3     | integer | generated always as ((f1 + f2)) stored | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select classid, objsubid, refclassid, refobjsubid, deptype from pg_depend
        where refobjid = (select oid from pg_class where relname='t1') or objid = (select oid from pg_class where relname='t1') order by 1, 2, 3, 4, 5;
 classid | objsubid | refclassid | refobjsubid | deptype 
---------+----------+------------+-------------+---------
    1247 |        0 |       1259 |           0 | i
    1259 |        0 |       2615 |           0 | n
    1259 |        3 |       1259 |           1 | a
    1259 |        3 |       1259 |           2 | a
    2604 |        0 |       1259 |           1 | a
    2604 |        0 |       1259 |           3 | a
    2606 |        0 |       1259 |           2 | a
(7 rows)

alter table t1 drop f2, add f6 int, add f7 int generated always as (f1 + f6) stored after f1;
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f1     | integer | default 10                             | plain   |              | 
 f7     | integer | generated always as ((f1 + f6)) stored | plain   |              | 
 f6     | integer |                                        | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select classid, objsubid, refclassid, refobjsubid, deptype from pg_depend
        where refobjid = (select oid from pg_class where relname='t1') or objid = (select oid from pg_class where relname='t1') order by 1, 2, 3, 4, 5;
 classid | objsubid | refclassid | refobjsubid | deptype 
---------+----------+------------+-------------+---------
    1247 |        0 |       1259 |           0 | i
    1259 |        0 |       2615 |           0 | n
    1259 |        2 |       1259 |           1 | a
    1259 |        2 |       1259 |           5 | a
    2604 |        0 |       1259 |           1 | a
    2604 |        0 |       1259 |           2 | a
(6 rows)

-- pg_rewrite test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
insert into t1 values(1, 2, 3), (11, 22, 33);
create view t1_view1 as select * from t1;
create view t1_view2 as select f1, f2 from t1;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
View definition:
 SELECT  *
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
   pg_get_viewdef   
--------------------
 SELECT  * FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f2 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

select * from t1_view2;
 f1 | f2 
----+----
  1 |  2
 11 | 22
(2 rows)

select * from t1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

alter table t1 add f4 int first, add f5 int after f1;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2, t1.f3
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
           pg_get_viewdef            
-------------------------------------
 SELECT t1.f1, t1.f2, t1.f3 FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f2 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

select * from t1_view2;
 f1 | f2 
----+----
  1 |  2
 11 | 22
(2 rows)

select * from t1;
 f4 | f1 | f5 | f2 | f3 
----+----+----+----+----
    |  1 |    |  2 |  3
    | 11 |    | 22 | 33
(2 rows)

-- pg_trigger test
drop table if exists t1 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view t1_view1
drop cascades to view t1_view2
create table t1(f1 boolean not null, f2 text, f3 int, f4 date);
alter table t1 add primary key(f1);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create or replace function dummy_update_func() returns trigger as $$
begin
        raise notice 'dummy_update_func(%) called: action = %, oid = %, new = %', TG_ARGV[0], TG_OP, OLD, NEW;
        return new;
end;
$$ language plpgsql;
drop trigger if exists f1_trig_update on t1;
NOTICE:  trigger "t1.f1_trig_update" for table "t1" does not exist, skipping
drop trigger if exists f1_trig_insert on t1;
NOTICE:  trigger "t1.f1_trig_insert" for table "t1" does not exist, skipping
create trigger f1_trig_update after update of f1 on t1 for each row
        when (not old.f1 and new.f1) execute procedure dummy_update_func('update');
create trigger f1_trig_insert after insert on t1 for each row
        when (not new.f1) execute procedure dummy_update_func('insert');
select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 80}) :location 76}
 f1_trig_update | 1      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 86}) :location 82} {VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 97}) :location 93}
(2 rows)

alter table t1 add f5 int after f1, add f6 boolean first;
\d+ t1
                                      Table "public.t1"
 Column |              Type              | Modifiers | Storage  | Stats target | Description 
--------+--------------------------------+-----------+----------+--------------+-------------
 f6     | boolean                        |           | plain    |              | 
 f1     | boolean                        | not null  | plain    |              | 
 f5     | integer                        |           | plain    |              | 
 f2     | text                           |           | extended |              | 
 f3     | integer                        |           | plain    |              | 
 f4     | timestamp(0) without time zone |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Triggers:
    f1_trig_insert AFTER INSERT ON t1 FOR EACH ROW WHEN (NOT new.f1) EXECUTE PROCEDURE dummy_update_func('insert')
    f1_trig_update AFTER UPDATE OF f1 ON t1 FOR EACH ROW WHEN (NOT old.f1 AND new.f1) EXECUTE PROCEDURE dummy_update_func('update')
Has OIDs: no
Options: orientation=row, compression=no

select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 2 :location 80}) :location 76}
 f1_trig_update | 2      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 86}) :location 82} {VAR :varno 2 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 2 :location 97}) :location 93}
(2 rows)

-- pg_rlspolicy test
drop table if exists t1 cascade;
drop role if exists test_rlspolicy;
NOTICE:  role "test_rlspolicy" does not exist, skipping
create role test_rlspolicy nologin password 'Gauss_234';
create table t1 (f1 int, f2 int, f3 text) partition by range (f1)
(
        partition t1_p0 values less than(10),
        partition t1_p1 values less than(50),
        partition t1_p2 values less than(100),
        partition t1_p3 values less than(MAXVALUE)
);
INSERT INTO t1 VALUES (generate_series(1, 150) % 24, generate_series(1, 150), 'huawei');
grant select on t1 to public;
create row level security policy t1_rls1 on t1 as permissive to public using (f2 <= 20);
create row level security policy t1_rls2 on t1 as restrictive to test_rlspolicy using (f1 < 30);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f1     | integer |           | plain    |              | 
 f2     | integer |           | plain    |              | 
 f3     | text    |           | extended |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f1 | f2 |   f3   
----+----+--------
  1 |  1 | huawei
  2 |  2 | huawei
  3 |  3 | huawei
  4 |  4 | huawei
  5 |  5 | huawei
  6 |  6 | huawei
  7 |  7 | huawei
  8 |  8 | huawei
  9 |  9 | huawei
  0 | 24 | huawei
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 2 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 87} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 92 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 90}
(2 rows)

alter table t1 add f4 int generated always as (f1 + 100) stored after f1, add f5 int generated always as (f2 + 100) stored first;
\d+ t1
                                         Table "public.t1"
 Column |  Type   |                Modifiers                | Storage  | Stats target | Description 
--------+---------+-----------------------------------------+----------+--------------+-------------
 f5     | integer | generated always as ((f2 + 100)) stored | plain    |              | 
 f1     | integer |                                         | plain    |              | 
 f4     | integer | generated always as ((f1 + 100)) stored | plain    |              | 
 f2     | integer |                                         | plain    |              | 
 f3     | text    |                                         | extended |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f5  | f1 | f4  | f2 |   f3   
-----+----+-----+----+--------
 101 |  1 | 101 |  1 | huawei
 102 |  2 | 102 |  2 | huawei
 103 |  3 | 103 |  3 | huawei
 104 |  4 | 104 |  4 | huawei
 105 |  5 | 105 |  5 | huawei
 106 |  6 | 106 |  6 | huawei
 107 |  7 | 107 |  7 | huawei
 108 |  8 | 108 |  8 | huawei
 109 |  9 | 109 |  9 | huawei
 124 |  0 | 100 | 24 | huawei
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 4 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 2 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 87} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 92 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 90}
(2 rows)

drop table if exists t1 cascade;
\c postgres
drop database test_first_after_A;
-- test add column ... first | after columnname in B compatibility
create database test_first_after_B dbcompatibility 'b';
\c test_first_after_B
-- test add column ... first | after columnname in astore table
-- ASTORE table
-- common scenatios
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 clob first, add f7 blob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f9     | text                        |           | extended |              | 
 f6     | clob                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f7     | blob                        |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f10    | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f8     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

-- 1 primary key
-- 1.1.1 primary key in original table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 add f6 clob first, add f7 blob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f9     | text                        |           | extended |              | 
 f6     | clob                        |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f7     | blob                        |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f10    | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f8     | integer                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 1.1.2 primary key in original table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 blob first, add f7 clob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

-- 1.2.1 primary key in a table without data, add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
ERROR:  multiple primary keys for table "t1" are not allowed
select * from t1;
 f1 | f2 | f3 | f4 | f5 
----+----+----+----+----
(0 rows)

-- 1.2.2 primary key in a table with data, add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
ERROR:  multiple primary keys for table "t1" are not allowed
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.3.1 primary key in a table without data, drop primary key, then add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1;
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f7     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f8     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f6     | text                        |           | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 1.3.2 primary key in a table with data, drop primary key, then add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
ERROR:  column "f7" contains null values
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.4.1 primary key in a table without data, drop primary key, the add column with primary key and default
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key default 7 first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                         Table "public.t1"
 Column |            Type             |     Modifiers      | Storage  | Stats target | Description 
--------+-----------------------------+--------------------+----------+--------------+-------------
 f7     | integer                     | not null default 7 | plain    |              | 
 f2     | character varying(20)       |                    | extended |              | 
 f3     | timestamp without time zone |                    | plain    |              | 
 f8     | double precision            |                    | plain    |              | 
 f4     | bit(8)                      |                    | extended |              | 
 f5     | boolean                     |                    | plain    |              | 
 f6     | text                        |                    | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 1.4.2 primary key in a table with data, drop primary key, then add column with primary key and default
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 text, add f7 int primary key default 7 first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
ERROR:  could not create unique index "t1_pkey"
DETAIL:  Key (f7)=(7) is duplicated.
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.5.1 primary key in a table without data, drop primary key, the add column with primary key and auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key auto_increment first, add f8 float after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f7     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f8     | double precision            |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
 f6     | text                        |                         | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 1.5.2 primary key in a table with data, drop primary key, the add column with primary key and auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 text, add f7 int primary key auto_increment first, add f8 float after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select * from t1;
 f7 | f2 |               f3                | f8 |    f4    | f5 | f6 
----+----+---------------------------------+----+----------+----+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t  | 
  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f  | 
(2 rows)

-- 2 unique index
-- 2.1.1 unique index in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 2.1.2 unique index in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.2.1 unique index in a table without data, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
    "t1_f6_key" UNIQUE CONSTRAINT, btree (f6) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 2.2.2 unique index in a table with data, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.3.1 unique index in a table without data, drop unique index, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 drop f1, add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f6_key" UNIQUE CONSTRAINT, btree (f6) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 2.3.2 unique index in a table with data, drop unique index, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.4.1 unique index in a table without data, drop unique index, add column with unique index and default
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int unique default 6 first;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
alter table t1 drop f1, add f7 float unique default 7 after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f6_key" UNIQUE CONSTRAINT, btree (f6) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, btree (f7) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 2.4.2 unique index in a table with data, drop unique index, add column with unique index and default
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 int unique default 6 first;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
ERROR:  could not create unique index "t1_f6_key"
DETAIL:  Key (f6)=(6) is duplicated.
alter table t1 drop f1;
-- error
alter table t1 add f7 float unique default 7 after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
ERROR:  could not create unique index "t1_f7_key"
DETAIL:  Key (f7)=(7) is duplicated.
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 3 default and generated column
-- 3.1.1 default in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 add f6 int first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     | default 1 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 3.1.2 default in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 3.2.1 default in a table without data, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 add f6 int default 6 first, add f7 float default 7 after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f1     | integer                     | default 1 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 3.2.2 default in a table with data, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int default 6 first, add f7 float default 7 after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
  6 |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |  7 | 01000001 | t
  6 |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |  7 | 01000010 | f
(2 rows)

-- 3.3.1 default in a table without data, drop default, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 drop f1, add f6 int default 6 first, add f7 float default 7 after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 3.3.2 default in a table with data, drop default, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int default 1 first, add f7 float default 7 after f3;
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 |  7 | 01000001 | t
  1 | b  | Wed Nov 09 19:56:10.158564 2022 |  7 | 01000010 | f
(2 rows)

-- 3.4.1 generated column in a table without data, drop generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
alter table t1 drop f1, add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f3*10) stored after f5;
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f5     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
 f6     | integer | generated always as ((f3 * 10)) stored | plain   |              | 
 f2     | integer | default 2                              | plain   |              | 
 f3     | integer | default 3                              | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 3.4.1 generated column in a table with data, drop generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
insert into t1 values(1, 2, 3), (11, 22, 33);
alter table t1 drop f1, add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f3*10) stored after f5;
select * from t1;
 f5 | f6  | f2 | f3 
----+-----+----+----
  5 |  30 |  2 |  3
 55 | 330 | 22 | 33
(2 rows)

-- 3.5.1 generated column in a table without data, add generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
alter table t1 add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f2 + f3) stored after f5;
\d+ t1;
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f5     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
 f6     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
 f1     | integer |                                        | plain   |              | 
 f2     | integer | default 2                              | plain   |              | 
 f3     | integer | default 3                              | plain   |              | 
 f4     | integer | generated always as ((f1 + f2)) stored | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 3.5.2 generated column in table with data, add generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
insert into t1 values(1, 2, 3), (11, 22, 33);
alter table t1 add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f1 + f3) stored after f5;
select * from t1;
 f5 | f6 | f1 | f2 | f3 | f4 
----+----+----+----+----+----
  5 |  4 |  1 |  2 |  3 |  3
 55 | 44 | 11 | 22 | 33 | 33
(2 rows)

-- 4 auto_increment
-- 4.1.1 auto_increment in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 add f6 text first, add f7 float after f3;
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f6     | text                        |                         | extended |              | 
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f7     | double precision            |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 4.1.2 auto_increment in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 text first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 4.2.1 auto_increment in a table without data, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- error
alter table t1 add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  Incorrect column definition, there can be only one auto_increment column
-- error
alter table t1 add f7 int primary key auto_increment after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
ERROR:  Incorrect column definition, there can be only one auto_increment column
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 4.2.2 auto_increment in a table with data, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  Incorrect column definition, there can be only one auto_increment column
-- error
alter table t1 add f7 int primary key auto_increment after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
ERROR:  Incorrect column definition, there can be only one auto_increment column
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 4.3.1 auto_increment in a table without data, drop auto_increment, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f6     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f6) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

-- 4.3.2 auto_increment in a table with data, drop auto_increment, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- 4.4.1 auto_increment in a table without data, drop auto_increment, add column with auto_increment and default
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1;
-- error
alter table t1 add f6 int primary key auto_increment default 6 first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  multiple default values specified for column "f6" of table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 4.4.2 auto_increment in a table with data, drop auto_increment, add column with auto_increment and default
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 int primary key auto_increment default 6 first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  multiple default values specified for column "f6" of table "t1"
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5 NULL and NOT NULL
-- 5.1.1 null and not null in a table without data, add column without constraints
drop table if exists t1 cascade;
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 add f6 text first, add f7 float after f3;
ERROR:  relation "t1" does not exist
\d+ t1
-- 5.1.2 null and not null in a table with data, add column without constraints
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  relation "t1" does not exist on datanode1
LINE 1: insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', ...
                    ^
alter table t1 add f6 text first, add f7 float after f3;
ERROR:  relation "t1" does not exist
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
-- 5.2.1 null and not null in table without data, add column with null or not null
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 add f6 int null first;
ERROR:  relation "t1" does not exist
alter table t1 add f7 float not null after f3;
ERROR:  relation "t1" does not exist
\d+ t1
-- 5.2.2 null and not null in a table with data, add column with null or not null
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 | f1 | f2 |               f3                |    f4    | f5 
----+----+----+---------------------------------+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5.3.1 null and not null in a table without data, drop null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
alter table t1 drop f1, add f6 int null first, add f7 float not null after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f2     | character varying(20)       | not null  | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | not null  | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 5.3.2 null and not null in a table with data, drop null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
    | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5.4.1 null and not null in a table without data, drop null and not null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
alter table t1 drop f1, drop f2, add f6 int null first, add f7 float not null after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | not null  | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- 5.4.2 null and not null in a table without data, drop null and not null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, drop f2, add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
    | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 6 check constraint
-- 6.1.1 check constraint in a table without data, add column without constraint
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 add f6 text first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | text                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

-- 6.1.2 check constraint in a table with data, add column without constraint
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  new row for relation "t1" violates check constraint "t1_f1_check"
DETAIL:  N/A
alter table t1 add f6 text first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 | f3 | f7 | f4 | f5 
----+----+----+----+----+----+----
(0 rows)

-- 6.2.1 check constraint in a table without data, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 add f6 int default 6, add f7 text check(f6 = 6) first, add f8 float check(f1 + f2 == 7);
ERROR:  operator does not exist: bigint == integer
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

-- 6.2.2 check constraint in a table with data, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (1, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int default 6, add f7 text check(f6 = 6) first, add f8 float check(f1 + f2 == 7) after f3;
ERROR:  operator does not exist: bigint == integer
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  1 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 6.3.1 check constraint in a table without data, drop check, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 drop f2, add f6 text check (f1 > 0) first, add f7 int check (f7 - f1 > 0) after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | text                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | integer                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_check" CHECK ((f7 - f1) > 0)
    "t1_f1_check" CHECK (f1 = 1)
    "t1_f1_check1" CHECK (f1 > 0)
Has OIDs: no
Options: orientation=row, compression=no

-- 6.3.2 check constraint in a table with data, drop check, add column with with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (1, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f2, add f6 text check (f1 > 0) first, add f7 int check(f7 - f1 > 0) after f3;
select * from t1;
 f6 | f1 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    |  1 | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  1 | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 7 foreign key
-- 7.1.1 foreign key constraint in a table without data, add column without constraint
drop table if exists t_pri1 cascade;
NOTICE:  table "t_pri1" does not exist, skipping
create table t_pri1(f1 int, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
alter table t1 add f4 int, add f5 text first, f6 float after f2;
ERROR:  syntax error at or near "f6"
LINE 1: alter table t1 add f4 int, add f5 text first, f6 float after...
                                                      ^
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, compression=no

-- 7.1.2 foreign key constraint in a table with data, add column without constraint
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
create table t_pri1(f1 text, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t1(f1 text, f2 int references t_pri1(f2), f3 bool);
insert into t1 values('a', 1, true), ('b', 2, false);
alter table t1 add f4 int, add f5 text first, f6 float after f2;
ERROR:  syntax error at or near "f6"
LINE 1: alter table t1 add f4 int, add f5 text first, f6 float after...
                                                      ^
select * from t1;
 f1 | f2 | f3 
----+----+----
 a  |  1 | t
 b  |  2 | f
(2 rows)

-- 7.2.1 foreign key constraint in a table without data, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
NOTICE:  table "t_pri2" does not exist, skipping
create table t_pri1(f1 text, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
create table t_pri2(f1 int, f2 int, f4 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
alter table t1 add f4 int references t_pri2(f4) first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f4, add f4 int references t_pri2(f4) after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, compression=no

-- 7.2.2 foreign key constraint in a table with data, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 text, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t_pri2(f1 int, f2 bool, f4 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
insert into t_pri2 values(11, true, 1), (22, false, 2);
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
insert into t1 values(1, 1, true), (2, 2, false);
alter table t1 add f4 int references t_pri2(f4) first;
select * from t1;
 f4 | f1 | f2 | f3 
----+----+----+----
    |  1 |  1 | t
    |  2 |  2 | f
(2 rows)

alter table t1 drop f4, add f4 int references t_pri2(f4) after f2;
select * from t1;
 f1 | f2 | f4 | f3 
----+----+----+----
  1 |  1 |    | t
  2 |  2 |    | f
(2 rows)

-- 7.3.1 foreign key constraint in a table without data, drop foreign key, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 int, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
create table t_pri2(f1 int, f2 int, f4 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
alter table t1 drop f2, add f4 int references t_pri2(f4) first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f4, add f4 int references t_pri2(f4) after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, compression=no

-- 7.3.2 foreign key constraint in a table with data, drop foreign key, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 text, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t_pri2(f1 text, f2 bool, f4 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
insert into t_pri2 values('a', true, 1), ('b', false, 2);
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
insert into t1 values(1, 2, true), (2, 2, false);
alter table t1 drop f2, add f4 int references t_pri2(f4) first;
select * from t1;
 f4 | f1 | f3 
----+----+----
    |  1 | t
    |  2 | f
(2 rows)

alter table t1 drop f4, add f4 int references t_pri2(f4) after f1;
select * from t1;
 f1 | f4 | f3 
----+----+----
  1 |    | t
  2 |    | f
(2 rows)

-- partition table
drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int)
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 add f4 int first, add f5 int after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 4
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

-- subpartition table
drop table if exists range_range cascade;
NOTICE:  table "range_range" does not exist, skipping
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
-- test pg_partition
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range add f1 int default 1 first, add f2 text after id;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 f1       | integer           | default 1 | plain    |              | 
 id       | integer           |           | plain    |              | 
 f2       | text              |           | extended |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 5
 p_2         | p        | 5
 p_3         | p        | 5
 range_range | r        | 2
(4 rows)

select * from range_range;
 f1 | id  | f2 | gender |  birthday  
----+-----+----+--------+------------
  1 |  33 |    | boy    | 08-11-2003
  1 |  78 |    | girl   | 06-24-2014
  1 |  15 |    | girl   | 01-12-2009
  1 | 198 |    | boy    | 02-15-2010
  1 | 146 |    | girl   | 03-08-2005
  1 | 111 |    | girl   | 11-19-2013
  1 | 156 |    | boy    | 05-21-2011
  1 | 233 |    | girl   | 01-01-2010
  1 | 360 |    | boy    | 05-14-2007
(9 rows)

-- USTORE table
-- common scenatios
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 clob first, add f7 blob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f9     | text                        |           | extended |              | 
 f6     | clob                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f7     | blob                        |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f10    | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f8     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

-- 1 primary key
-- 1.1.1 primary key in original table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 add f6 clob first, add f7 blob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f9     | text                        |           | extended |              | 
 f6     | clob                        |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f7     | blob                        |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f10    | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f8     | integer                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 1.1.2 primary key in original table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 blob first, add f7 clob after f2;
alter table t1 add f8 int, add f9 text first, add f10 float after f3;
select * from t1;
 f9 | f6 | f1 | f2 | f7 |               f3                | f10 |    f4    | f5 | f8 
----+----+----+----+----+---------------------------------+-----+----------+----+----
    |    |  1 | a  |    | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  |   
    |    |  2 | b  |    | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  |   
(2 rows)

-- 1.2.1 primary key in a table without data, add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
ERROR:  multiple primary keys for table "t1" are not allowed
select * from t1;
 f1 | f2 | f3 | f4 | f5 
----+----+----+----+----
(0 rows)

-- 1.2.2 primary key in a table with data, add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
ERROR:  multiple primary keys for table "t1" are not allowed
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.3.1 primary key in a table without data, drop primary key, then add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1;
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f7     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f8     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f6     | text                        |           | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 1.3.2 primary key in a table with data, drop primary key, then add column with primary key
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 text, add f7 int primary key first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
ERROR:  column "f7" contains null values
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.4.1 primary key in a table without data, drop primary key, the add column with primary key and default
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key default 7 first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                         Table "public.t1"
 Column |            Type             |     Modifiers      | Storage  | Stats target | Description 
--------+-----------------------------+--------------------+----------+--------------+-------------
 f7     | integer                     | not null default 7 | plain    |              | 
 f2     | character varying(20)       |                    | extended |              | 
 f3     | timestamp without time zone |                    | plain    |              | 
 f8     | double precision            |                    | plain    |              | 
 f4     | bit(8)                      |                    | extended |              | 
 f5     | boolean                     |                    | plain    |              | 
 f6     | text                        |                    | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 1.4.2 primary key in a table with data, drop primary key, then add column with primary key and default
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 text, add f7 int primary key default 7 first, add f8 float after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
ERROR:  could not create unique index "t1_pkey"
DETAIL:  Key (f7)=(7) is duplicated.
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 1.5.1 primary key in a table without data, drop primary key, the add column with primary key and auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 text, add f7 int primary key auto_increment first, add f8 float after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f7     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f8     | double precision            |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
 f6     | text                        |                         | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 1.5.2 primary key in a table with data, drop primary key, the add column with primary key and auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 text, add f7 int primary key auto_increment first, add f8 float after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select * from t1;
 f7 | f2 |               f3                | f8 |    f4    | f5 | f6 
----+----+---------------------------------+----+----------+----+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t  | 
  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f  | 
(2 rows)

-- 2 unique index
-- 2.1.1 unique index in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 2.1.2 unique index in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.2.1 unique index in a table without data, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f6_key" UNIQUE CONSTRAINT, ubtree (f6) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 2.2.2 unique index in a table with data, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.3.1 unique index in a table without data, drop unique index, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 drop f1, add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f6_key" UNIQUE CONSTRAINT, ubtree (f6) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 2.3.2 unique index in a table with data, drop unique index, add column with unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int unique first, add f7 float unique after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 2.4.1 unique index in a table without data, drop unique index, add column with unique index and default
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 add f6 int unique default 6 first;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
alter table t1 drop f1, add f7 float unique default 7 after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f6_key" UNIQUE CONSTRAINT, ubtree (f6) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f7_key" UNIQUE CONSTRAINT, ubtree (f7) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 2.4.2 unique index in a table with data, drop unique index, add column with unique index and default
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 int unique default 6 first;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f6_key" for table "t1"
ERROR:  could not create unique index "t1_f6_key"
DETAIL:  Key (f6)=(6) is duplicated.
alter table t1 drop f1;
-- error
alter table t1 add f7 float unique default 7 after f3;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f7_key" for table "t1"
ERROR:  could not create unique index "t1_f7_key"
DETAIL:  Key (f7)=(7) is duplicated.
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 3 default and generated column
-- 3.1.1 default in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 add f6 int first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f1     | integer                     | default 1 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 3.1.2 default in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 3.2.1 default in a table without data, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 add f6 int default 6 first, add f7 float default 7 after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f1     | integer                     | default 1 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 3.2.2 default in a table with data, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int default 6 first, add f7 float default 7 after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
  6 |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |  7 | 01000001 | t
  6 |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |  7 | 01000010 | f
(2 rows)

-- 3.3.1 default in a table without data, drop default, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 drop f1, add f6 int default 6 first, add f7 float default 7 after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     | default 6 | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | default 7 | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 3.3.2 default in a table with data, drop default, add column with default
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int default 1 first, add f7 float default 7 after f3;
select * from t1;
 f6 | f2 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 |  7 | 01000001 | t
  1 | b  | Wed Nov 09 19:56:10.158564 2022 |  7 | 01000010 | f
(2 rows)

-- 3.4.1 generated column in a table without data, drop generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with (storage_type = ustore);
alter table t1 drop f1, add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f3*10) stored after f5;
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f5     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
 f6     | integer | generated always as ((f3 * 10)) stored | plain   |              | 
 f2     | integer | default 2                              | plain   |              | 
 f3     | integer | default 3                              | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 3.4.1 generated column in a table with data, drop generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with (storage_type = ustore);
insert into t1 values(1, 2, 3), (11, 22, 33);
alter table t1 drop f1, add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f3*10) stored after f5;
select * from t1;
 f5 | f6  | f2 | f3 
----+-----+----+----
  5 |  30 |  2 |  3
 55 | 330 | 22 | 33
(2 rows)

-- 3.5.1 generated column in a table without data, add generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with (storage_type = ustore);
alter table t1 add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f1 + f3) stored after f5;
\d+ t1;
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f5     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
 f6     | integer | generated always as ((f1 + f3)) stored | plain   |              | 
 f1     | integer |                                        | plain   |              | 
 f2     | integer | default 2                              | plain   |              | 
 f3     | integer | default 3                              | plain   |              | 
 f4     | integer | generated always as ((f1 + f2)) stored | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 3.5.2 generated column in table with data, add generated column
drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with (storage_type = ustore);
insert into t1 values(1, 2, 3), (11, 22, 33);
alter table t1 add f5 int generated always as (f2 + f3) stored first, add f6 int generated always as (f1 + f3) stored after f5;
select * from t1 cascade;
 f5 | f6 | f1 | f2 | f3 | f4 
----+----+----+----+----+----
  5 |  4 |  1 |  2 |  3 |  3
 55 | 44 | 11 | 22 | 33 | 33
(2 rows)

-- 4 auto_increment
-- 4.1.1 auto_increment in a table without data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 add f6 text first, add f7 float after f3;
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f6     | text                        |                         | extended |              | 
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f7     | double precision            |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 4.1.2 auto_increment in a table with data, add column without constraints
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 text first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 |               f3                | f7 |    f4    | f5 
----+----+----+---------------------------------+----+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 4.2.1 auto_increment in a table without data, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- error
alter table t1 add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  Incorrect column definition, there can be only one auto_increment column
-- error
alter table t1 add f7 int primary key auto_increment after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
ERROR:  Incorrect column definition, there can be only one auto_increment column
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 4.2.2 auto_increment in a table with data, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  Incorrect column definition, there can be only one auto_increment column
-- error
alter table t1 add f7 int primary key auto_increment after f3;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f7_seq" for serial column "t1.f7"
ERROR:  Incorrect column definition, there can be only one auto_increment column
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 4.3.1 auto_increment in a table without data, drop auto_increment, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1, add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f6     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f6) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 4.3.2 auto_increment in a table with data, drop auto_increment, add column with auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int primary key auto_increment first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
-- 4.4.1 auto_increment in a table without data, drop auto_increment, add column with auto_increment and default
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
alter table t1 drop f1;
-- error
alter table t1 add f6 int primary key auto_increment default 6 first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  multiple default values specified for column "f6" of table "t1"
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 4.4.2 auto_increment in a table with data, drop auto_increment, add column with auto_increment and default
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1;
-- error
alter table t1 add f6 int primary key auto_increment default 6 first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f6_seq" for serial column "t1.f6"
ERROR:  multiple default values specified for column "f6" of table "t1"
select * from t1;
 f2 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
 a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
 b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5 NULL and NOT NULL
-- 5.1.1 null and not null in a table without data, add column without constraints
drop table if exists t1 cascade;
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 add f6 text first, add f7 float after f3;
ERROR:  relation "t1" does not exist
\d+ t1
-- 5.1.2 null and not null in a table with data, add column without constraints
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  relation "t1" does not exist on datanode1
LINE 1: insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', ...
                    ^
alter table t1 add f6 text first, add f7 float after f3;
ERROR:  relation "t1" does not exist
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
-- 5.2.1 null and not null in table without data, add column with null or not null
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 add f6 int null first, add f7 float not null after f3;
ERROR:  relation "t1" does not exist
\d+ t1
-- 5.2.2 null and not null in a table with data, add column with null or not null
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 | f1 | f2 |               f3                |    f4    | f5 
----+----+----+---------------------------------+----------+----
    |  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    |  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5.3.1 null and not null in a table without data, drop null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 drop f1, add f6 int null first, add f7 float not null after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f2     | character varying(20)       | not null  | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | not null  | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 5.3.2 null and not null in a table with data, drop null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
    | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 5.4.1 null and not null in a table without data, drop null and not null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 drop f1, drop f2, add f6 int null first, add f7 float not null after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | integer                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            | not null  | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 5.4.2 null and not null in a table without data, drop null and not null, add column with null or not null
drop table if exists t1 cascade;
create table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f1, drop f2, add f6 int null first;
-- error
alter table t1 add f7 float not null after f3;
ERROR:  column "f7" contains null values
select * from t1;
 f6 |               f3                |    f4    | f5 
----+---------------------------------+----------+----
    | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
    | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 6 check constraint
-- 6.1.1 check constraint in a table without data, add column without constraint
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 add f6 text first, add f7 float after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | text                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | double precision            |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 6.1.2 check constraint in a table with data, add column without constraint
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  new row for relation "t1" violates check constraint "t1_f1_check"
DETAIL:  N/A
alter table t1 add f6 text first, add f7 float after f3;
select * from t1;
 f6 | f1 | f2 | f3 | f7 | f4 | f5 
----+----+----+----+----+----+----
(0 rows)

-- 6.2.1 check constraint in a table without data, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 add f6 int default 6, add f7 text check(f6 = 6) first, add f8 float check(f1 + f2 == 7);
ERROR:  operator does not exist: bigint == integer
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 6.2.2 check constraint in a table with data, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (1, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 add f6 int default 6, add f7 text check(f6 = 6) first, add f8 float check(f1 + f2 == 7) after f3;
ERROR:  operator does not exist: bigint == integer
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  1 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

-- 6.3.1 check constraint in a table without data, drop check, add column with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
alter table t1 drop f2, add f6 text check (f1 > 0) first, add f7 int check (f7 - f1 > 0) after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f6     | text                        |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f7     | integer                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_check" CHECK ((f7 - f1) > 0)
    "t1_f1_check" CHECK (f1 = 1)
    "t1_f1_check1" CHECK (f1 > 0)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no, toast.storage_type=USTORE

-- 6.3.2 check constraint in a table with data, drop check, add column with with check
drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (1, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f2, add f6 text check (f1 > 0) first, add f7 int check(f7 - f1 > 0) after f3;
select * from t1;
 f6 | f1 |               f3                | f7 |    f4    | f5 
----+----+---------------------------------+----+----------+----
    |  1 | Tue Nov 08 19:56:10.158564 2022 |    | 01000001 | t
    |  1 | Wed Nov 09 19:56:10.158564 2022 |    | 01000010 | f
(2 rows)

-- 7 foreign key
-- 7.1.1 foreign key constraint in a table without data, add column without constraint
drop table if exists t_pri1 cascade;
create table t_pri1(f1 int, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
alter table t1 add f4 int, add f5 text first, f6 float after f2;
ERROR:  syntax error at or near "f6"
LINE 1: alter table t1 add f4 int, add f5 text first, f6 float after...
                                                      ^
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 7.1.2 foreign key constraint in a table with data, add column without constraint
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
create table t_pri1(f1 text, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t1(f1 text, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
insert into t1 values('a', 1, true), ('b', 2, false);
alter table t1 add f4 int, add f5 text first, f6 float after f2;
ERROR:  syntax error at or near "f6"
LINE 1: alter table t1 add f4 int, add f5 text first, f6 float after...
                                                      ^
select * from t1;
 f1 | f2 | f3 
----+----+----
 a  |  1 | t
 b  |  2 | f
(2 rows)

-- 7.2.1 foreign key constraint in a table without data, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 text, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
create table t_pri2(f1 int, f2 int, f4 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
alter table t1 add f4 int references t_pri2(f4) first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f4, add f4 int references t_pri2(f4) after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 7.2.2 foreign key constraint in a table with data, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 text, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t_pri2(f1 int, f2 bool, f4 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
insert into t_pri2 values(11, true, 1), (22, false, 2);
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
insert into t1 values(1, 1, true), (2, 2, false);
alter table t1 add f4 int references t_pri2(f4) first;
select * from t1;
 f4 | f1 | f2 | f3 
----+----+----+----
    |  1 |  1 | t
    |  2 |  2 | f
(2 rows)

alter table t1 drop f4, add f4 int references t_pri2(f4) after f2;
select * from t1;
 f1 | f2 | f4 | f3 
----+----+----+----
  1 |  1 |    | t
  2 |  2 |    | f
(2 rows)

-- 7.3.1 foreign key constraint in a table without data, drop foreign key, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 int, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
create table t_pri2(f1 int, f2 int, f4 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
alter table t1 drop f2, add f4 int references t_pri2(f4) first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f4, add f4 int references t_pri2(f4) after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f4_fkey" FOREIGN KEY (f4) REFERENCES t_pri2(f4)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

-- 7.3.2 foreign key constraint in a table with data, drop foreign key, add column with foreign key
drop table if exists t1 cascade;
drop table if exists t_pri1 cascade;
drop table if exists t_pri2 cascade;
create table t_pri1(f1 text, f2 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values('a', 1), ('b', 2);
create table t_pri2(f1 text, f2 bool, f4 int primary key) with (storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri2_pkey" for table "t_pri2"
insert into t_pri2 values('a', true, 1), ('b', false, 2);
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with (storage_type = ustore);
insert into t1 values(1, 2, true), (2, 2, false);
alter table t1 drop f2, add f4 int references t_pri2(f4) first;
select * from t1;
 f4 | f1 | f3 
----+----+----
    |  1 | t
    |  2 | f
(2 rows)

alter table t1 drop f4, add f4 int references t_pri2(f4) after f1;
select * from t1;
 f1 | f4 | f3 
----+----+----
  1 |    | t
  2 |    | f
(2 rows)

-- partition table
drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int) with (storage_type = ustore)
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 add f4 int first, add f5 int after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 4
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

-- subpartition table
drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null) with (storage_type = ustore)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
-- test pg_partition
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range add f1 int default 1 first, add f2 text after id;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 f1       | integer           | default 1 | plain    |              | 
 id       | integer           |           | plain    |              | 
 f2       | text              |           | extended |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 5
 p_2         | p        | 5
 p_3         | p        | 5
 range_range | r        | 2
(4 rows)

select * from range_range;
 f1 | id  | f2 | gender |  birthday  
----+-----+----+--------+------------
  1 |  33 |    | boy    | 08-11-2003
  1 |  78 |    | girl   | 06-24-2014
  1 |  15 |    | girl   | 01-12-2009
  1 | 198 |    | boy    | 02-15-2010
  1 | 146 |    | girl   | 03-08-2005
  1 | 111 |    | girl   | 11-19-2013
  1 | 156 |    | boy    | 05-21-2011
  1 | 233 |    | girl   | 01-01-2010
  1 | 360 |    | boy    | 05-14-2007
(9 rows)

-- orientation = column not support
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (orientation = column);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 add f6 text first;
ERROR:  Un-supported feature
DETAIL:  column orientated table is not supported for add column first|after columnName
-- error
alter table t1 add f6 text after f1;
ERROR:  Un-supported feature
DETAIL:  column orientated table is not supported for add column first|after columnName
-- pg_constraint test
set enable_default_ustore_table = on;
drop table if exists t_pri cascade;
NOTICE:  table "t_pri" does not exist, skipping
drop table if exists t1 cascade;
create table t_pri(f1 int, f2 int, f3 int, primary key(f2, f3));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri_pkey" for table "t_pri"
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        foreign key(f1, f2) references t_pri(f2, f3),
        unique((lower(f3)), (abs(f4))),
        check(f5 = 10),
        unique(f4, f5) include(f6, f7)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_lower_abs_key" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f4_f5_f6_f7_key" for table "t1"
select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                 conbin                                                                                                                                                                                                                                                                  |  consrc   | conincluding 
--------------------+---------+--------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {1,2}  | {2,3}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f4_f5_f6_f7_key | u       | {4,5}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | {6,7}
 t1_f5_check        | c       | {5}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 198} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 203 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 201} | (f5 = 10) | 
 t1_lower_abs_key   | u       | {0,0}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
(4 rows)

alter table t_pri add f4 int first, add f5 int after f2;
alter table t1 add f8 int primary key first, add f9 int unique after f3;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f9_key" for table "t1"
\d+ t_pri
                        Table "public.t_pri"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f5     | integer |           | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "t_pri_pkey" PRIMARY KEY, ubtree (f2, f3) WITH (storage_type=USTORE) TABLESPACE pg_default
Referenced by:
    TABLE "t1" CONSTRAINT "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't_pri') order by conname;
  conname   | contype | conkey | confkey | conbin | consrc | conincluding 
------------+---------+--------+---------+--------+--------+--------------
 t_pri_pkey | p       | {3,5}  |         |        |        | 
(1 row)

\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f8     | integer               | not null  | plain    |              | 
 f1     | integer               |           | plain    |              | 
 f2     | integer               |           | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f9     | integer               |           | plain    |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f8) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f4_f5_f6_f7_key" UNIQUE CONSTRAINT, ubtree (f4, f5) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_f9_key" UNIQUE CONSTRAINT, ubtree (f9) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_lower_abs_key" UNIQUE CONSTRAINT, ubtree (lower(f3::text), abs(f4)) WITH (storage_type=USTORE) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Foreign-key constraints:
    "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                 conbin                                                                                                                                                                                                                                                                  |  consrc   | conincluding 
--------------------+---------+--------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {2,3}  | {3,5}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f4_f5_f6_f7_key | u       | {6,7}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | {8,9}
 t1_f5_check        | c       | {7}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 198} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 203 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 201} | (f5 = 10) | 
 t1_f9_key          | u       | {5}    |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_lower_abs_key   | u       | {0,0}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_pkey            | p       | {1}    |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
(6 rows)

set enable_default_ustore_table = off;
-- pg_index test
drop table if exists t1 cascade;
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        primary key(f1, f2),
        unique((lower(f3)), (abs(f4))),
        check(f5 = 10)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_lower_abs_key" for table "t1"
create unique index partial_t1_idx on t1(f5, abs(f6)) where f5 + f6 - abs(f7) > 0;
select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1') order by 1, 2, 3;
 indkey |                                                                                                                                                                                                                                                                                                                                             indexprs                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 0 0    | ({FUNCEXPR :funcid 870 :funcresulttype 25 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 100 :inputcollid 100 :args ({RELABELTYPE :arg {VAR :varno 1 :varattno 3 :vartype 1043 :vartypmod 24 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 3 :location 141} :resulttype 25 :resulttypmod -1 :resultcollid 100 :relabelformat 2 :location -1}) :location 135 :refSynOid 0} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 4 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 152}) :location 148 :refSynOid 0}) | 
 1 2    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 
 5 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 49}) :location 45 :refSynOid 0})                                                                                                                                                                                                                                                                                                                                                                                                        | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 60} {VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 65}) :location 63} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 74}) :location 70 :refSynOid 0}) :location 68} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 80 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 78}
(3 rows)

alter table t1 add f8 int first, add f9 int unique after f1;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "t1_f9_key" for table "t1"
\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f8     | integer               |           | plain    |              | 
 f1     | integer               | not null  | plain    |              | 
 f9     | integer               |           | plain    |              | 
 f2     | integer               | not null  | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
    "partial_t1_idx" UNIQUE, btree (f5, abs(f6)) TABLESPACE pg_default WHERE (f5 + f6 - abs(f7)) > 0
    "t1_f9_key" UNIQUE CONSTRAINT, btree (f9) TABLESPACE pg_default
    "t1_lower_abs_key" UNIQUE CONSTRAINT, btree (lower(f3::text), abs(f4)) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Has OIDs: no
Options: orientation=row, compression=no

select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1') order by 1, 2, 3;
 indkey |                                                                                                                                                                                                                                                                                                                                             indexprs                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 0 0    | ({FUNCEXPR :funcid 870 :funcresulttype 25 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 100 :inputcollid 100 :args ({RELABELTYPE :arg {VAR :varno 1 :varattno 5 :vartype 1043 :vartypmod 24 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 141} :resulttype 25 :resulttypmod -1 :resultcollid 100 :relabelformat 2 :location -1}) :location 135 :refSynOid 0} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 152}) :location 148 :refSynOid 0}) | 
 2 4    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 
 3      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 
 7 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 8 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 8 :location 49}) :location 45 :refSynOid 0})                                                                                                                                                                                                                                                                                                                                                                                                        | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 60} {VAR :varno 1 :varattno 8 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 8 :location 65}) :location 63} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 9 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 9 :location 74}) :location 70 :refSynOid 0}) :location 68} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 80 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 78}
(4 rows)

-- pg_attribute test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f1      |      1 | f         | f
 f2      |      2 | f         | f
 f3      |      3 | f         | f
(3 rows)

alter table t1 add f4 int default 4 first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer | default 4 | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f4      |      1 | t         | f
 f1      |      2 | f         | f
 f2      |      3 | f         | f
 f3      |      4 | f         | f
(4 rows)

alter table t1 drop f2, add f5 int default 5 after f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer | default 4 | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer | default 5 | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
           attname            | attnum | atthasdef | attisdropped 
------------------------------+--------+-----------+--------------
 f4                           |      1 | t         | f
 f1                           |      2 | f         | f
 f5                           |      3 | t         | f
 ........pg.dropped.4........ |      4 | f         | t
 f3                           |      5 | f         | f
(5 rows)

-- pg_attrdef test
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 int, f3 int default 3, f4 int generated always as (f2 + f3) stored);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |     adsrc      | adgencol 
-------+----------------+----------
     1 | AUTO_INCREMENT | 
     3 | 3              | 
     4 | (f2 + f3)      | s
(3 rows)

alter table t1 add f5 text default 'aaa' first;
\d+ t1
                                         Table "public.t1"
 Column |  Type   |               Modifiers                | Storage  | Stats target | Description 
--------+---------+----------------------------------------+----------+--------------+-------------
 f5     | text    | default 'aaa'::text                    | extended |              | 
 f1     | integer | not null AUTO_INCREMENT                | plain    |              | 
 f2     | integer |                                        | plain    |              | 
 f3     | integer | default 3                              | plain    |              | 
 f4     | integer | generated always as ((f2 + f3)) stored | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |     adsrc      | adgencol 
-------+----------------+----------
     1 | 'aaa'::text    | 
     2 | AUTO_INCREMENT | 
     4 | 3              | 
     5 | (f2 + f3)      | s
(4 rows)

alter table t1 drop f2, add f6 int generated always as (f1 + abs(f3)) stored after f1; -- ERROR
ERROR:  generated column cannot refer to auto_increment column
-- pg_rewrite test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
insert into t1 values(1, 2, 3), (11, 22, 33);
create view t1_view1 as select * from t1;
create view t1_view2 as select f1, f2 from t1;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
View definition:
 SELECT  *
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
   pg_get_viewdef   
--------------------
 SELECT  * FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f2 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

select * from t1_view2;
 f1 | f2 
----+----
  1 |  2
 11 | 22
(2 rows)

select * from t1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

alter table t1 add f4 int first, add f5 int after f1;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2, t1.f3
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
           pg_get_viewdef            
-------------------------------------
 SELECT t1.f1, t1.f2, t1.f3 FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f2 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

select * from t1_view2;
 f1 | f2 
----+----
  1 |  2
 11 | 22
(2 rows)

select * from t1;
 f4 | f1 | f5 | f2 | f3 
----+----+----+----+----
    |  1 |    |  2 |  3
    | 11 |    | 22 | 33
(2 rows)

-- pg_trigger test
drop table if exists t1 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view t1_view1
drop cascades to view t1_view2
create table t1(f1 boolean not null, f2 text, f3 int, f4 date);
alter table t1 add primary key(f1);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create or replace function dummy_update_func() returns trigger as $$
begin
        raise notice 'dummy_update_func(%) called: action = %, oid = %, new = %', TG_ARGV[0], TG_OP, OLD, NEW;
        return new;
end;
$$ language plpgsql;
drop trigger if exists f1_trig_update on t1;
NOTICE:  trigger "t1.f1_trig_update" for table "t1" does not exist, skipping
drop trigger if exists f1_trig_insert on t1;
NOTICE:  trigger "t1.f1_trig_insert" for table "t1" does not exist, skipping
create trigger f1_trig_update after update of f1 on t1 for each row
        when (not old.f1 and new.f1) execute procedure dummy_update_func('update');
create trigger f1_trig_insert after insert on t1 for each row
        when (not new.f1) execute procedure dummy_update_func('insert');
select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 80}) :location 76}
 f1_trig_update | 1      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 86}) :location 82} {VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 97}) :location 93}
(2 rows)

alter table t1 add f5 int after f1, add f6 boolean first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f6     | boolean |           | plain    |              | 
 f1     | boolean | not null  | plain    |              | 
 f5     | integer |           | plain    |              | 
 f2     | text    |           | extended |              | 
 f3     | integer |           | plain    |              | 
 f4     | date    |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Triggers:
    f1_trig_insert AFTER INSERT ON t1 FOR EACH ROW WHEN (NOT new.f1) EXECUTE PROCEDURE dummy_update_func('insert')
    f1_trig_update AFTER UPDATE OF f1 ON t1 FOR EACH ROW WHEN (NOT old.f1 AND new.f1) EXECUTE PROCEDURE dummy_update_func('update')
Has OIDs: no
Options: orientation=row, compression=no

select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 2 :location 80}) :location 76}
 f1_trig_update | 2      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 86}) :location 82} {VAR :varno 2 :varattno 2 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 2 :location 97}) :location 93}
(2 rows)

-- pg_rlspolicy test
drop table if exists t1 cascade;
drop role if exists test_rlspolicy2;
NOTICE:  role "test_rlspolicy2" does not exist, skipping
create role test_rlspolicy2 nologin password 'Gauss_234';
create table t1 (f1 int, f2 int, f3 text) partition by range (f1)
(
        partition t1_p0 values less than(10),
        partition t1_p1 values less than(50),
        partition t1_p2 values less than(100),
        partition t1_p3 values less than(MAXVALUE)
);
INSERT INTO t1 VALUES (generate_series(1, 150) % 24, generate_series(1, 150), 'huawei');
grant select on t1 to public;
create row level security policy t1_rls1 on t1 as permissive to public using (f2 <= 20);
create row level security policy t1_rls2 on t1 as restrictive to test_rlspolicy2 using (f1 < 30);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f1     | integer |           | plain    |              | 
 f2     | integer |           | plain    |              | 
 f3     | text    |           | extended |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy2
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f1 | f2 |   f3   
----+----+--------
  1 |  1 | huawei
  2 |  2 | huawei
  3 |  3 | huawei
  4 |  4 | huawei
  5 |  5 | huawei
  6 |  6 | huawei
  7 |  7 | huawei
  8 |  8 | huawei
  9 |  9 | huawei
  0 | 24 | huawei
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 2 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 88} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 93 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 91}
(2 rows)

alter table t1 add f4 int generated always as (f1 + 100) stored after f1, add f5 int generated always as (f2 + 100) stored first;
\d+ t1
                                         Table "public.t1"
 Column |  Type   |                Modifiers                | Storage  | Stats target | Description 
--------+---------+-----------------------------------------+----------+--------------+-------------
 f5     | integer | generated always as ((f2 + 100)) stored | plain    |              | 
 f1     | integer |                                         | plain    |              | 
 f4     | integer | generated always as ((f1 + 100)) stored | plain    |              | 
 f2     | integer |                                         | plain    |              | 
 f3     | text    |                                         | extended |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy2
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f5  | f1 | f4  | f2 |   f3   
-----+----+-----+----+--------
 101 |  1 | 101 |  1 | huawei
 102 |  2 | 102 |  2 | huawei
 103 |  3 | 103 |  3 | huawei
 104 |  4 | 104 |  4 | huawei
 105 |  5 | 105 |  5 | huawei
 106 |  6 | 106 |  6 | huawei
 107 |  7 | 107 |  7 | huawei
 108 |  8 | 108 |  8 | huawei
 109 |  9 | 109 |  9 | huawei
 124 |  0 | 100 | 24 | huawei
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 4 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 2 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 88} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 93 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 91}
(2 rows)

-- expression test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int, f4 bool, f5 text, f6 text);
insert into t1 values(1, 2, 3, true, 'nanjin', 'huawei');
-- T_FuncExpr
create index t1_idx1 on t1(abs(f1), f2);
-- T_OpExpr
create index t1_idx2 on t1((f1 + f2), (f1 - f3));
-- T_BooleanTest
create index t1_idx3 on t1((f4 is true));
-- T_CaseExpr and T_CaseWhen
create index t1_idx4 on t1((case f1 when f2 then 'yes' when f3 then 'no' else 'unknow' end));
-- T_ArrayExpr
create index t1_idx5 on t1((array[f1, f2, f3]));
-- T_TypeCast
create index t1_idx6 on t1(((f1 + f2 + 1) :: text));
-- T_BoolExpr
create index t1_idx7 on t1((f1 and f2), (f2 or f3));
-- T_ArrayRef
create index t1_idx8 on t1((f1 = (array[f1, f2, 3])[1]));
-- T_ScalarArrayOpExpr
create index t1_idx9 on t1((f1 = ANY(ARRAY[f2, 1, f1 + 10])));
-- T_RowCompareExpr
create index t1_idx10 on t1((row(f1, f5) < row(f2, f6)));
-- T_MinMaxExpr
create index t1_idx11 on t1(greatest(f1, f2, f3), least(f1, f2, f3));
-- T_RowExpr
drop table if exists mytable cascade;
NOTICE:  table "mytable" does not exist, skipping
create table mytable(f1 int, f2 int, f3 text);
create function getf1(mytable) returns int as 'select $1.f1' language sql;
create index t1_idx12 on t1(getf1(row(f1, 2, 'a')));
-- T_CoalesceExpr
create index t1_idx13 on t1(nvl(f1, f2));
-- T_NullTest
create index t1_idx14 on t1((f1 is null));
-- T_ScalarArrayOpExpr
create index t1_idx16 on t1((f1 in (1,2,3)));
-- T_NullIfExpr
create index t1_idx17 on t1(nullif(f5,f6));
-- T_RelabelType
alter table t1 add f7 oid;
create index t1_idx18 on t1((f7::int4));
-- T_CoerceViaIO
alter table t1 add f8 json;
create index t1_idx19 on t1((f8::jsonb));
-- T_ArrayCoerceExpr
alter table t1 add f9 float[];
create index t1_idx20 on t1((f9::int[]));
-- T_PrefixKey
create index t1_idx21 on t1(f6(5));
\d+ t1
                                Table "public.t1"
 Column |        Type        | Modifiers | Storage  | Stats target | Description 
--------+--------------------+-----------+----------+--------------+-------------
 f1     | integer            |           | plain    |              | 
 f2     | integer            |           | plain    |              | 
 f3     | integer            |           | plain    |              | 
 f4     | boolean            |           | plain    |              | 
 f5     | text               |           | extended |              | 
 f6     | text               |           | extended |              | 
 f7     | oid                |           | plain    |              | 
 f8     | json               |           | extended |              | 
 f9     | double precision[] |           | extended |              | 
Indexes:
    "t1_idx1" btree (abs(f1), f2) TABLESPACE pg_default
    "t1_idx10" btree (((ROW(f1, f5) < ROW(f2, f6)))) TABLESPACE pg_default
    "t1_idx11" btree ((GREATEST(f1, f2, f3)), (LEAST(f1, f2, f3))) TABLESPACE pg_default
    "t1_idx12" btree (getf1(ROW(f1, 2, 'a'::text))) TABLESPACE pg_default
    "t1_idx13" btree ((COALESCE(f1, f2))) TABLESPACE pg_default
    "t1_idx14" btree ((f1 IS NULL)) TABLESPACE pg_default
    "t1_idx16" btree ((f1 = ANY (ARRAY[1, 2, 3]))) TABLESPACE pg_default
    "t1_idx17" btree ((NULLIF(f5, f6))) TABLESPACE pg_default
    "t1_idx18" btree ((f7::integer)) TABLESPACE pg_default
    "t1_idx19" btree ((f8::jsonb)) TABLESPACE pg_default
    "t1_idx2" btree ((f1 + f2), (f1 - f3)) TABLESPACE pg_default
    "t1_idx20" btree ((f9::integer[])) TABLESPACE pg_default
    "t1_idx21" btree (f6(5)) TABLESPACE pg_default
    "t1_idx3" btree ((f4 IS TRUE)) TABLESPACE pg_default
    "t1_idx4" btree ((
CASE f1
    WHEN f2 THEN 'yes'::text
    WHEN f3 THEN 'no'::text
    ELSE 'unknow'::text
END)) TABLESPACE pg_default
    "t1_idx5" btree ((ARRAY[f1, f2, f3])) TABLESPACE pg_default
    "t1_idx6" btree (((f1 + f2 + 1)::text)) TABLESPACE pg_default
    "t1_idx7" btree ((f1 AND f2), (f2 OR f3)) TABLESPACE pg_default
    "t1_idx8" btree ((f1 = (ARRAY[f1, f2, 3])[1])) TABLESPACE pg_default
    "t1_idx9" btree ((f1 = ANY (ARRAY[f2, 1, f1 + 10]))) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 | f3 | f4 |   f5   |   f6   | f7 | f8 | f9 
----+----+----+----+--------+--------+----+----+----
  1 |  2 |  3 | t  | nanjin | huawei |    |    | 
(1 row)

alter table t1 add f10 int primary key auto_increment after f4,
        add f11 int generated always as (f1 + f2) stored after f1,
        add f12 date default '2023-01-05' first,
        add f13 int not null default 13 first;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f10_seq" for serial column "t1.f10"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                              Table "public.t1"
 Column |        Type        |               Modifiers                | Storage  | Stats target | Description 
--------+--------------------+----------------------------------------+----------+--------------+-------------
 f13    | integer            | not null default 13                    | plain    |              | 
 f12    | date               | default '01-05-2023'::date             | plain    |              | 
 f1     | integer            |                                        | plain    |              | 
 f11    | integer            | generated always as ((f1 + f2)) stored | plain    |              | 
 f2     | integer            |                                        | plain    |              | 
 f3     | integer            |                                        | plain    |              | 
 f4     | boolean            |                                        | plain    |              | 
 f10    | integer            | not null AUTO_INCREMENT                | plain    |              | 
 f5     | text               |                                        | extended |              | 
 f6     | text               |                                        | extended |              | 
 f7     | oid                |                                        | plain    |              | 
 f8     | json               |                                        | extended |              | 
 f9     | double precision[] |                                        | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f10) TABLESPACE pg_default
    "t1_idx1" btree (abs(f1), f2) TABLESPACE pg_default
    "t1_idx10" btree (((ROW(f1, f5) < ROW(f2, f6)))) TABLESPACE pg_default
    "t1_idx11" btree ((GREATEST(f1, f2, f3)), (LEAST(f1, f2, f3))) TABLESPACE pg_default
    "t1_idx12" btree (getf1(ROW(f1, 2, 'a'::text))) TABLESPACE pg_default
    "t1_idx13" btree ((COALESCE(f1, f2))) TABLESPACE pg_default
    "t1_idx14" btree ((f1 IS NULL)) TABLESPACE pg_default
    "t1_idx16" btree ((f1 = ANY (ARRAY[1, 2, 3]))) TABLESPACE pg_default
    "t1_idx17" btree ((NULLIF(f5, f6))) TABLESPACE pg_default
    "t1_idx18" btree ((f7::integer)) TABLESPACE pg_default
    "t1_idx19" btree ((f8::jsonb)) TABLESPACE pg_default
    "t1_idx2" btree ((f1 + f2), (f1 - f3)) TABLESPACE pg_default
    "t1_idx20" btree ((f9::integer[])) TABLESPACE pg_default
    "t1_idx21" btree (f6(5)) TABLESPACE pg_default
    "t1_idx3" btree ((f4 IS TRUE)) TABLESPACE pg_default
    "t1_idx4" btree ((
CASE f1
    WHEN f2 THEN 'yes'::text
    WHEN f3 THEN 'no'::text
    ELSE 'unknow'::text
END)) TABLESPACE pg_default
    "t1_idx5" btree ((ARRAY[f1, f2, f3])) TABLESPACE pg_default
    "t1_idx6" btree (((f1 + f2 + 1)::text)) TABLESPACE pg_default
    "t1_idx7" btree ((f1 AND f2), (f2 OR f3)) TABLESPACE pg_default
    "t1_idx8" btree ((f1 = (ARRAY[f1, f2, 3])[1])) TABLESPACE pg_default
    "t1_idx9" btree ((f1 = ANY (ARRAY[f2, 1, f1 + 10]))) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f13 |    f12     | f1 | f11 | f2 | f3 | f4 | f10 |   f5   |   f6   | f7 | f8 | f9 
-----+------------+----+-----+----+----+----+-----+--------+--------+----+----+----
  13 | 01-05-2023 |  1 |   3 |  2 |  3 | t  |   1 | nanjin | huawei |    |    | 
(1 row)

-- test modify column ... first | after column in astore table
-- ASTORE table
-- common scenatios
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4, modify f5 bool after f2;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f2 | f5 |    f4    | f1 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 | a  | t  | 01000001 |  1
 Wed Nov 09 19:56:10.158564 2022 | b  | f  | 01000010 |  2
(2 rows)

alter table t1 modify 
-- 1 primary key
drop table if exists t1 cascade;
ERROR:  syntax error at or near "table"
LINE 3: drop table if exists t1 cascade;
             ^
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
ERROR:  relation "t1" already exists in schema "public"
DETAIL:  creating new table with existing name in the same schema
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

-- 2 unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

-- 3 default and generated column
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
alter table t1 modify f4 int after f2, modify f1 int after f3, modify f3 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored);
insert into t1 values(1,2,3),(11,22,33);
alter table t1 modify f4 int after f2, modify f1 int after f3, modify f3 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f3 | f2 | f4 | f1 
----+----+----+----
  3 |  2 |  3 |  1
 33 | 22 | 33 | 11
(2 rows)

alter table t1 drop f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f3 | f2 | f4 
----+----+----
  3 |  2 |  3
 33 | 22 | 33
(2 rows)

-- 4 auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1(f2, f3, f4, f5) values('a', '2022-11-08 19:56:10.158564', x'41', true), ('b', '2022-11-09 19:56:10.158564', x'42', false);
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

insert into t1(f3, f2, f4, f5, f1) values('2022-11-10 19:56:10.158564', 'c', x'43', false, 3);
select f1 from t1;
 f1 
----
  1
  2
  3
(3 rows)

-- 5 NULL and NOT NULL
drop table if exists t1 cascade;
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 modify f3 timestamp first, modify f1 int after f4;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 modify f1 int after f3;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 drop f1, modify f5 bool first;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 modify f2 varchar(20) after f3;
ERROR:  relation "t1" does not exist
\d+ t1
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  relation "t1" does not exist on datanode1
LINE 1: insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', ...
                    ^
alter table t1 modify f3 timestamp first, modify f1 int after f4;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 modify f1 int after f3;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 drop f1, modify f5 bool first;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 modify f2 varchar(20) after f3;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
-- 6 check constraint
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  new row for relation "t1" violates check constraint "t1_f1_check"
DETAIL:  N/A
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f3 | f2 | f4 | f1 | f5 
----+----+----+----+----
(0 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f3 | f1 | f2 | f4 | f5 
----+----+----+----+----
(0 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f5 | f3 | f2 | f4 
----+----+----+----
(0 rows)

-- 7 foreign key
drop table if exists t_pri1 cascade;
create table t_pri1(f1 int, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
alter table t1 modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f2 int after f3;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
 f2     | integer |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t_pri1 cascade;
NOTICE:  drop cascades to constraint t1_f2_fkey on table t1
create table t_pri1(f1 int, f2 int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values(1,1),(2,2);
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool);
insert into t1 values(1, 1, true), (2, 2, false);
alter table t1 modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f2 | f1 | f3 
----+----+----
  1 |  1 | t
  2 |  2 | f
(2 rows)

alter table t1 modify f2 int after f3;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
 f2     | integer |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f3 | f2 
----+----+----
  1 | t  |  1
  2 | f  |  2
(2 rows)

-- partition table
drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int, primary key (f1, f2))
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 modify f1 int after f2, modify f3 int first, modify f2 int first;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 modify f1 int after f2;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

-- modify operation before add
alter table t1 add f4 int after f2, modify f1 int after f2;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int, primary key (f1, f2))
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(9, -1, 1), (19, -1, 2), (29, -1, 3);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f1 | f2 | f3 
----+----+----
  9 | -1 |  1
(1 row)

select * from t1 partition (t1_p1);
 f1 | f2 | f3 
----+----+----
 19 | -1 |  2
(1 row)

select * from t1 partition (t1_p2);
 f1 | f2 | f3 
----+----+----
 29 | -1 |  3
(1 row)

alter table t1 modify f1 int after f2, modify f3 int first, modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f3 | f1 
----+----+----
 -1 |  1 |  9
(1 row)

select * from t1 partition (t1_p1);
 f2 | f3 | f1 
----+----+----
 -1 |  2 | 19
(1 row)

select * from t1 partition (t1_p2);
 f2 | f3 | f1 
----+----+----
 -1 |  3 | 29
(1 row)

alter table t1 modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer | not null  | plain   |              | 
 f1     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f1 | f3 
----+----+----
 -1 |  9 |  1
(1 row)

select * from t1 partition (t1_p1);
 f2 | f1 | f3 
----+----+----
 -1 | 19 |  2
(1 row)

select * from t1 partition (t1_p2);
 f2 | f1 | f3 
----+----+----
 -1 | 29 |  3
(1 row)

alter table t1 add f4 int after f2, modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer | not null  | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    |  9 |  1
(1 row)

select * from t1 partition (t1_p1);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    | 19 |  2
(1 row)

select * from t1 partition (t1_p2);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    | 29 |  3
(1 row)

-- subpartition table
drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null, primary key(id, birthday))
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "range_range_pkey" for table "range_range"
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range modify birthday date first, modify id int after gender;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 birthday | date              | not null  | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 id       | integer           | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id, birthday) LOCAL TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 1
 p_2         | p        | 1
 p_3         | p        | 1
 range_range | r        | 3
(4 rows)

drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null, primary key(id, birthday))
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "range_range_pkey" for table "range_range"
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range modify birthday date first, modify id int after gender;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 birthday | date              | not null  | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 id       | integer           | not null  | plain    |              | 
Indexes:
    "range_range_pkey" PRIMARY KEY, btree (id, birthday) LOCAL TABLESPACE pg_default
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 1
 p_2         | p        | 1
 p_3         | p        | 1
 range_range | r        | 3
(4 rows)

select * from range_range;
  birthday  | gender | id  
------------+--------+-----
 08-11-2003 | boy    |  33
 06-24-2014 | girl   |  78
 01-12-2009 | girl   |  15
 02-15-2010 | boy    | 198
 03-08-2005 | girl   | 146
 11-19-2013 | girl   | 111
 05-21-2011 | boy    | 156
 01-01-2010 | girl   | 233
 05-14-2007 | boy    | 360
(9 rows)

-- USTORE table
-- common scenatios
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4, modify f5 bool after f2;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f2 | f5 |    f4    | f1 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 | a  | t  | 01000001 |  1
 Wed Nov 09 19:56:10.158564 2022 | b  | f  | 01000010 |  2
(2 rows)

alter table t1 modify 
-- 1 primary key
drop table if exists t1 cascade;
ERROR:  syntax error at or near "table"
LINE 3: drop table if exists t1 cascade;
             ^
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
ERROR:  relation "t1" already exists in schema "public"
DETAIL:  creating new table with existing name in the same schema
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int primary key, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     | not null  | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

-- 2 unique index
drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int unique, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f1_key" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_f1_key" UNIQUE CONSTRAINT, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

-- 3 default and generated column
drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int default 1, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f1 | f2 |    f4    | f5 
---------------------------------+----+----+----------+----
 Tue Nov 08 19:56:10.158564 2022 |  1 | a  | 01000001 | t
 Wed Nov 09 19:56:10.158564 2022 |  2 | b  | 01000010 | f
(2 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f5 |               f3                | f2 |    f4    
----+---------------------------------+----+----------
 t  | Tue Nov 08 19:56:10.158564 2022 | a  | 01000001
 f  | Wed Nov 09 19:56:10.158564 2022 | b  | 01000010
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with(storage_type = ustore);
alter table t1 modify f4 int after f2, modify f1 int after f3, modify f3 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int, f2 int default 2, f3 int default 3, f4 int generated always as (f1 + f2) stored) with(storage_type = ustore);
insert into t1 values(1,2,3),(11,22,33);
alter table t1 modify f4 int after f2, modify f1 int after f3, modify f3 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f3 | f2 | f4 | f1 
----+----+----+----
  3 |  2 |  3 |  1
 33 | 22 | 33 | 11
(2 rows)

alter table t1 drop f1;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer | default 2 | plain   |              | 
 f4     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f3 | f2 | f4 
----+----+----
  3 |  2 |  3
 33 | 22 | 33
(2 rows)

-- 4 auto_increment
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1(f2, f3, f4, f5) values('a', '2022-11-08 19:56:10.158564', x'41', true), ('b', '2022-11-09 19:56:10.158564', x'42', false);
\d+ t1
                                           Table "public.t1"
 Column |            Type             |        Modifiers        | Storage  | Stats target | Description 
--------+-----------------------------+-------------------------+----------+--------------+-------------
 f1     | integer                     | not null AUTO_INCREMENT | plain    |              | 
 f2     | character varying(20)       |                         | extended |              | 
 f3     | timestamp without time zone |                         | plain    |              | 
 f4     | bit(8)                      |                         | extended |              | 
 f5     | boolean                     |                         | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     | not null  | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, ubtree (f1) WITH (storage_type=ustore) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
               f3                | f2 |    f4    | f1 | f5 
---------------------------------+----+----------+----+----
 Tue Nov 08 19:56:10.158564 2022 | a  | 01000001 |  1 | t
 Wed Nov 09 19:56:10.158564 2022 | b  | 01000010 |  2 | f
(2 rows)

insert into t1(f3, f2, f4, f5, f1) values('2022-11-10 19:56:10.158564', 'c', x'43', false, 3);
select f1 from t1;
 f1 
----
  1
  2
  3
(3 rows)

-- 5 NULL and NOT NULL
drop table if exists t1 cascade;
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
alter table t1 modify f3 timestamp first, modify f1 int after f4;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 modify f1 int after f3;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 drop f1, modify f5 bool first;
ERROR:  relation "t1" does not exist
\d+ t1
alter table t1 modify f2 varchar(20) after f3;
ERROR:  relation "t1" does not exist
\d+ t1
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
alter table t1(f1 int null, f2 varchar(20) not null, f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
ERROR:  syntax error at or near "("
LINE 1: alter table t1(f1 int null, f2 varchar(20) not null, f3 time...
                      ^
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  relation "t1" does not exist on datanode1
LINE 1: insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', ...
                    ^
alter table t1 modify f3 timestamp first, modify f1 int after f4;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 modify f1 int after f3;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 drop f1, modify f5 bool first;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
alter table t1 modify f2 varchar(20) after f3;
ERROR:  relation "t1" does not exist
\d+ t1
select * from t1;
ERROR:  relation "t1" does not exist on datanode1
LINE 1: select * from t1;
                      ^
-- 6 check constraint
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t1 cascade;
create table t1(f1 int check(f1 = 1), f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with(storage_type = ustore);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
ERROR:  new row for relation "t1" violates check constraint "t1_f1_check"
DETAIL:  N/A
alter table t1 modify f3 timestamp first, modify f1 int after f4;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f1     | integer                     |           | plain    |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f3 | f2 | f4 | f1 | f5 
----+----+----+----+----
(0 rows)

alter table t1 modify f1 int after f3;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f3     | timestamp without time zone |           | plain    |              | 
 f1     | integer                     |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
 f5     | boolean                     |           | plain    |              | 
Check constraints:
    "t1_f1_check" CHECK (f1 = 1)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f3 | f1 | f2 | f4 | f5 
----+----+----+----+----
(0 rows)

alter table t1 drop f1, modify f5 bool first;
\d+ t1
                                    Table "public.t1"
 Column |            Type             | Modifiers | Storage  | Stats target | Description 
--------+-----------------------------+-----------+----------+--------------+-------------
 f5     | boolean                     |           | plain    |              | 
 f3     | timestamp without time zone |           | plain    |              | 
 f2     | character varying(20)       |           | extended |              | 
 f4     | bit(8)                      |           | extended |              | 
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f5 | f3 | f2 | f4 
----+----+----+----
(0 rows)

-- 7 foreign key
drop table if exists t_pri1 cascade;
create table t_pri1(f1 int, f2 int primary key) with(storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with(storage_type = ustore);
alter table t1 modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

alter table t1 modify f2 int after f3;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
 f2     | integer |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

drop table if exists t_pri1 cascade;
NOTICE:  drop cascades to constraint t1_f2_fkey on table t1
create table t_pri1(f1 int, f2 int primary key) with(storage_type = ustore);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri1_pkey" for table "t_pri1"
insert into t_pri1 values(1,1),(2,2);
drop table if exists t1 cascade;
create table t1(f1 int, f2 int references t_pri1(f2), f3 bool) with(storage_type = ustore);
insert into t1 values(1, 1, true), (2, 2, false);
alter table t1 modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f2 | f1 | f3 
----+----+----
  1 |  1 | t
  2 |  2 | f
(2 rows)

alter table t1 modify f2 int after f3;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f3     | boolean |           | plain   |              | 
 f2     | integer |           | plain   |              | 
Foreign-key constraints:
    "t1_f2_fkey" FOREIGN KEY (f2) REFERENCES t_pri1(f2)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select * from t1;
 f1 | f3 | f2 
----+----+----
  1 | t  |  1
  2 | f  |  2
(2 rows)

-- partition table
drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int) with(storage_type = ustore)
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 modify f1 int after f2, modify f3 int first, modify f2 int first;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

alter table t1 modify f1 int after f2;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1') order by relname;
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

-- modify operation before add
alter table t1 add f4 int after f2, modify f1 int after f2;
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

drop table if exists t1 cascade;
create table t1
(f1 int, f2 int, f3 int) with(storage_type = ustore)
partition by range(f1, f2)
(
        partition t1_p0 values less than (10, 0),
        partition t1_p1 values less than (20, 0),
        partition t1_p2 values less than (30, 0)
);
insert into t1 values(9, -1, 1), (19, -1, 2), (29, -1, 3);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 1 2
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f1 | f2 | f3 
----+----+----
  9 | -1 |  1
(1 row)

select * from t1 partition (t1_p1);
 f1 | f2 | f3 
----+----+----
 19 | -1 |  2
(1 row)

select * from t1 partition (t1_p2);
 f1 | f2 | f3 
----+----+----
 29 | -1 |  3
(1 row)

alter table t1 modify f1 int after f2, modify f3 int first, modify f2 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f3 | f1 
----+----+----
 -1 |  1 |  9
(1 row)

select * from t1 partition (t1_p1);
 f2 | f3 | f1 
----+----+----
 -1 |  2 | 19
(1 row)

select * from t1 partition (t1_p2);
 f2 | f3 | f1 
----+----+----
 -1 |  3 | 29
(1 row)

alter table t1 modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 2 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f1 | f3 
----+----+----
 -1 |  9 |  1
(1 row)

select * from t1 partition (t1_p1);
 f2 | f1 | f3 
----+----+----
 -1 | 19 |  2
(1 row)

select * from t1 partition (t1_p2);
 f2 | f1 | f3 
----+----+----
 -1 | 29 |  3
(1 row)

alter table t1 add f4 int after f2, modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Partition By RANGE(f1, f2)
Number of partitions: 3 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='t1');
 relname | parttype | partkey 
---------+----------+---------
 t1      | r        | 3 1
 t1_p0   | p        | 
 t1_p1   | p        | 
 t1_p2   | p        | 
(4 rows)

select * from t1 partition (t1_p0);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    |  9 |  1
(1 row)

select * from t1 partition (t1_p1);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    | 19 |  2
(1 row)

select * from t1 partition (t1_p2);
 f2 | f4 | f1 | f3 
----+----+----+----
 -1 |    | 29 |  3
(1 row)

-- subpartition table
drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null) with(storage_type = ustore)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range modify birthday date first, modify id int after gender;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 birthday | date              |           | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 id       | integer           |           | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 1
 p_2         | p        | 1
 p_3         | p        | 1
 range_range | r        | 3
(4 rows)

drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null) with(storage_type = ustore)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range modify birthday date first, modify id int after gender;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 birthday | date              |           | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 id       | integer           |           | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 1
 p_2         | p        | 1
 p_3         | p        | 1
 range_range | r        | 3
(4 rows)

select * from range_range;
  birthday  | gender | id  
------------+--------+-----
 08-11-2003 | boy    |  33
 06-24-2014 | girl   |  78
 01-12-2009 | girl   |  15
 02-15-2010 | boy    | 198
 03-08-2005 | girl   | 146
 11-19-2013 | girl   | 111
 05-21-2011 | boy    | 156
 01-01-2010 | girl   | 233
 05-14-2007 | boy    | 360
(9 rows)

-- orientation = column not support
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool) with (orientation = column);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
-- error
alter table t1 modify f1 int after f3;
ERROR:  Un-support feature
DETAIL:  column-store relation doesn't support this ALTER yet
-- error
alter table t1 modify f3 timestamp first;
ERROR:  Un-support feature
DETAIL:  column-store relation doesn't support this ALTER yet
-- pg_constraint test
set enable_default_ustore_table = on;
drop table if exists t_pri cascade;
drop table if exists t1 cascade;
create table t_pri(f1 int, f2 int, f3 int, primary key(f2, f3));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_pri_pkey" for table "t_pri"
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        foreign key(f1, f2) references t_pri(f2, f3),
        unique((lower(f3)), (abs(f4))),
        check(f5 = 10),
        unique(f4, f5) include(f6, f7)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_lower_abs_key" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_f4_f5_f6_f7_key" for table "t1"
\d+ t_pri
                        Table "public.t_pri"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "t_pri_pkey" PRIMARY KEY, ubtree (f2, f3) WITH (storage_type=USTORE) TABLESPACE pg_default
Referenced by:
    TABLE "t1" CONSTRAINT "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f1     | integer               |           | plain    |              | 
 f2     | integer               |           | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_f4_f5_f6_f7_key" UNIQUE CONSTRAINT, ubtree (f4, f5) WITH (storage_type=USTORE) TABLESPACE pg_default
    "t1_lower_abs_key" UNIQUE CONSTRAINT, ubtree (lower(f3::text), abs(f4)) WITH (storage_type=USTORE) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Foreign-key constraints:
    "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't_pri') order by conname;
  conname   | contype | conkey | confkey | conbin | consrc | conincluding 
------------+---------+--------+---------+--------+--------+--------------
 t_pri_pkey | p       | {2,3}  |         |        |        | 
(1 row)

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                 conbin                                                                                                                                                                                                                                                                  |  consrc   | conincluding 
--------------------+---------+--------+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {1,2}  | {2,3}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
 t1_f4_f5_f6_f7_key | u       | {4,5}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | {6,7}
 t1_f5_check        | c       | {5}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 198} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 203 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 201} | (f5 = 10) | 
 t1_lower_abs_key   | u       | {0,0}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |           | 
(4 rows)

alter table t_pri modify f3 int first;
alter table t1 modify f2 int first, modify f4 int after f1, modify f5 int after f7;
\d+ t_pri
                        Table "public.t_pri"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer | not null  | plain   |              | 
 f1     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
Indexes:
    "t_pri_pkey" PRIMARY KEY, ubtree (f2, f3) WITH (storage_type=ustore) TABLESPACE pg_default
Referenced by:
    TABLE "t1" CONSTRAINT "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f2     | integer               |           | plain    |              | 
 f1     | integer               |           | plain    |              | 
 f4     | integer               |           | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
Indexes:
    "t1_f4_f5_f6_f7_key" UNIQUE CONSTRAINT, ubtree (f4, f5) WITH (storage_type=ustore) TABLESPACE pg_default
    "t1_lower_abs_key" UNIQUE CONSTRAINT, ubtree (lower(f3::text), abs(f4)) WITH (storage_type=ustore) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Foreign-key constraints:
    "t1_f1_fkey" FOREIGN KEY (f1, f2) REFERENCES t_pri(f2, f3)
Has OIDs: no
Options: orientation=row, compression=no, storage_type=USTORE

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't_pri') order by conname;
  conname   | contype | conkey | confkey | conbin | consrc | conincluding 
------------+---------+--------+---------+--------+--------+--------------
 t_pri_pkey | p       | {3,1}  |         |        |        | 
(1 row)

select conname, contype, conkey, confkey, conbin, consrc, conincluding from pg_constraint 
        where conrelid = (select oid from pg_class where relname = 't1') order by conname;
      conname       | contype | conkey | confkey |                                                                                                                                                                                                                                                                conbin                                                                                                                                                                                                                                                                |  consrc   | conincluding 
--------------------+---------+--------+---------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------------
 t1_f1_fkey         | f       | {2,1}  | {3,1}   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |           | 
 t1_f4_f5_f6_f7_key | u       | {3,7}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |           | {5,6}
 t1_f5_check        | c       | {7}    |         | {OPEXPR :opno 96 :opfuncid 65 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 55} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 60 :constvalue 4 [ 10 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 58} | (f5 = 10) | 
 t1_lower_abs_key   | u       | {0,0}  |         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |           | 
(4 rows)

set enable_default_ustore_table = off;
-- pg_index test
drop table if exists t1 cascade;
create table t1
(
        f1 int, f2 int, f3 varchar(20), f4 int, f5 int, f6 int, f7 int,
        primary key(f1, f2),
        unique((lower(f3)), (abs(f4))),
        check(f5 = 10)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_lower_abs_key" for table "t1"
create unique index partial_t1_idx on t1(f5, abs(f6)) where f5 + f6 - abs(f7) > 0;
\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f1     | integer               | not null  | plain    |              | 
 f2     | integer               | not null  | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f4     | integer               |           | plain    |              | 
 f5     | integer               |           | plain    |              | 
 f6     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
    "partial_t1_idx" UNIQUE, btree (f5, abs(f6)) TABLESPACE pg_default WHERE (f5 + f6 - abs(f7)) > 0
    "t1_lower_abs_key" UNIQUE CONSTRAINT, btree (lower(f3::text), abs(f4)) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Has OIDs: no
Options: orientation=row, compression=no

select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1');
 indkey |                                                                                                                                                                                                                                                                                                                                             indexprs                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 5 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 49}) :location 45 :refSynOid 0})                                                                                                                                                                                                                                                                                                                                                                                                        | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 60} {VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 65}) :location 63} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 74}) :location 70 :refSynOid 0}) :location 68} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 80 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 78}
 0 0    | ({FUNCEXPR :funcid 870 :funcresulttype 25 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 100 :inputcollid 100 :args ({RELABELTYPE :arg {VAR :varno 1 :varattno 3 :vartype 1043 :vartypmod 24 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 3 :location 141} :resulttype 25 :resulttypmod -1 :resultcollid 100 :relabelformat 2 :location -1}) :location 135 :refSynOid 0} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 4 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 152}) :location 148 :refSynOid 0}) | 
 1 2    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 
(3 rows)

alter table t1 modify f1 int after f2, modify f4 int after f6, modify f5 int first;
\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f5     | integer               |           | plain    |              | 
 f2     | integer               | not null  | plain    |              | 
 f1     | integer               | not null  | plain    |              | 
 f3     | character varying(20) |           | extended |              | 
 f6     | integer               |           | plain    |              | 
 f4     | integer               |           | plain    |              | 
 f7     | integer               |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
    "partial_t1_idx" UNIQUE, btree (f5, abs(f6)) TABLESPACE pg_default WHERE (f5 + f6 - abs(f7)) > 0
    "t1_lower_abs_key" UNIQUE CONSTRAINT, btree (lower(f3::text), abs(f4)) TABLESPACE pg_default
Check constraints:
    "t1_f5_check" CHECK (f5 = 10)
Has OIDs: no
Options: orientation=row, compression=no

select indkey, indexprs, indpred from pg_index where indrelid = (select oid from pg_class where relname = 't1');
 indkey |                                                                                                                                                                                                                                                                                                                                           indexprs                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             indpred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
--------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 1 0    | ({FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 62}) :location 58 :refSynOid 0})                                                                                                                                                                                                                                                                                                                                                                                                    | {OPEXPR :opno 521 :opfuncid 147 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 555 :opfuncid 181 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({OPEXPR :opno 551 :opfuncid 177 :opresulttype 23 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 98} {VAR :varno 1 :varattno 5 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 5 :location 103}) :location 101} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 7 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 7 :location 113}) :location 109 :refSynOid 0}) :location 107} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 120 :constvalue 4 [ 0 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 118}
 0 0    | ({FUNCEXPR :funcid 870 :funcresulttype 25 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 100 :inputcollid 100 :args ({RELABELTYPE :arg {VAR :varno 1 :varattno 4 :vartype 1043 :vartypmod 24 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 67} :resulttype 25 :resulttypmod -1 :resultcollid 100 :relabelformat 1 :location 69}) :location 61 :refSynOid 0} {FUNCEXPR :funcid 1397 :funcresulttype 23 :funcresulttype_orig -1 :funcretset false :funcformat 0 :funccollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 6 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 6 :location 84}) :location 80 :refSynOid 0}) | 
 3 2    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 
(3 rows)

-- pg_attribute test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f1      |      1 | f         | f
 f2      |      2 | f         | f
 f3      |      3 | f         | f
(3 rows)

alter table t1 modify f3 int first, modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select attname, attnum, atthasdef, attisdropped from pg_attribute where attrelid = (select oid from pg_class where relname = 't1') and attnum > 0 order by attnum;
 attname | attnum | atthasdef | attisdropped 
---------+--------+-----------+--------------
 f3      |      1 | f         | f
 f2      |      2 | f         | f
 f1      |      3 | f         | f
(3 rows)

-- pg_attrdef test
drop table if exists t1 cascade;
create table t1(f1 int primary key auto_increment, f2 int, f3 int default 3, f4 int generated always as (f2 + f3) stored);
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f1     | integer | not null AUTO_INCREMENT                | plain   |              | 
 f2     | integer |                                        | plain   |              | 
 f3     | integer | default 3                              | plain   |              | 
 f4     | integer | generated always as ((f2 + f3)) stored | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum |     adsrc      | adgencol 
-------+----------------+----------
     1 | AUTO_INCREMENT | 
     3 | 3              | 
     4 | (f2 + f3)      | s
(3 rows)

alter table t1 modify f3 int first, modify f1 int after f4, modify f4 int first;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select adnum, adsrc, adgencol from pg_attrdef where adrelid = (select oid from pg_class where relname = 't1') order by adnum;
 adnum | adsrc | adgencol 
-------+-------+----------
(0 rows)

-- pg_depend test
drop table if exists t1 cascade;
create table t1(f1 int default 10, f2 int primary key, f3 int generated always as (f1 + f2) stored, f4 int, unique ((abs(f4))));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t1_abs_key" for table "t1"
\d+ t1
                                        Table "public.t1"
 Column |  Type   |               Modifiers                | Storage | Stats target | Description 
--------+---------+----------------------------------------+---------+--------------+-------------
 f1     | integer | default 10                             | plain   |              | 
 f2     | integer | not null                               | plain   |              | 
 f3     | integer | generated always as ((f1 + f2)) stored | plain   |              | 
 f4     | integer |                                        | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f2) TABLESPACE pg_default
    "t1_abs_key" UNIQUE CONSTRAINT, btree (abs(f4)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select classid, objsubid, refclassid, refobjsubid, deptype from pg_depend
        where refobjid = (select oid from pg_class where relname='t1') or objid = (select oid from pg_class where relname='t1') order by 1, 2, 3, 4, 5;
 classid | objsubid | refclassid | refobjsubid | deptype 
---------+----------+------------+-------------+---------
    1247 |        0 |       1259 |           0 | i
    1259 |        0 |       1259 |           4 | a
    1259 |        0 |       2615 |           0 | n
    1259 |        3 |       1259 |           1 | a
    1259 |        3 |       1259 |           2 | a
    2604 |        0 |       1259 |           1 | a
    2604 |        0 |       1259 |           3 | a
    2606 |        0 |       1259 |           0 | a
    2606 |        0 |       1259 |           2 | a
(9 rows)

alter table t1 modify f4 int first, modify f3 int after f1, modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f4     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f1     | integer |           | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f2) TABLESPACE pg_default
    "t1_abs_key" UNIQUE CONSTRAINT, btree (abs(f4)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select classid, objsubid, refclassid, refobjsubid, deptype from pg_depend
        where refobjid = (select oid from pg_class where relname='t1') or objid = (select oid from pg_class where relname='t1') order by 1, 2, 3, 4, 5;
 classid | objsubid | refclassid | refobjsubid | deptype 
---------+----------+------------+-------------+---------
    1247 |        0 |       1259 |           0 | i
    1259 |        0 |       1259 |           1 | a
    1259 |        0 |       2615 |           0 | n
    2606 |        0 |       1259 |           0 | a
    2606 |        0 |       1259 |           3 | a
(5 rows)

-- pg_partition test
drop table if exists range_range cascade;
create table range_range(id int, gender varchar not null, birthday date not null)
partition by range (id) subpartition by range (birthday)
(
        partition p_1 values less than(100)
        (
                subpartition p_1_a values less than('2022-01-01'),
                subpartition p_1_b values less than(MAXVALUE)
        ),
        partition p_2 values less than(200)
        (
                subpartition p_2_a values less than('2022-01-01'),
                subpartition p_2_b values less than(MAXVALUE)
        ),
        partition p_3 values less than(MAXVALUE)
        (
                subpartition p_3_a values less than('2022-01-01'),
                subpartition p_3_b values less than(MAXVALUE)
        )
);
insert into range_range values(198,'boy','2010-02-15'),(33,'boy','2003-08-11'),(78,'girl','2014-06-24');
insert into range_range values(233,'girl','2010-01-01'),(360,'boy','2007-05-14'),(146,'girl','2005-03-08');
insert into range_range values(111,'girl','2013-11-19'),(15,'girl','2009-01-12'),(156,'boy','2011-05-21');
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           |           | plain    |              | 
 gender   | character varying | not null  | extended |              | 
 birthday | date              | not null  | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 3
 p_2         | p        | 3
 p_3         | p        | 3
 range_range | r        | 1
(4 rows)

alter table range_range modify gender varchar after birthday;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 id       | integer           |           | plain    |              | 
 birthday | date              | not null  | plain    |              | 
 gender   | character varying |           | extended |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 2
 p_2         | p        | 2
 p_3         | p        | 2
 range_range | r        | 1
(4 rows)

alter table range_range modify birthday date first, modify id int after gender;
\d+ range_range
                            Table "public.range_range"
  Column  |       Type        | Modifiers | Storage  | Stats target | Description 
----------+-------------------+-----------+----------+--------------+-------------
 birthday | date              |           | plain    |              | 
 gender   | character varying |           | extended |              | 
 id       | integer           |           | plain    |              | 
Partition By RANGE(id) Subpartition By RANGE(birthday)
Number of partitions: 3 (View pg_partition to check each partition range.)
Number of subpartitions: 6 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

select relname, parttype, partkey from pg_partition where parentid=(select oid from pg_class where relname='range_range') order by relname;
   relname   | parttype | partkey 
-------------+----------+---------
 p_1         | p        | 1
 p_2         | p        | 1
 p_3         | p        | 1
 range_range | r        | 3
(4 rows)

-- pg_rewrite test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int, f4 int);
insert into t1 values(1, 2, 3, 4), (11, 22, 33, 44);
create view t1_view1 as select * from t1;
create view t1_view2 as select f1, f4 from t1;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
 f4     | integer |           | plain   | 
View definition:
 SELECT  *
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f4     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f4
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
   pg_get_viewdef   
--------------------
 SELECT  * FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f4 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 | f4 
----+----+----+----
  1 |  2 |  3 |  4
 11 | 22 | 33 | 44
(2 rows)

select * from t1_view2;
 f1 | f4 
----+----
  1 |  4
 11 | 44
(2 rows)

select * from t1;
 f1 | f2 | f3 | f4 
----+----+----+----
  1 |  2 |  3 |  4
 11 | 22 | 33 | 44
(2 rows)

alter table t1 modify f2 int first, modify f1 int after f4, add f5 int after f4;
\d+ t1_view1
                View "public.t1_view1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f2     | integer |           | plain   | 
 f3     | integer |           | plain   | 
 f4     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f2, t1.f3, t1.f4
   FROM t1;

\d+ t1_view2
                View "public.t1_view2"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 f1     | integer |           | plain   | 
 f4     | integer |           | plain   | 
View definition:
 SELECT t1.f1, t1.f4
   FROM t1;

\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f4     | integer |           | plain   |              | 
 f5     | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select pg_get_viewdef('t1_view1');
               pg_get_viewdef               
--------------------------------------------
 SELECT t1.f1, t1.f2, t1.f3, t1.f4 FROM t1;
(1 row)

select pg_get_viewdef('t1_view2');
        pg_get_viewdef        
------------------------------
 SELECT t1.f1, t1.f4 FROM t1;
(1 row)

select * from t1_view1;
 f1 | f2 | f3 | f4 
----+----+----+----
  1 |  2 |  3 |  4
 11 | 22 | 33 | 44
(2 rows)

select * from t1_view2;
 f1 | f4 
----+----
  1 |  4
 11 | 44
(2 rows)

select * from t1;
 f2 | f3 | f4 | f5 | f1 
----+----+----+----+----
  2 |  3 |  4 |    |  1
 22 | 33 | 44 |    | 11
(2 rows)

-- pg_trigger test
drop table if exists t1 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view t1_view2
drop cascades to view t1_view1
create table t1(f1 boolean not null, f2 text, f3 int, f4 date);
alter table t1 add primary key(f1);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create or replace function dummy_update_func() returns trigger as $$
begin
        raise notice 'dummy_update_func(%) called: action = %, oid = %, new = %', TG_ARGV[0], TG_OP, OLD, NEW;
        return new;
end;
$$ language plpgsql;
drop trigger if exists f1_trig_update on t1;
NOTICE:  trigger "t1.f1_trig_update" for table "t1" does not exist, skipping
drop trigger if exists f1_trig_insert on t1;
NOTICE:  trigger "t1.f1_trig_insert" for table "t1" does not exist, skipping
create trigger f1_trig_update after update of f1 on t1 for each row
        when (not old.f1 and new.f1) execute procedure dummy_update_func('update');
create trigger f1_trig_insert after insert on t1 for each row
        when (not new.f1) execute procedure dummy_update_func('insert');
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f1     | boolean | not null  | plain    |              | 
 f2     | text    |           | extended |              | 
 f3     | integer |           | plain    |              | 
 f4     | date    |           | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Triggers:
    f1_trig_insert AFTER INSERT ON t1 FOR EACH ROW WHEN (NOT new.f1) EXECUTE PROCEDURE dummy_update_func('insert')
    f1_trig_update AFTER UPDATE OF f1 ON t1 FOR EACH ROW WHEN (NOT old.f1 AND new.f1) EXECUTE PROCEDURE dummy_update_func('update')
Has OIDs: no
Options: orientation=row, compression=no

select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 80}) :location 76}
 f1_trig_update | 1      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 86}) :location 82} {VAR :varno 2 :varattno 1 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 97}) :location 93}
(2 rows)

alter table t1 modify f3 int first, modify f1 boolean after f4;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f3     | integer |           | plain    |              | 
 f2     | text    |           | extended |              | 
 f4     | date    |           | plain    |              | 
 f1     | boolean | not null  | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1) TABLESPACE pg_default
Triggers:
    f1_trig_insert AFTER INSERT ON t1 FOR EACH ROW WHEN (NOT new.f1) EXECUTE PROCEDURE dummy_update_func('insert')
    f1_trig_update AFTER UPDATE OF f1 ON t1 FOR EACH ROW WHEN (NOT old.f1 AND new.f1) EXECUTE PROCEDURE dummy_update_func('update')
Has OIDs: no
Options: orientation=row, compression=no

select tgname, tgattr, tgqual from pg_trigger where tgrelid = (select oid from pg_class where relname='t1') order by tgname;
     tgname     | tgattr |                                                                                                                                                                tgqual                                                                                                                                                                 
----------------+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 f1_trig_insert |        | {BOOLEXPR :boolop not :args ({VAR :varno 2 :varattno 4 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 4 :location 80}) :location 76}
 f1_trig_update | 4      | {BOOLEXPR :boolop and :args ({BOOLEXPR :boolop not :args ({VAR :varno 1 :varattno 4 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 4 :location 86}) :location 82} {VAR :varno 2 :varattno 4 :vartype 16 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 4 :location 97}) :location 93}
(2 rows)

-- pg_rlspolicy test
drop table if exists t1 cascade;
drop role if exists test_rlspolicy3;
NOTICE:  role "test_rlspolicy3" does not exist, skipping
create role test_rlspolicy3 nologin password 'Gauss_234';
create table t1 (f1 int, f2 int, f3 text) partition by range (f1)
(
        partition t1_p0 values less than(10),
        partition t1_p1 values less than(50),
        partition t1_p2 values less than(100),
        partition t1_p3 values less than(MAXVALUE)
);
INSERT INTO t1 VALUES (generate_series(1, 150) % 24, generate_series(1, 150), 'huawei');
grant select on t1 to public;
create row level security policy t1_rls1 on t1 as permissive to public using (f2 <= 20);
create row level security policy t1_rls2 on t1 as restrictive to test_rlspolicy3 using (f1 < 30);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f1     | integer |           | plain    |              | 
 f2     | integer |           | plain    |              | 
 f3     | text    |           | extended |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy3
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f1 | f2 |   f3   
----+----+--------
  1 |  1 | huawei
  2 |  2 | huawei
  3 |  3 | huawei
  4 |  4 | huawei
  5 |  5 | huawei
  6 |  6 | huawei
  7 |  7 | huawei
  8 |  8 | huawei
  9 |  9 | huawei
  0 | 24 | huawei
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 2 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 88} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 93 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 91}
(2 rows)

alter table t1 modify f2 int first, modify f1 int after f3;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage  | Stats target | Description 
--------+---------+-----------+----------+--------------+-------------
 f2     | integer |           | plain    |              | 
 f3     | text    |           | extended |              | 
 f1     | integer |           | plain    |              | 
Row Level Security Policies:
    POLICY "t1_rls1" FOR ALL
      TO public
      USING ((f2 <= 20))
    POLICY "t1_rls2" AS RESTRICTIVE FOR ALL
      TO test_rlspolicy3
      USING ((f1 < 30))
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

select * from t1 limit 10;
 f2 |   f3   | f1 
----+--------+----
  1 | huawei |  1
  2 | huawei |  2
  3 | huawei |  3
  4 | huawei |  4
  5 | huawei |  5
  6 | huawei |  6
  7 | huawei |  7
  8 | huawei |  8
  9 | huawei |  9
 24 | huawei |  0
(10 rows)

select polname, polqual from pg_rlspolicy where polrelid = (select oid from pg_class where relname='t1');
 polname |                                                                                                                                                                                                                                                                polqual                                                                                                                                                                                                                                                                 
---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 t1_rls1 | {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 78} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 84 :constvalue 4 [ 20 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 81}
 t1_rls2 | {OPEXPR :opno 97 :opfuncid 66 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 3 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 3 :location 88} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :ismaxvalue false :location 93 :constvalue 4 [ 30 0 0 0 0 0 0 0 ] :cursor_data  :row_count 0 :cur_dno -1 :is_open false :found false :not_found false :null_open false :null_fetch false}) :location 91}
(2 rows)

-- expression test
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int, f4 bool, f5 text, f6 text);
insert into t1 values(1, 2, 3, true, 'nanjin', 'huawei');
-- T_FuncExpr
create index t1_idx1 on t1(abs(f1), f2);
-- T_OpExpr
create index t1_idx2 on t1((f1 + f2), (f1 - f3));
-- T_BooleanTest
create index t1_idx3 on t1((f4 is true));
-- T_CaseExpr and T_CaseWhen
create index t1_idx4 on t1((case f1 when f2 then 'yes' when f3 then 'no' else 'unknow' end));
-- T_ArrayExpr
create index t1_idx5 on t1((array[f1, f2, f3]));
-- T_TypeCast
create index t1_idx6 on t1(((f1 + f2 + 1) :: text));
-- T_BoolExpr
create index t1_idx7 on t1((f1 and f2), (f2 or f3));
-- T_ArrayRef
create index t1_idx8 on t1((f1 = (array[f1, f2, 3])[1]));
-- T_ScalarArrayOpExpr
create index t1_idx9 on t1((f1 = ANY(ARRAY[f2, 1, f1 + 10])));
-- T_RowCompareExpr
create index t1_idx10 on t1((row(f1, f5) < row(f2, f6)));
-- T_MinMaxExpr
create index t1_idx11 on t1(greatest(f1, f2, f3), least(f1, f2, f3));
-- T_RowExpr
drop table if exists mytable cascade;
NOTICE:  drop cascades to function getf1(mytable)
create table mytable(f1 int, f2 int, f3 text);
create function getf1(mytable) returns int as 'select $1.f1' language sql;
create index t1_idx12 on t1(getf1(row(f1, 2, 'a')));
-- T_CoalesceExpr
create index t1_idx13 on t1(nvl(f1, f2));
-- T_NullTest
create index t1_idx14 on t1((f1 is null));
-- T_ScalarArrayOpExpr
create index t1_idx16 on t1((f1 in (1,2,3)));
-- T_NullIfExpr
create index t1_idx17 on t1(nullif(f5,f6));
-- T_RelabelType
alter table t1 add f7 oid;
create index t1_idx18 on t1((f7::int4));
-- T_CoerceViaIO
alter table t1 add f8 json;
create index t1_idx19 on t1((f8::jsonb));
-- T_ArrayCoerceExpr
alter table t1 add f9 float[];
create index t1_idx20 on t1((f9::int[]));
\d+ t1
                                Table "public.t1"
 Column |        Type        | Modifiers | Storage  | Stats target | Description 
--------+--------------------+-----------+----------+--------------+-------------
 f1     | integer            |           | plain    |              | 
 f2     | integer            |           | plain    |              | 
 f3     | integer            |           | plain    |              | 
 f4     | boolean            |           | plain    |              | 
 f5     | text               |           | extended |              | 
 f6     | text               |           | extended |              | 
 f7     | oid                |           | plain    |              | 
 f8     | json               |           | extended |              | 
 f9     | double precision[] |           | extended |              | 
Indexes:
    "t1_idx1" btree (abs(f1), f2) TABLESPACE pg_default
    "t1_idx10" btree (((ROW(f1, f5) < ROW(f2, f6)))) TABLESPACE pg_default
    "t1_idx11" btree ((GREATEST(f1, f2, f3)), (LEAST(f1, f2, f3))) TABLESPACE pg_default
    "t1_idx12" btree (getf1(ROW(f1, 2, 'a'::text))) TABLESPACE pg_default
    "t1_idx13" btree ((COALESCE(f1, f2))) TABLESPACE pg_default
    "t1_idx14" btree ((f1 IS NULL)) TABLESPACE pg_default
    "t1_idx16" btree ((f1 = ANY (ARRAY[1, 2, 3]))) TABLESPACE pg_default
    "t1_idx17" btree ((NULLIF(f5, f6))) TABLESPACE pg_default
    "t1_idx18" btree ((f7::integer)) TABLESPACE pg_default
    "t1_idx19" btree ((f8::jsonb)) TABLESPACE pg_default
    "t1_idx2" btree ((f1 + f2), (f1 - f3)) TABLESPACE pg_default
    "t1_idx20" btree ((f9::integer[])) TABLESPACE pg_default
    "t1_idx3" btree ((f4 IS TRUE)) TABLESPACE pg_default
    "t1_idx4" btree ((
CASE f1
    WHEN f2 THEN 'yes'::text
    WHEN f3 THEN 'no'::text
    ELSE 'unknow'::text
END)) TABLESPACE pg_default
    "t1_idx5" btree ((ARRAY[f1, f2, f3])) TABLESPACE pg_default
    "t1_idx6" btree (((f1 + f2 + 1)::text)) TABLESPACE pg_default
    "t1_idx7" btree ((f1 AND f2), (f2 OR f3)) TABLESPACE pg_default
    "t1_idx8" btree ((f1 = (ARRAY[f1, f2, 3])[1])) TABLESPACE pg_default
    "t1_idx9" btree ((f1 = ANY (ARRAY[f2, 1, f1 + 10]))) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 | f3 | f4 |   f5   |   f6   | f7 | f8 | f9 
----+----+----+----+--------+--------+----+----+----
  1 |  2 |  3 | t  | nanjin | huawei |    |    | 
(1 row)

alter table t1 modify f8 json first, modify f2 int after f6, modify f7 oid after f3;
\d+ t1
                                Table "public.t1"
 Column |        Type        | Modifiers | Storage  | Stats target | Description 
--------+--------------------+-----------+----------+--------------+-------------
 f8     | json               |           | extended |              | 
 f1     | integer            |           | plain    |              | 
 f3     | integer            |           | plain    |              | 
 f7     | oid                |           | plain    |              | 
 f4     | boolean            |           | plain    |              | 
 f5     | text               |           | extended |              | 
 f6     | text               |           | extended |              | 
 f2     | integer            |           | plain    |              | 
 f9     | double precision[] |           | extended |              | 
Indexes:
    "t1_idx1" btree (abs(f1), f2) TABLESPACE pg_default
    "t1_idx10" btree (((ROW(f1, f5) < ROW(f2, f6)))) TABLESPACE pg_default
    "t1_idx11" btree ((GREATEST(f1, f2, f3)), (LEAST(f1, f2, f3))) TABLESPACE pg_default
    "t1_idx12" btree (getf1(ROW(f1, 2, 'a'::text))) TABLESPACE pg_default
    "t1_idx13" btree ((COALESCE(f1, f2))) TABLESPACE pg_default
    "t1_idx14" btree ((f1 IS NULL)) TABLESPACE pg_default
    "t1_idx16" btree ((f1 = ANY (ARRAY[1, 2, 3]))) TABLESPACE pg_default
    "t1_idx17" btree ((NULLIF(f5, f6))) TABLESPACE pg_default
    "t1_idx18" btree ((f7::integer)) TABLESPACE pg_default
    "t1_idx19" btree ((f8::jsonb)) TABLESPACE pg_default
    "t1_idx2" btree ((f1 + f2), (f1 - f3)) TABLESPACE pg_default
    "t1_idx20" btree ((f9::integer[])) TABLESPACE pg_default
    "t1_idx3" btree ((f4 IS TRUE)) TABLESPACE pg_default
    "t1_idx4" btree ((
CASE f1
    WHEN f2 THEN 'yes'::text
    WHEN f3 THEN 'no'::text
    ELSE 'unknow'::text
END)) TABLESPACE pg_default
    "t1_idx5" btree ((ARRAY[f1, f2, f3])) TABLESPACE pg_default
    "t1_idx6" btree (((f1 + f2 + 1)::text)) TABLESPACE pg_default
    "t1_idx7" btree ((f1 AND f2), (f2 OR f3)) TABLESPACE pg_default
    "t1_idx8" btree ((f1 = (ARRAY[f1, f2, 3])[1])) TABLESPACE pg_default
    "t1_idx9" btree ((f1 = ANY (ARRAY[f2, 1, f1 + 10]))) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f8 | f1 | f3 | f7 | f4 |   f5   |   f6   | f2 | f9 
----+----+----+----+----+--------+--------+----+----
    |  1 |  3 |    | t  | nanjin | huawei |  2 | 
(1 row)

drop table if exists t1;
create table t1(f1 int, f2 int);
insert into t1 values(1,2);
alter table t1 add f3 int default 3, add f4 int default 4 after f3, add f5 int default 5, add f6 int default 6 after f3;
select * from t1;
 f1 | f2 | f3 | f6 | f4 | f5 
----+----+----+----+----+----
  1 |  2 |  3 |  6 |  4 |  5
(1 row)

drop table if exists t1;
create table t1(f1 int, f2 int);
insert into t1 values(1,2);
alter table t1 add f3 int default 3, add f4 int default 4 after f1, add f5 int default 5, add f6 int default 6 after f5;
select * from t1;
 f1 | f4 | f2 | f3 | f5 | f6 
----+----+----+----+----+----
  1 |  4 |  2 |  3 |  5 |  6
(1 row)

drop table if exists t1;
create table t1(f1 int, f2 int);
insert into t1 values(1,2);
alter table t1 add f3 int, add f4 int after f3, add f5 int, add f6 int first;
select * from t1;
 f6 | f1 | f2 | f3 | f4 | f5 
----+----+----+----+----+----
    |  1 |  2 |    |    |   
(1 row)

drop table if exists t1;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
alter table t1 drop f5,
        add f6 int default 6 , add f7 int first, add f8 int default 8 after f3,
        modify f3 timestamp first, modify f6 int after f2, modify f1 text, modify f2 text after f4;
ERROR:  column "f6" of relation "t1" does not exist
drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int, primary key(f1, f3));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 2, 3), (11, 22, 33);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f3) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 22 | 33
(2 rows)

alter table t1 modify f3 int first, modify f1 int after f2;
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f3     | integer | not null  | plain   |              | 
 f2     | integer |           | plain   |              | 
 f1     | integer | not null  | plain   |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f3) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from  t1;
 f3 | f2 | f1 
----+----+----
  3 |  2 |  1
 33 | 22 | 11
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 int, f3 int);
insert into t1 values(1, 2, 3), (11, 12, 13), (21, 22, 23);
select * from t1;
 f1 | f2 | f3 
----+----+----
  1 |  2 |  3
 11 | 12 | 13
 21 | 22 | 23
(3 rows)

alter table t1 add f4 int generated always as (f1 + 100) stored after f1, add f5 int generated always as (f2 * 10) stored first;
select * from t1;
 f5  | f1 | f4  | f2 | f3 
-----+----+-----+----+----
  20 |  1 | 101 |  2 |  3
 120 | 11 | 111 | 12 | 13
 220 | 21 | 121 | 22 | 23
(3 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool, f6 int generated always as (f1 * 10) stored, primary key(f1, f2));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 | f6 
----+----+---------------------------------+----------+----+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t  | 10
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f  | 20
(2 rows)

alter table t1 drop f4,
        add f7 int default 7 , add f8 int first, add f9 int default 9 after f3,
        modify f3 timestamp first, modify f6 int after f2, modify f5 int, modify f2 text after f5,
        add f10 timestamp generated always as (f3) stored after f3,
        add f11 int generated always as (f1 * 100) stored first;
\d+ t1
                                                   Table "public.t1"
 Column |            Type             |                Modifiers                | Storage  | Stats target | Description 
--------+-----------------------------+-----------------------------------------+----------+--------------+-------------
 f11    | integer                     | generated always as ((f1 * 100)) stored | plain    |              | 
 f8     | integer                     |                                         | plain    |              | 
 f3     | timestamp without time zone |                                         | plain    |              | 
 f10    | timestamp without time zone | generated always as (f3) stored         | plain    |              | 
 f9     | integer                     | default 9                               | plain    |              | 
 f1     | integer                     | not null                                | plain    |              | 
 f6     | integer                     |                                         | plain    |              | 
 f5     | integer                     |                                         | plain    |              | 
 f2     | text                        | not null                                | extended |              | 
 f7     | integer                     | default 7                               | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f11 | f8 |               f3                |               f10               | f9 | f1 | f6 | f5 | f2 | f7 
-----+----+---------------------------------+---------------------------------+----+----+----+----+----+----
 100 |    | Tue Nov 08 19:56:10.158564 2022 | Tue Nov 08 19:56:10.158564 2022 |  9 |  1 | 10 |  1 | a  |  7
 200 |    | Wed Nov 09 19:56:10.158564 2022 | Wed Nov 09 19:56:10.158564 2022 |  9 |  2 | 20 |  0 | b  |  7
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 int, primary key(f1, f3));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', 1), (2, 'b', 2);
\d+ t1
                                 Table "public.t1"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f1     | integer               | not null  | plain    |              | 
 f2     | character varying(20) |           | extended |              | 
 f3     | integer               | not null  | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f3) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 | f3 
----+----+----
  1 | a  |  1
  2 | b  |  2
(2 rows)

alter table t1 modify f1 text after f3, add f10 int default 10 after f2;
\d+ t1
                                  Table "public.t1"
 Column |         Type          | Modifiers  | Storage  | Stats target | Description 
--------+-----------------------+------------+----------+--------------+-------------
 f2     | character varying(20) |            | extended |              | 
 f10    | integer               | default 10 | plain    |              | 
 f3     | integer               | not null   | plain    |              | 
 f1     | text                  | not null   | extended |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f3) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f2 | f10 | f3 | f1 
----+-----+----+----
 a  |  10 |  1 | 1
 b  |  10 |  2 | 2
(2 rows)

-- unlogged table
drop table if exists t1 cascade;
create unlogged table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool, f6 int generated always as (f1 * 10) stored, primary key(f1, f2));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
\d+ t1
                                              Unlogged table "public.t1"
 Column |            Type             |               Modifiers                | Storage  | Stats target | Description 
--------+-----------------------------+----------------------------------------+----------+--------------+-------------
 f1     | integer                     | not null                               | plain    |              | 
 f2     | character varying(20)       | not null                               | extended |              | 
 f3     | timestamp without time zone |                                        | plain    |              | 
 f4     | bit(8)                      |                                        | extended |              | 
 f5     | boolean                     |                                        | plain    |              | 
 f6     | integer                     | generated always as ((f1 * 10)) stored | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 | f2 |               f3                |    f4    | f5 | f6 
----+----+---------------------------------+----------+----+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t  | 10
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f  | 20
(2 rows)

alter table t1 drop f4,
        add f7 int default 7 , add f8 int first, add f9 int default 9 after f3,
        modify f3 timestamp first, modify f6 int after f2, modify f5 int, modify f2 text after f5,
        add f10 timestamp generated always as (f3) stored after f3,
        add f11 int generated always as (f1 * 100) stored first;
\d+ t1
                                               Unlogged table "public.t1"
 Column |            Type             |                Modifiers                | Storage  | Stats target | Description 
--------+-----------------------------+-----------------------------------------+----------+--------------+-------------
 f11    | integer                     | generated always as ((f1 * 100)) stored | plain    |              | 
 f8     | integer                     |                                         | plain    |              | 
 f3     | timestamp without time zone |                                         | plain    |              | 
 f10    | timestamp without time zone | generated always as (f3) stored         | plain    |              | 
 f9     | integer                     | default 9                               | plain    |              | 
 f1     | integer                     | not null                                | plain    |              | 
 f6     | integer                     |                                         | plain    |              | 
 f5     | integer                     |                                         | plain    |              | 
 f2     | text                        | not null                                | extended |              | 
 f7     | integer                     | default 7                               | plain    |              | 
Indexes:
    "t1_pkey" PRIMARY KEY, btree (f1, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f11 | f8 |               f3                |               f10               | f9 | f1 | f6 | f5 | f2 | f7 
-----+----+---------------------------------+---------------------------------+----+----+----+----+----+----
 100 |    | Tue Nov 08 19:56:10.158564 2022 | Tue Nov 08 19:56:10.158564 2022 |  9 |  1 | 10 |  1 | a  |  7
 200 |    | Wed Nov 09 19:56:10.158564 2022 | Wed Nov 09 19:56:10.158564 2022 |  9 |  2 | 20 |  0 | b  |  7
(2 rows)

-- temp table
drop table if exists t1 cascade;
create temp table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool, f6 int generated always as (f1 * 10) stored, primary key(f1, f2));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 | f6 
----+----+---------------------------------+----------+----+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t  | 10
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f  | 20
(2 rows)

alter table t1 drop f4,
        add f7 int default 7 , add f8 int first, add f9 int default 9 after f3,
        modify f3 timestamp first, modify f6 int after f2, modify f5 int, modify f2 text after f5,
        add f10 timestamp generated always as (f3) stored after f3,
        add f11 int generated always as (f1 * 100) stored first;
select * from t1;
 f11 | f8 |               f3                |               f10               | f9 | f1 | f6 | f5 | f2 | f7 
-----+----+---------------------------------+---------------------------------+----+----+----+----+----+----
 100 |    | Tue Nov 08 19:56:10.158564 2022 | Tue Nov 08 19:56:10.158564 2022 |  9 |  1 | 10 |  1 | a  |  7
 200 |    | Wed Nov 09 19:56:10.158564 2022 | Wed Nov 09 19:56:10.158564 2022 |  9 |  2 | 20 |  0 | b  |  7
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 SET('beijing','shanghai','nanjing','wuhan'));
NOTICE:  CREATE TABLE will create implicit set "t1_f2_set" for column "t1.f2"
insert into t1 values(1, 'shanghai,beijing'), (2, 'wuhan');
\d+ t1
                           Table "public.t1"
 Column |   Type    | Modifiers | Storage | Stats target | Description 
--------+-----------+-----------+---------+--------------+-------------
 f1     | integer   |           | plain   |              | 
 f2     | t1_f2_set |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
 f1 |        f2        
----+------------------
  1 | beijing,shanghai
  2 | wuhan
(2 rows)

alter table t1 add f3 int default 3 first, add f4 int default 4 after f3,
        add f5 SET('beijing','shanghai','nanjing','wuhan') default 'nanjing' first;
NOTICE:  ALTER TABLE will create implicit set "t1_f5_set" for column "t1.f5"
\d+ t1
                                    Table "public.t1"
 Column |   Type    |          Modifiers           | Storage | Stats target | Description 
--------+-----------+------------------------------+---------+--------------+-------------
 f5     | t1_f5_set | default 'nanjing'::t1_f5_set | plain   |              | 
 f3     | integer   | default 3                    | plain   |              | 
 f4     | integer   | default 4                    | plain   |              | 
 f1     | integer   |                              | plain   |              | 
 f2     | t1_f2_set |                              | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

select * from t1;
   f5    | f3 | f4 | f1 |        f2        
---------+----+----+----+------------------
 nanjing |  3 |  4 |  1 | beijing,shanghai
 nanjing |  3 |  4 |  2 | wuhan
(2 rows)

drop table if exists t1 cascade;
create table t1(f1 int, f2 SET('beijing','shanghai','nanjing','wuhan'));
NOTICE:  CREATE TABLE will create implicit set "t1_f2_set" for column "t1.f2"
-- error
alter table t1 modify f2 SET('beijing','shanghai','nanjing','wuhan') first;
ERROR:  can not alter column type to another set
alter table t1 modify f2 SET('beijing','shanghai','nanjing','wuhan') after f1;
ERROR:  can not alter column type to another set
drop table if exists t1 cascade;
--DTS
drop table if exists unit cascade;
NOTICE:  table "unit" does not exist, skipping
CREATE TABLE unit
(
    f11  INTEGER CHECK (f11 >=2),
    f12  bool,
    f13  text,
	f14  varchar(20),
	primary key (f11,f12)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "unit_pkey" for table "unit"
insert into unit values(2,3,4,5);
insert into unit values(3,4,5,6);
ALTER TABLE unit  ADD f1 int CHECK (f1 >=10) FIRST;
insert into unit values (10,6,1,1,1);
insert into unit values (11,7,1,1,1);
ALTER TABLE unit  ADD f2 int CHECK (f2 >=10) after f11;
select * from unit;
 f1 | f11 | f2 | f12 | f13 | f14 
----+-----+----+-----+-----+-----
    |   2 |    | t   | 4   | 5
    |   3 |    | t   | 5   | 6
 10 |   6 |    | t   | 1   | 1
 11 |   7 |    | t   | 1   | 1
(4 rows)

ALTER TABLE unit MODIFY f12 int FIRST;
select * from unit;
 f12 | f1 | f11 | f2 | f13 | f14 
-----+----+-----+----+-----+-----
   1 |    |   2 |    | 4   | 5
   1 |    |   3 |    | 5   | 6
   1 | 10 |   6 |    | 1   | 1
   1 | 11 |   7 |    | 1   | 1
(4 rows)

drop table if exists unit cascade;
-- dts for set
drop table if exists test_s1 cascade;
NOTICE:  table "test_s1" does not exist, skipping
create table test_s1 (c1 int,c2 SET('aaa','bbb','ccc'), c3 bool, primary key(c1));
NOTICE:  CREATE TABLE will create implicit set "test_s1_c2_set" for column "test_s1.c2"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_s1_pkey" for table "test_s1"
insert into test_s1 values(1,2,1), (2,'aaa',3), (3,4,4), (4,5,5), (5,1,6), (6,3,7);
alter table test_s1 add f1 text after c1;
alter table test_s1 modify c2 int first;
select * from test_s1;
 c2 | c1 | f1 | c3 
----+----+----+----
  2 |  1 |    | t
  1 |  2 |    | t
  4 |  3 |    | t
  5 |  4 |    | t
  1 |  5 |    | t
  3 |  6 |    | t
(6 rows)

drop table if exists test_s1 cascade;
drop table if exists test_s2 cascade;
NOTICE:  table "test_s2" does not exist, skipping
create table test_s2 (c1 int,c2 SET('aaa','bbb','ccc'), c3 bool, primary key(c1));
NOTICE:  CREATE TABLE will create implicit set "test_s2_c2_set" for column "test_s2.c2"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_s2_pkey" for table "test_s2"
insert into test_s2 values(1,2,1), (2,'aaa',3), (3,4,4), (4,5,5), (5,1,6), (6,3,7);
alter table test_s2 add f1 text check(f1 >= 2) after c1;
alter table test_s2 add f2 SET('w','ww','www','wwww') first;
NOTICE:  ALTER TABLE will create implicit set "test_s2_f2_set" for column "test_s2.f2"
alter table test_s2 modify f2 text after c1;
alter table test_s2 modify c2 int first;
select * from test_s2;
 c2 | c1 | f2 | f1 | c3 
----+----+----+----+----
  2 |  1 |    |    | t
  1 |  2 |    |    | t
  4 |  3 |    |    | t
  5 |  4 |    |    | t
  1 |  5 |    |    | t
  3 |  6 |    |    | t
(6 rows)

drop table if exists test_s2 cascade;
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 set('aaa','bbb','ccc'), f2 set('1','2','3'), f3 set('beijing','shannghai','nanjing'),
        f4 set('aaa','bbb','ccc') generated always as(f1+f2+f3) stored,
        f5 set('1','2','3') generated always as(f1+f2+f3) stored,
        f6 set('beijing','shannghai','nanjing') generated always as(f1+f2+f3) stored);
NOTICE:  CREATE TABLE will create implicit set "t1_f1_set" for column "t1.f1"
NOTICE:  CREATE TABLE will create implicit set "t1_f2_set" for column "t1.f2"
NOTICE:  CREATE TABLE will create implicit set "t1_f3_set" for column "t1.f3"
NOTICE:  CREATE TABLE will create implicit set "t1_f4_set" for column "t1.f4"
NOTICE:  CREATE TABLE will create implicit set "t1_f5_set" for column "t1.f5"
NOTICE:  CREATE TABLE will create implicit set "t1_f6_set" for column "t1.f6"
\d+ t1
                                                             Table "public.t1"
 Column |   Type    |                                   Modifiers                                    | Storage | Stats target | Description 
--------+-----------+--------------------------------------------------------------------------------+---------+--------------+-------------
 f1     | t1_f1_set |                                                                                | plain   |              | 
 f2     | t1_f2_set |                                                                                | plain   |              | 
 f3     | t1_f3_set |                                                                                | plain   |              | 
 f4     | t1_f4_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
 f5     | t1_f5_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
 f6     | t1_f6_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 modify f1 int after f6;
\d+ t1
                                                             Table "public.t1"
 Column |   Type    |                                   Modifiers                                    | Storage | Stats target | Description 
--------+-----------+--------------------------------------------------------------------------------+---------+--------------+-------------
 f2     | t1_f2_set |                                                                                | plain   |              | 
 f3     | t1_f3_set |                                                                                | plain   |              | 
 f4     | t1_f4_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
 f5     | t1_f5_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
 f6     | t1_f6_set | generated always as ((((f1)::numeric + (f2)::numeric) + (f3)::numeric)) stored | plain   |              | 
 f1     | integer   |                                                                                | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

alter table t1 drop f1;
\d+ t1
                           Table "public.t1"
 Column |   Type    | Modifiers | Storage | Stats target | Description 
--------+-----------+-----------+---------+--------------+-------------
 f2     | t1_f2_set |           | plain   |              | 
 f3     | t1_f3_set |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1 cascade;
drop table t1 cascade;
ERROR:  table "t1" does not exist
create table t1(f1 int, f2 text, f3 int, f4 bool, f5 int generated always as (f1 + f3) stored); 
insert into t1 values(1, 'aaa', 3, true);
insert into t1 values(11, 'bbb', 33, false);
insert into t1 values(111, 'ccc', 333, true);
insert into t1 values(1111, 'ddd', 3333, true);
 
create view t1_view1 as select * from t1;
select * from t1_view1;
  f1  | f2  |  f3  | f4 |  f5  
------+-----+------+----+------
    1 | aaa |    3 | t  |    4
   11 | bbb |   33 | f  |   44
  111 | ccc |  333 | t  |  444
 1111 | ddd | 3333 | t  | 4444
(4 rows)

alter table t1 modify f1 int after f2, modify f3 int first;
drop view t1_view1;
create view t1_view1 as select * from t1;
alter table t1 modify f1 int after f2, modify f3 int first;
drop table t1 cascade;
NOTICE:  drop cascades to view t1_view1
create table t1(f1 int, f2 text, f3 int, f4 bigint, f5 int generated always as (f1 + f3) stored); 
insert into t1 values(1, 'aaa', 3, 1);
insert into t1 values(11, 'bbb', 33, 2);
insert into t1 values(111, 'ccc', 333, 3);
insert into t1 values(1111, 'ddd', 3333, 4);
create view t1_view1 as select * from t1;
select * from t1_view1;
  f1  | f2  |  f3  | f4 |  f5  
------+-----+------+----+------
    1 | aaa |    3 |  1 |    4
   11 | bbb |   33 |  2 |   44
  111 | ccc |  333 |  3 |  444
 1111 | ddd | 3333 |  4 | 4444
(4 rows)

alter table t1 add f6 int first, add f7 int after f4, modify f1 int after f2, modify f3 int first;
select * from t1_view1;
  f1  | f2  |  f3  | f4 |  f5  
------+-----+------+----+------
    1 | aaa |    3 |  1 |    4
   11 | bbb |   33 |  2 |   44
  111 | ccc |  333 |  3 |  444
 1111 | ddd | 3333 |  4 | 4444
(4 rows)

drop view t1_view1;
create view t1_view2 as select f1, f3, f5 from t1 where f2='aaa';
select * from t1_view2;
 f1 | f3 | f5 
----+----+----
  1 |  3 |  4
(1 row)

alter table t1 add f8 int first, add f9 int after f4, modify f1 int after f2, modify f3 int first, modify f2 varchar(20) first;
select * from t1_view2;
 f1 | f3 | f5 
----+----+----
  1 |  3 |  4
(1 row)

drop view t1_view2;
create view t1_view3 as select * from (select f1+f3, f5 from t1);
select * from t1_view3;
 ?column? |  f5  
----------+------
        4 |    4
       44 |   44
      444 |  444
     4444 | 4444
(4 rows)

alter table t1 add f10 int first, add f11 int after f4, modify f1 int after f2, modify f3 int first, modify f2 varchar(20) first;
select * from t1_view3;
 ?column? |  f5  
----------+------
        4 |    4
       44 |   44
      444 |  444
     4444 | 4444
(4 rows)

drop view t1_view3;
create view t1_view4 as select * from (select abs(f1+f3) as col1, abs(f5) as col2 from t1);
select * from t1_view4;
 col1 | col2 
------+------
    4 |    4
   44 |   44
  444 |  444
 4444 | 4444
(4 rows)

alter table t1 add f12 int first, add f13 int after f4, modify f1 int after f2, modify f3 int first, modify f2 varchar(20) first;
select * from t1_view4;
 col1 | col2 
------+------
    4 |    4
   44 |   44
  444 |  444
 4444 | 4444
(4 rows)

drop view t1_view4;
create view t1_view5 as select * from (select * from t1);
select * from t1_view5;
 f12 | f2  |  f3  | f10 |  f1  | f8 | f6 | f4 | f13 | f11 | f9 | f7 |  f5  
-----+-----+------+-----+------+----+----+----+-----+-----+----+----+------
     | aaa |    3 |     |    1 |    |    |  1 |     |     |    |    |    4
     | bbb |   33 |     |   11 |    |    |  2 |     |     |    |    |   44
     | ccc |  333 |     |  111 |    |    |  3 |     |     |    |    |  444
     | ddd | 3333 |     | 1111 |    |    |  4 |     |     |    |    | 4444
(4 rows)

alter table t1 add f14 int first, add f15 int after f4, modify f1 int after f2, modify f3 int first;
select * from t1_view5;
 f12 | f2  |  f3  | f10 |  f1  | f8 | f6 | f4 | f13 | f11 | f9 | f7 |  f5  
-----+-----+------+-----+------+----+----+----+-----+-----+----+----+------
     | aaa |    3 |     |    1 |    |    |  1 |     |     |    |    |    4
     | bbb |   33 |     |   11 |    |    |  2 |     |     |    |    |   44
     | ccc |  333 |     |  111 |    |    |  3 |     |     |    |    |  444
     | ddd | 3333 |     | 1111 |    |    |  4 |     |     |    |    | 4444
(4 rows)

drop view t1_view5;
create view t1_view6 as select f1, f3, f5 from t1 where f2='aaa';
select * from t1_view6;
 f1 | f3 | f5 
----+----+----
  1 |  3 |  4
(1 row)

alter table t1 modify f1 int after f2, modify f3 int first, modify f2 varchar(20) first;
select * from t1_view6;
 f1 | f3 | f5 
----+----+----
  1 |  3 |  4
(1 row)

drop view t1_view6;
drop table t1 cascade;
-- dts for add
drop table if exists test_d;
NOTICE:  table "test_d" does not exist, skipping
create table test_d (f2 int primary key, f3 bool, f5 text);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_d_pkey" for table "test_d"
insert into test_d values(1,2,3), (2,3,4), (3,4,5);
select * from test_d;
 f2 | f3 | f5 
----+----+----
  1 | t  | 3
  2 | t  | 4
  3 | t  | 5
(3 rows)

alter table test_d add f1 int default 1,add f11 text check (f11 >=2) first;
select * from test_d;
 f11 | f2 | f3 | f5 | f1 
-----+----+----+----+----
     |  1 | t  | 3  |  1
     |  2 | t  | 4  |  1
     |  3 | t  | 5  |  1
(3 rows)

 
drop table if exists test_d;
create table test_d (f2 int primary key, f3 bool, f5 text);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_d_pkey" for table "test_d"
insert into test_d values(1,2,3), (2,3,4), (3,4,5);
select * from test_d;
 f2 | f3 | f5 
----+----+----
  1 | t  | 3
  2 | t  | 4
  3 | t  | 5
(3 rows)

alter table test_d add f1 int default 1;
alter table test_d add f11 text check (f11 >=2) first;
select * from test_d;
 f11 | f2 | f3 | f5 | f1 
-----+----+----+----+----
     |  1 | t  | 3  |  1
     |  2 | t  | 4  |  1
     |  3 | t  | 5  |  1
(3 rows)

drop table if exists test_d;
 
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

alter table t1 add f6 int generated always as (f1 * 10) stored, add f7 text default '777' first,
        add f8 int default 8, add f9 int primary key auto_increment after f6;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f9_seq" for serial column "t1.f9"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select * from t1;
 f7  | f1 | f2 |               f3                |    f4    | f5 | f6 | f9 | f8 
-----+----+----+---------------------------------+----------+----+----+----+----
 777 |  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t  | 10 |  1 |  8
 777 |  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f  | 20 |  2 |  8
(2 rows)

 
drop table if exists t1 cascade;
create table t1(f1 int, f2 varchar(20), f3 timestamp, f4 bit(8), f5 bool);
insert into t1 values(1, 'a', '2022-11-08 19:56:10.158564', x'41', true), (2, 'b', '2022-11-09 19:56:10.158564', x'42', false);
select * from t1;
 f1 | f2 |               f3                |    f4    | f5 
----+----+---------------------------------+----------+----
  1 | a  | Tue Nov 08 19:56:10.158564 2022 | 01000001 | t
  2 | b  | Wed Nov 09 19:56:10.158564 2022 | 01000010 | f
(2 rows)

alter table t1 add f6 int generated always as (f1 * 10) stored, add f7 text default '7' first,
        add f8 int default 8, add f9 int primary key auto_increment after f1,
        add f10 bool default true, add f11 timestamp after f2,
        add f12 text after f3, add f14 int default '14', add f15 int default 15 check(f15 = 15) after f9;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f9_seq" for serial column "t1.f9"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
select * from t1;
 f7 | f1 | f9 | f15 | f2 | f11 |               f3                | f12 |    f4    | f5 | f6 | f8 | f10 | f14 
----+----+----+-----+----+-----+---------------------------------+-----+----------+----+----+----+-----+-----
 7  |  1 |  1 |  15 | a  |     | Tue Nov 08 19:56:10.158564 2022 |     | 01000001 | t  | 10 |  8 | t   |  14
 7  |  2 |  2 |  15 | b  |     | Wed Nov 09 19:56:10.158564 2022 |     | 01000010 | f  | 20 |  8 | t   |  14
(2 rows)

drop table if exists t1 cascade;
drop table if exists t1 cascade;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int comment 'f1 is int', f2 varchar(20), f3 timestamp comment 'f3 is timestamp', f4 bit(8), f5 bool comment 'f5 is boolean');
SELECT pg_get_tabledef('t1');
                pg_get_tabledef                
-----------------------------------------------
 SET search_path = public;                    +
 CREATE TABLE t1 (                            +
     f1 integer,                              +
     f2 character varying(20),                +
     f3 timestamp without time zone,          +
     f4 bit(8),                               +
     f5 boolean                               +
 )                                            +
 WITH (orientation=row, compression=no);      +
 COMMENT ON COLUMN t1.f1 IS 'f1 is int';      +
 COMMENT ON COLUMN t1.f3 IS 'f3 is timestamp';+
 COMMENT ON COLUMN t1.f5 IS 'f5 is boolean';
(1 row)

alter table t1 add f6 int generated always as (f1 * 10) stored, add f7 text default '7' first, add f8 int primary key auto_increment after f2;
NOTICE:  ALTER TABLE will create implicit sequence "t1_f8_seq" for serial column "t1.f8"
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
SELECT pg_get_tabledef('t1');
                    pg_get_tabledef                     
--------------------------------------------------------
 SET search_path = public;                             +
 CREATE TABLE t1 (                                     +
     f7 text DEFAULT '7'::text,                        +
     f1 integer,                                       +
     f2 character varying(20),                         +
     f8 integer AUTO_INCREMENT NOT NULL,               +
     f3 timestamp without time zone,                   +
     f4 bit(8),                                        +
     f5 boolean,                                       +
     f6 integer GENERATED ALWAYS AS ((f1 * 10)) STORED,+
     CONSTRAINT t1_pkey PRIMARY KEY (f8)               +
 ) AUTO_INCREMENT = 1                                  +
 WITH (orientation=row, compression=no);               +
 COMMENT ON COLUMN t1.f1 IS 'f1 is int';               +
 COMMENT ON COLUMN t1.f3 IS 'f3 is timestamp';         +
 COMMENT ON COLUMN t1.f5 IS 'f5 is boolean';
(1 row)

alter table t1 modify f1 int after f3, modify f5 bool first, modify f3 timestamp after f4;
SELECT pg_get_tabledef('t1');
                    pg_get_tabledef                     
--------------------------------------------------------
 SET search_path = public;                             +
 CREATE TABLE t1 (                                     +
     f5 boolean,                                       +
     f7 text DEFAULT '7'::text,                        +
     f2 character varying(20),                         +
     f8 integer AUTO_INCREMENT NOT NULL,               +
     f1 integer,                                       +
     f4 bit(8),                                        +
     f3 timestamp without time zone,                   +
     f6 integer GENERATED ALWAYS AS ((f1 * 10)) STORED,+
     CONSTRAINT t1_pkey PRIMARY KEY (f8)               +
 ) AUTO_INCREMENT = 1                                  +
 WITH (orientation=row, compression=no);
(1 row)

drop table if exists t1 cascade;
-- test about setting schema by RenameStmt
CREATE SCHEMA test1;
CREATE SCHEMA test2;
CREATE TABLE test1.test(a int primary key, b int not null);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_pkey" for table "test"
CREATE INDEX ON test1.test using btree(b);
INSERT INTO test1.test VALUES (1, 1);
\d+ test1.test
                         Table "test1.test"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer | not null  | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_pkey" PRIMARY KEY, btree (a) TABLESPACE pg_default
    "test_b_idx" btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

SELECT n.nspname, c.relname from pg_class c, pg_namespace n where n.oid = c.relnamespace and c.relname in ('test', 'test_pkey', 'test_b_idx', 'tttt') order by c.relname;
 nspname |  relname   
---------+------------
 test1   | test
 test1   | test_b_idx
 test1   | test_pkey
(3 rows)

SELECT * FROM test1.test;
 a | b 
---+---
 1 | 1
(1 row)

-- check about type
SELECT n.nspname, t.typname FROM pg_type t, pg_namespace n where t.typnamespace = n.oid and t.typname in ('test','tttt');
 nspname | typname 
---------+---------
 test1   | test
(1 row)

ALTER TABLE test1.test RENAME TO test2.tttt;
\d+ test1.test
\d+ test2.tttt
                         Table "test2.tttt"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer | not null  | plain   |              | 
 b      | integer | not null  | plain   |              | 
Indexes:
    "test_pkey" PRIMARY KEY, btree (a) TABLESPACE pg_default
    "test_b_idx" btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

SELECT n.nspname, c.relname from pg_class c, pg_namespace n where n.oid = c.relnamespace and c.relname in ('test', 'test_pkey', 'test_b_idx', 'tttt') order by c.relname;
 nspname |  relname   
---------+------------
 test2   | test_b_idx
 test2   | test_pkey
 test2   | tttt
(3 rows)

INSERT INTO test2.tttt VALUES (2, 2);
SELECT * FROM test1.test;
ERROR:  relation "test1.test" does not exist on datanode1
LINE 1: SELECT * FROM test1.test;
                      ^
SELECT * FROM test2.tttt;
 a | b 
---+---
 1 | 1
 2 | 2
(2 rows)

-- check about type
SELECT n.nspname, t.typname FROM pg_type t, pg_namespace n where t.typnamespace = n.oid and t.typname in ('test','tttt');
 nspname | typname 
---------+---------
 test2   | tttt
(1 row)

-- just rename
ALTER TABLE test2.tttt RENAME TO test2.ttt;
SELECT * FROM test2.tttt;
ERROR:  relation "test2.tttt" does not exist on datanode1
LINE 1: SELECT * FROM test2.tttt;
                      ^
SELECT * FROM test2.ttt;
 a | b 
---+---
 1 | 1
 2 | 2
(2 rows)

-- check about type
SELECT n.nspname, t.typname FROM pg_type t, pg_namespace n where t.typnamespace = n.oid and t.typname = 'ttt';
 nspname | typname 
---------+---------
 test2   | ttt
(1 row)

-- just move to other schema
CREATE TABLE test1.t1 (a int);
\d+ test1.t1
                          Table "test1.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

ALTER TABLE test1.t1 RENAME TO test2.t1;
\d+ test1.t1
\d+ test2.t1
                          Table "test2.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- check about type
SELECT n.nspname, t.typname FROM pg_type t, pg_namespace n where t.typnamespace = n.oid and t.typname = 't1';
 nspname | typname 
---------+---------
 test2   | t1
(1 row)

-- test about partition table
CREATE TABLE test1.sales_table1
(
    order_no INTEGER NOT NULL,
    goods_name CHAR(20) NOT NULL,
    sales_date DATE NOT NULL,
    sales_volume INTEGER,
    sales_store CHAR(20)
)
PARTITION BY RANGE(sales_date)
(
    PARTITION sales_table1_season1 VALUES LESS THAN('2021-04-01 00:00:00'),
    PARTITION sales_table1_season2 VALUES LESS THAN('2021-07-01 00:00:00'),
    PARTITION sales_table1_season3 VALUES LESS THAN('2021-10-01 00:00:00'),
    PARTITION sales_table1_season4 VALUES LESS THAN(MAXVALUE)
);
CREATE TABLE test1.sales_table2
(
    order_no INTEGER NOT NULL,
    goods_name CHAR(20) NOT NULL,
    sales_date DATE NOT NULL,
    sales_volume INTEGER,
    sales_store CHAR(20)
)
PARTITION BY RANGE(sales_date)
(
    PARTITION sales_table2_season1 VALUES LESS THAN('2021-04-01 00:00:00'),
    PARTITION sales_table2_season2 VALUES LESS THAN('2021-07-01 00:00:00'),
    PARTITION sales_table2_season3 VALUES LESS THAN('2021-10-01 00:00:00'),
    PARTITION sales_table2_season4 VALUES LESS THAN(MAXVALUE)
);
CREATE TABLE test1.sales_table3
(
    order_no INTEGER NOT NULL,
    goods_name CHAR(20) NOT NULL,
    sales_date DATE NOT NULL,
    sales_volume INTEGER,
    sales_store CHAR(20)
)
PARTITION BY RANGE(sales_date)
(
    PARTITION sales_table3_season1 VALUES LESS THAN('2021-04-01 00:00:00'),
    PARTITION sales_table3_season2 VALUES LESS THAN('2021-07-01 00:00:00'),
    PARTITION sales_table3_season3 VALUES LESS THAN('2021-10-01 00:00:00'),
    PARTITION sales_table3_season4 VALUES LESS THAN(MAXVALUE)
);
SELECT n.nspname, c.relname, p.relname AS partition_name
FROM pg_class c, pg_namespace n, pg_partition p 
WHERE n.oid = c.relnamespace and c.oid = p.parentid and c.relname like '%sales_table%' ORDER BY 1, 2, 3;
 nspname |   relname    |    partition_name    
---------+--------------+----------------------
 test1   | sales_table1 | sales_table1
 test1   | sales_table1 | sales_table1_season1
 test1   | sales_table1 | sales_table1_season2
 test1   | sales_table1 | sales_table1_season3
 test1   | sales_table1 | sales_table1_season4
 test1   | sales_table2 | sales_table2
 test1   | sales_table2 | sales_table2_season1
 test1   | sales_table2 | sales_table2_season2
 test1   | sales_table2 | sales_table2_season3
 test1   | sales_table2 | sales_table2_season4
 test1   | sales_table3 | sales_table3
 test1   | sales_table3 | sales_table3_season1
 test1   | sales_table3 | sales_table3_season2
 test1   | sales_table3 | sales_table3_season3
 test1   | sales_table3 | sales_table3_season4
(15 rows)

ALTER TABLE test1.sales_table1 RENAME TO test2.sales_table1;
ALTER TABLE test1.sales_table2 RENAME TO test2.sales_table3;
ALTER TABLE test1.sales_table3 RENAME TO test1.sales_table4;
SELECT n.nspname, c.relname, p.relname AS partition_name
FROM pg_class c, pg_namespace n, pg_partition p 
WHERE n.oid = c.relnamespace and c.oid = p.parentid and c.relname like '%sales_table%' ORDER BY 1, 2, 3;
 nspname |   relname    |    partition_name    
---------+--------------+----------------------
 test1   | sales_table4 | sales_table3_season1
 test1   | sales_table4 | sales_table3_season2
 test1   | sales_table4 | sales_table3_season3
 test1   | sales_table4 | sales_table3_season4
 test1   | sales_table4 | sales_table4
 test2   | sales_table1 | sales_table1
 test2   | sales_table1 | sales_table1_season1
 test2   | sales_table1 | sales_table1_season2
 test2   | sales_table1 | sales_table1_season3
 test2   | sales_table1 | sales_table1_season4
 test2   | sales_table3 | sales_table2_season1
 test2   | sales_table3 | sales_table2_season2
 test2   | sales_table3 | sales_table2_season3
 test2   | sales_table3 | sales_table2_season4
 test2   | sales_table3 | sales_table3
(15 rows)

-- rename table with view or matview
CREATE TABLE test1.test_table_view1 (a int);
CREATE TABLE test1.test_table_view2 (a int);
CREATE TABLE test1.test_table_matview1 (a int);
CREATE TABLE test1.test_table_matview2 (a int);
CREATE VIEW test1.test_view1 AS SELECT * FROM test1.test_table_view1;
CREATE VIEW test1.test_view2 AS SELECT * FROM test1.test_table_view2;
CREATE MATERIALIZED VIEW test1.test_matview1 AS SELECT * FROM test1.test_table_matview1;
CREATE MATERIALIZED VIEW test1.test_matview2 AS SELECT * FROM test1.test_table_matview2;
ALTER TABLE test1.test_table_view1 RENAME TO test2.test_table_view1; -- just move to other schema
ALTER TABLE test1.test_table_view2 RENAME TO test2.test_table_view3; -- rename and move to other schema
SELECT * FROM test1.test_view1;
 a 
---
(0 rows)

SELECT pg_get_viewdef('test1.test_view1');
             pg_get_viewdef             
----------------------------------------
 SELECT  * FROM test2.test_table_view1;
(1 row)

SELECT * FROM test1.test_view2;
 a 
---
(0 rows)

SELECT pg_get_viewdef('test1.test_view2');
                     pg_get_viewdef                      
---------------------------------------------------------
 SELECT  * FROM test2.test_table_view3 test_table_view2;
(1 row)

ALTER TABLE test1.test_table_matview1 RENAME TO test2.test_table_matview1; -- just move to other schema
ALTER TABLE test1.test_table_matview2 RENAME TO test2.test_table_matview3; -- rename and move to other schema
SELECT * FROM test1.test_matview1;
 a 
---
(0 rows)

SELECT pg_get_viewdef('test1.test_matview1');
              pg_get_viewdef               
-------------------------------------------
 SELECT  * FROM test2.test_table_matview1;
(1 row)

SELECT * FROM test1.test_matview2;
 a 
---
(0 rows)

SELECT pg_get_viewdef('test1.test_matview2');
                        pg_get_viewdef                         
---------------------------------------------------------------
 SELECT  * FROM test2.test_table_matview3 test_table_matview2;
(1 row)

-- rename to a existed table
CREATE TABLE test1.name1 (a int);
CREATE TABLE test2.name1 (a int);
CREATE TABLE test2.name2 (a int);
ALTER TABLE test1.name1 RENAME TO test2.name1;
ERROR:  relation "name1" already exists in schema "test2"
ALTER TABLE test1.name1 RENAME TO test2.name2;
ERROR:  relation "name2" already exists in schema "test2"
ALTER TABLE test2.name1 RENAME TO test2.name2;
ERROR:  relation "name2" already exists in schema "test2"
CREATE TABLE t_after_first ( c4 INT , c5 INT ) ;
INSERT INTO t_after_first VALUES ( 1 , 2 ) , ( 3 , 4 ) ;
ALTER TABLE t_after_first ADD COLUMN c11 VARCHAR ( 2 ) , ADD COLUMN c22 VARCHAR ( 2 ) AFTER c11 , ADD COLUMN c57 INT FIRST;
select * from t_after_first;
 c57 | c4 | c5 | c11 | c22 
-----+----+----+-----+-----
     |  1 |  2 |     | 
     |  3 |  4 |     | 
(2 rows)

drop table if exists test_dts;
NOTICE:  table "test_dts" does not exist, skipping
create table test_dts(
        f1 int primary key,
        f2 varchar(8),
        f3 timestamp
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_dts_pkey" for table "test_dts"
insert into test_dts(f1, f2, f3) values(1, 'data1', '2023-07-31 12:34:56'), (2, 'date2', '2023-07-31 13:45:30'),
(3, 'data3', '2023-07-31 14:56:15'), (4, 'data1', '2023-07-31 12:34:56'), (5, 'date2', '2023-07-31 13:45:30'),
(6, 'data3', '2023-07-31 14:56:15');
analyze test_dts;
analyze test_dts((f1, f3));
INFO:  Please set default_statistics_target to a negative value to collect extended statistics.
select staattnum, stavalues1 from pg_statistic where starelid = 'test_dts'::regclass order by staattnum;
 staattnum |                                     stavalues1                                     
-----------+------------------------------------------------------------------------------------
         1 | {1,2,3,4,5,6}
         2 | {data1,data3,date2}
         3 | {"Mon Jul 31 12:34:56 2023","Mon Jul 31 13:45:30 2023","Mon Jul 31 14:56:15 2023"}
(3 rows)

select stakey from pg_statistic_ext where starelid = 'test_dts'::regclass;
 stakey 
--------
(0 rows)

alter table test_dts add column f4 int default 0 after f1;
select staattnum, stavalues1 from pg_statistic where starelid = 'test_dts'::regclass order by staattnum;
 staattnum |                                     stavalues1                                     
-----------+------------------------------------------------------------------------------------
         1 | {1,2,3,4,5,6}
         3 | {data1,data3,date2}
         4 | {"Mon Jul 31 12:34:56 2023","Mon Jul 31 13:45:30 2023","Mon Jul 31 14:56:15 2023"}
(3 rows)

select stakey from pg_statistic_ext where starelid = 'test_dts'::regclass;
 stakey 
--------
(0 rows)

alter table test_dts add column f5 varchar(20) default 'f5' first;
select staattnum, stavalues1 from pg_statistic where starelid = 'test_dts'::regclass order by staattnum;
 staattnum |                                     stavalues1                                     
-----------+------------------------------------------------------------------------------------
         2 | {1,2,3,4,5,6}
         4 | {data1,data3,date2}
         5 | {"Mon Jul 31 12:34:56 2023","Mon Jul 31 13:45:30 2023","Mon Jul 31 14:56:15 2023"}
(3 rows)

select stakey from pg_statistic_ext where starelid = 'test_dts'::regclass;
 stakey 
--------
(0 rows)

alter table test_dts modify f5 varchar(20) after f4;
select staattnum, stavalues1 from pg_statistic where starelid = 'test_dts'::regclass order by staattnum;
 staattnum |                                     stavalues1                                     
-----------+------------------------------------------------------------------------------------
         1 | {1,2,3,4,5,6}
         4 | {data1,data3,date2}
         5 | {"Mon Jul 31 12:34:56 2023","Mon Jul 31 13:45:30 2023","Mon Jul 31 14:56:15 2023"}
(3 rows)

select stakey from pg_statistic_ext where starelid = 'test_dts'::regclass;
 stakey 
--------
(0 rows)

alter table test_dts modify f1 int first;
select staattnum, stavalues1 from pg_statistic where starelid = 'test_dts'::regclass order by staattnum;
 staattnum |                                     stavalues1                                     
-----------+------------------------------------------------------------------------------------
         4 | {data1,data3,date2}
         5 | {"Mon Jul 31 12:34:56 2023","Mon Jul 31 13:45:30 2023","Mon Jul 31 14:56:15 2023"}
(2 rows)

select stakey from pg_statistic_ext where starelid = 'test_dts'::regclass;
 stakey 
--------
(0 rows)

drop table if exists test_dts;
drop table if exists t_after_first;
create table t_after_first(c4 int, c5 int);
insert into t_after_first values(1, 2), (3, 4);
alter table t_after_first add column c11 varchar(2), add column c22 varchar(2) after c11, add column c57 int first;
select * from t_after_first;
 c57 | c4 | c5 | c11 | c22 
-----+----+----+-----+-----
     |  1 |  2 |     | 
     |  3 |  4 |     | 
(2 rows)

drop table if exists t_after_first;
-- test for modify type
drop table if exists fat0;
NOTICE:  table "fat0" does not exist, skipping
create table fat0(c41 int, c17 int);
insert into fat0 values(-104 not in (58, -123, -109), -49), (64, -28);
alter table fat0 modify column c17 int first, modify column c41 text, add column c4 int after c17, add column c61 int after c41, add constraint cc0 unique fai0(c17);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "fai0" for table "fat0"
insert into fat0 values(-51, 2, -20, default), (-34, 81, -24, default);
select * from fat0;
 c17 | c4 | c41 | c61 
-----+----+-----+-----
 -49 |    | 1   |    
 -28 |    | 64  |    
 -51 |  2 | -20 |    
 -34 | 81 | -24 |    
(4 rows)

drop table if exists fat0;
create table fat0(c41 int, c17 text);
insert into fat0 values(-104 not in(58, -123, -109), -49), (64, -28);
alter table fat0 modify c17 int first, modify column c41 int, add column c4 int after c17;
select * from fat0;
 c17 | c4 | c41 
-----+----+-----
 -49 |    |   1
 -28 |    |  64
(2 rows)

drop table if exists fat0;
create table fat0(c41 int, c17 int, c21 int);
insert into fat0 values(-104 not in(58, -123, -109), -49, -12),(64, -28, 20);
alter table fat0 modify column c17 text, modify column c41 text, add column c21 int after c41;
ERROR:  column "c21" of relation "fat0" already exists
insert into fat0 values(-51, 2, -20), (-34, 81, -24);
select * from fat0;
 c41 | c17 | c21 
-----+-----+-----
   1 | -49 | -12
  64 | -28 |  20
 -51 |   2 | -20
 -34 |  81 | -24
(4 rows)

drop table if exists fat0;
create table fat0(c41 int, c17 int, c21 int);
insert into fat0 values(-104 not in (58, -123, -109), -49, -12), (64, -28, 20);
alter table fat0 modify column c17 text first, modify column c41 text, add column c21 int after c41;
ERROR:  column "c21" of relation "fat0" already exists
insert into fat0 values(-51, 2, -20), (-34, 81, -24);
select * from fat0;
 c41 | c17 | c21 
-----+-----+-----
   1 | -49 | -12
  64 | -28 |  20
 -51 |   2 | -20
 -34 |  81 | -24
(4 rows)

drop table if exists fat0;
-- test for modify type not has column
create table fat0(c41 int, c17 int);
insert into fat0 values(-104 not in(58, -123, -109), -49), (64, -28);
alter table fat0 modify c17 int first, modify c41 text, add c4 int after c17, add c61 int after c41, add constraint cc0 unique fai0(c17);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "fai0" for table "fat0"
select * from fat0;
 c17 | c4 | c41 | c61 
-----+----+-----+-----
 -49 |    | 1   |    
 -28 |    | 64  |    
(2 rows)

drop table if exists fat0;
create table fat0(c41 int, c17 int);
insert into fat0 values(-104 not in (58, -123, -109), -49), (64, -28);
alter table fat0 modify column c17 int first, modify column c41 text;
drop table if exists fat0;
create table fat0(c41 int, c17 int);
insert into fat0 values(-104 not in (58, -123, -109), -49), (64, -28);
alter table fat0 modify c17 int first, modify c41 text;
drop table if exists fat0;
drop table if exists t0;
NOTICE:  table "t0" does not exist, skipping
create table t0(c32 int, c6 text default (substring (-108, true) is null));
insert into t0 values (55, -34), (-123, -49);
alter table t0 change column c32 c59 int after c6, modify column c59 bigint;
select * from t0;
 c6  | c59  
-----+------
 -34 |   55
 -49 | -123
(2 rows)

drop table if exists t0;
create table t0(c32 int, c6 text default (substring (-108, true) is null));
insert into t0 values(55, -34), (-123, -49);
alter table t0 change column c32 c59 int after c6, modify column c59 bigint;
select * from t0;
 c6  | c59  
-----+------
 -34 |   55
 -49 | -123
(2 rows)

alter table t0 change column c6 c int first, add x int default 11 first, modify column c text;
select * from t0;
 x  |  c  | c59  
----+-----+------
 11 | -34 |   55
 11 | -49 | -123
(2 rows)

drop table if exists t0;
create table t0(c32 int, c6 text default (substring (-108, true) is null));
insert into t0 values(55, -34), (-123, -49);
alter table t0 change column c32 c59 int after c6, modify c59 bigint;
select * from t0;
 c6  | c59  
-----+------
 -34 |   55
 -49 | -123
(2 rows)

alter table t0 add x int default 11 first, change column c6 c int first, modify c text;
select * from t0;
 x  |  c  | c59  
----+-----+------
 11 | -34 |   55
 11 | -49 | -123
(2 rows)

drop table if exists t0;
drop table if exists t0;
NOTICE:  table "t0" does not exist, skipping
create table t0(c32 int, c6 text default (substring(-108, true) is null));
insert into t0 values(55, -34), (-123, -49);
alter table t0 change column c32 c59 int after c6, modify c59 bigint;
select * from t0;
 c6  | c59  
-----+------
 -34 |   55
 -49 | -123
(2 rows)

alter table t0 change column c6 c int first, add x int default 11 first, modify c text;
select * from t0;
 x  |  c  | c59  
----+-----+------
 11 | -34 |   55
 11 | -49 | -123
(2 rows)

drop table if exists t0;
drop table if exists t0;
NOTICE:  table "t0" does not exist, skipping
create table t0(c32 int, c6 text default (substring (-108, true) is null));
insert into t0 change column c32 c59 int after c6, modify c59 bigint;
ERROR:  syntax error at or near "change"
LINE 1: insert into t0 change column c32 c59 int after c6, modify c5...
                       ^
select * from t0;
 c32 | c6 
-----+----
(0 rows)

alter table t0 add x int default 11 first;
select * from t0;
 x | c32 | c6 
---+-----+----
(0 rows)

alter table t0 change column c6 c int first, modify c text after x, change column c59 c32 bigint first, modify column c32 text after c;
ERROR:  column "c59" does not exist
select * from t0;
 x | c32 | c6 
---+-----+----
(0 rows)

drop table if exists t0;
\c postgres
drop database test_first_after_B;
