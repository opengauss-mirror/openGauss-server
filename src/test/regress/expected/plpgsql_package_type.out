-- FOR PL/pgSQL ARRAY of RECORD TYPE scenarios --
-- check compatibility --
show sql_compatibility; -- expect ORA --
 sql_compatibility 
-------------------
 A
(1 row)

-- create new schema --
drop schema if exists plpgsql_packagetype1;
NOTICE:  schema "plpgsql_packagetype1" does not exist, skipping
create schema plpgsql_packagetype1;
drop schema if exists plpgsql_packagetype2;
NOTICE:  schema "plpgsql_packagetype2" does not exist, skipping
create schema plpgsql_packagetype2;
-- initialize table and type--
----------------------------------------------------
------------------ START OF TESTS ------------------
----------------------------------------------------
-- test package type internal use
set search_path=plpgsql_packagetype1;
create or replace package p_test1 as
    type t1 is record(c1 varchar2, c2 int);
    type t2 is table of t1;
    function f1(ss in t1) return t1;
    function f2(ss in t2) return t2;
    procedure p1(aa in t1,bb in t2,cc out t1,dd out t2);
	procedure p2(aa in int);
end p_test1;
/
create or replace package p_test1 as
    type t1 is record(c1 varchar2, c2 int);
    type t2 is table of t1;
    function f1(ss in t1) return t1;
    function f2(ss in t2) return t2;
    procedure p1(aa in t1,bb in t2,cc out t1,dd out t2);
        procedure p2(aa in int);
end p_test1;
/
create or replace package body p_test1 as
    vb char;
    function f1(ss in t1) return t1 as
        va t1;
	begin
        va := ss;
        plpgsql_packagetype1.p_test1.vb := '';
        raise info '%',va;
        return va;
	end;

    function f2(ss in t2) return t2 as
        vb t2;
	begin
        vb := ss;
        return vb;
	end;
    
    procedure p1(aa in t1,bb in t2,cc out t1,dd out t2) as
	begin
        cc := aa;
        dd := bb;
        raise info '% %', cc,dd;
    end;
	
    procedure p2(aa in int) as
	    aa t1;
	    bb t2;
	    cc t1;
	    dd t2;
	begin
	    aa := ('a',1);
		bb := array[('b',2),('c',3)];
		p1(aa,bb,cc,dd);
	end;
		
end p_test1;
/
create or replace package body p_test1 as
    function f1(ss in t1) return t1 as
        va t1;
        begin
        va := ss;
        raise info '%',va;
        return va;
        end;

    function f2(ss in t2) return t2 as
        vb t2;
        begin
        vb := ss;
        return vb;
        end;

        procedure p1(aa in t1,bb in t2,cc out t1,dd out t2) as
        begin
        cc := aa;
        dd := bb;
        raise info '% %', cc,dd;
    end;

    procedure p2(aa in int) as
            aa t1;
            bb t2;
            cc t1;
            dd t2;
        begin
            aa := ('a',1);
                bb := array[('b',2),('c',3)];
                p1(aa,bb,cc,dd);
        end;

end p_test1;
/
select p_test1.f1(('a',3));
INFO:  (a,3)
CONTEXT:  referenced column: f1
  f1   
-------
 (a,3)
(1 row)

select p_test1.f2(array[('a',1)::p_test1.t1,('b',2)::p_test1.t1,('c',4)::p_test1.t1]);
            f2             
---------------------------
 {"(a,1)","(b,2)","(c,4)"}
(1 row)

-- test package type used in another package
create or replace package p_test2 as
    var1 p_test1.t1;
    type t21 is record(c1 p_test1.t1);
    type t22 is table of p_test1.t1;
    function ff1(ss in p_test1.t1) return p_test1.t1;
    procedure pp1(aa in p_test1.t1,bb in p_test1.t2,cc out p_test1.t1,dd out p_test1.t2);
    procedure pp2(aa in int);
end p_test2;
/
create or replace package body p_test2 as
    function ff1(ss in p_test1.t1) return p_test1.t1 as
        va p_test1.t1;
	begin
        va := ss;
        raise info '%',va;
        return va;
	end;


	procedure pp1(aa in p_test1.t1,bb in p_test1.t2,cc out p_test1.t1,dd out p_test1.t2) as
	begin
        cc := aa;
        dd := bb;
        raise info '% %', cc,dd;
    end;
	
    procedure pp2(aa in int) as
	    aa p_test1.t1;
	    bb p_test1.t2;
	    cc p_test1.t1;
	    dd p_test1.t2;
	begin
	    aa := ('a',1);
		bb := array[('b',2),('c',3)];
		pp1(aa,bb,cc,dd);
	end;
		
end p_test2;
/
select p_test2.ff1(('a',3));
INFO:  (a,3)
CONTEXT:  referenced column: ff1
  ff1  
-------
 (a,3)
(1 row)

-- test package type used in another schema package
set search_path=plpgsql_packagetype2;
create or replace package p_test2 as
    var1 plpgsql_packagetype1.p_test1.t1;
    type t21 is record(c1 plpgsql_packagetype1.p_test1.t1);
    type t22 is table of plpgsql_packagetype1.p_test1.t1;
    function ff1(ss in plpgsql_packagetype1.p_test1.t1) return plpgsql_packagetype1.p_test1.t1;
    procedure pp1(aa in plpgsql_packagetype1.p_test1.t1,bb in plpgsql_packagetype1.p_test1.t2,cc out plpgsql_packagetype1.p_test1.t1,dd out plpgsql_packagetype1.p_test1.t2);
end p_test2;
/
create or replace package body p_test2 as
    function ff1(ss in plpgsql_packagetype1.p_test1.t1) return plpgsql_packagetype1.p_test1.t1 as
        va plpgsql_packagetype1.p_test1.t1;
	begin
        va := ss;
        raise info '%',va;
        return va;
	end;


	procedure pp1(aa in plpgsql_packagetype1.p_test1.t1,bb in plpgsql_packagetype1.p_test1.t2,cc out plpgsql_packagetype1.p_test1.t1,dd out plpgsql_packagetype1.p_test1.t2) as
	begin
        cc := aa;
        dd := bb;
        raise info '% %', cc,dd;
    end;
	
    procedure pp2(aa in int) as
	    aa plpgsql_packagetype1.p_test1.t1;
	    bb plpgsql_packagetype1.p_test1.t2;
	    cc plpgsql_packagetype1.p_test1.t1;
	    dd plpgsql_packagetype1.p_test1.t2;
	begin
	    aa := ('a',1);
		bb := array[('b',2),('c',3)];
		pp1(aa,bb,cc,dd);
	end;
		
end p_test2;
/
select p_test2.ff1(('a',3));
INFO:  (a,3)
CONTEXT:  referenced column: ff1
  ff1  
-------
 (a,3)
(1 row)

drop package p_test2;
NOTICE:  drop cascades to 3 other objects
--?.*
--?.*
drop cascades to function plpgsql_packagetype2.pp2(integer)
drop package plpgsql_packagetype1.p_test2;
NOTICE:  drop cascades to 3 other objects
--?.*
--?.*
drop cascades to function plpgsql_packagetype1.pp2(integer)
drop package plpgsql_packagetype1.p_test1;
NOTICE:  drop cascades to 4 other objects
--?.*
--?.*
--?.*
drop cascades to function plpgsql_packagetype1.p2(integer)
--test ref cursortype
create or replace package test_cur
IS
type ref_cur is ref cursor;
end test_cur;
/
create or replace package body test_cur
IS
a int;
end test_cur;
/
create or replace package test_cur2
IS
procedure proc1(cur1 test_cur.ref_cur);
end test_cur2;
/
create or replace package body test_cur2
IS
procedure proc1(cur1 test_cur.ref_cur)
is
BEGIN
cur1.a.a:=2;
end;
end test_cur2;
/
ERROR:  "cur1.a.a" is not a known variable
LINE 2: cur1.a.a:=2;
        ^
QUERY:   DECLARE BEGIN
cur1.a.a:=2;
end
create or replace package test_cur3
IS
procedure proc11(cur1 test_cur.ref_cur);
function func11() return test_cur.ref_cur;
end test_cur3;
/
create or replace package body test_cur3
IS
procedure proc11(cur1 test_cur.ref_cur)
is
BEGIN
cur1.a.a:=2;
end;
function func11() return test_cur.ref_cur
is
BEGIN
return 1;
end;
end test_cur3;
/
ERROR:  "cur1.a.a" is not a known variable
LINE 2: cur1.a.a:=2;
        ^
QUERY:   DECLARE BEGIN
cur1.a.a:=2;
end
create or replace package test_cur4
IS
procedure proc111(cur1 test_cur.ref_cur);
function func111 return test_cur.ref_cur;
end test_cur4;
/
create or replace package body test_cur4
IS
procedure proc111(cur1 test_cur.ref_cur)
is
BEGIN
cur1.a.a:=2;
cur.a.a:=2;
end;
function func111() return test_cur.ref_cur
is
BEGIN
return 1;
end;
end test_cur4;
/
ERROR:  "cur1.a.a" is not a known variable
LINE 2: cur1.a.a:=2;
        ^
QUERY:   DECLARE BEGIN
cur1.a.a:=2;
cur.a.a:=2;
end
drop package if exists test_cur;
NOTICE:  drop cascades to 5 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.proc1(refcursor)
drop cascades to function plpgsql_packagetype2.proc11(refcursor)
drop cascades to function plpgsql_packagetype2.func11()
drop cascades to function plpgsql_packagetype2.proc111(refcursor)
drop cascades to function plpgsql_packagetype2.func111()
drop package if exists test_cur2;
NOTICE:  package test_cur2() does not exist, skipping
drop package if exists test_cur3;
NOTICE:  package test_cur3() does not exist, skipping
drop package if exists test_cur4;
NOTICE:  package test_cur4() does not exist, skipping
create or replace package pck1 is
type t1 is table of varchar2(10);
procedure pp11 (t1 in varchar2(10));
procedure pp22 (t1 out varchar2(10));
end pck1;
/
create or replace package body pck1 is
procedure pp11 (t1 in varchar2(10)) is
begin
raise info '%', t1;
end;
procedure pp22 (t1 out varchar2(10)) is
begin
t1 := 'bb';
raise info '%', t1;
end;
end pck1;
/
call pck1.pp11('aa');
INFO:  aa
 pp11 
------
 
(1 row)

call pck1.pp22('cc');
INFO:  bb
 t1 
----
 bb
(1 row)

DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.pp11(character varying)
drop cascades to function plpgsql_packagetype2.pp22()
--test package, type with same name
create or replace package plpgsql_packagetype1.pck2 is
va int;
end pck2;
/
create type plpgsql_packagetype1.pck2 as (a int, b int);
DROP table if exists t1;
NOTICE:  table "t1" does not exist, skipping
CREATE table t1 (a plpgsql_packagetype1.pck2);
insert into t1 values((1,2));
select * from t1;
   a   
-------
 (1,2)
(1 row)

create or replace package pck3 is
va plpgsql_packagetype1.pck2;
end pck3;
/
DROP package pck3;
DROP package plpgsql_packagetype1.pck2;
DROP table t1;
DROP type plpgsql_packagetype1.pck2;
--test synonym name same with procedure itself
create procedure proc1 as
begin
null;
end;
/
create synonym proc1 for proc1;
ERROR:  synonym name is already used by an existing object
call proc1();
 proc1 
-------
 
(1 row)

DROP procedure proc1();
--test package type form record
create or replace package pck1 is
type t1 is record (a int, b int);
type ta is varray(10) of varchar2(100);
type tb is varray(10) of int;
type tc is varray(10) of t1;
type td is table of varchar2(100);
type te is table of int;
type tf is table of t1;
end pck1;
/
create or replace package pck2 is
type tb is record (col1 pck1.ta, col2 pck1.tb, col3 pck1.tc, col4 pck1.td, col5 pck1.te, col6 pck1.tf);
end pck2;
/
DROP PACKAGE pck2;
DROP PACKAGE pck1;
-- test not support nested type
-- 1. array nest array
create or replace package pck1 as
type t1 is varray(10) of int;
type t2 is varray(10) of t1;
end pck1;
/
ERROR:  array type nested by array is not supported yet.
DETAIL:  Define array type "t2" of array is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is varray(10) of int;
type t2 is varray(10) of t1;
begin
return 0;
end;
/
ERROR:  array type nested by array is not supported yet.
DETAIL:  Define array type "t2" of array is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
-- 2. table nest array
create or replace package pck1 as
type t1 is varray(10) of int;
type t2 is table of t1;
end pck1;
/
ERROR:  array type nested by table type is not supported yet.
DETAIL:  Define table type "t2" of array is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is varray(10) of int;
type t2 is table of t1;
begin
return 0;
end;
/
ERROR:  array type nested by table type is not supported yet.
DETAIL:  Define table type "t2" of array is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
-- 3. array nest table
create or replace package pck1 as
type t1 is table of int;
type t2 is varray(10) of t1;
end pck1;
/
ERROR:  table type nested by array is not supported yet.
DETAIL:  Define array type "t2" of table type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is table of int;
type t2 is varray(10) of t1;
begin
return 0;
end;
/
ERROR:  table type nested by array is not supported yet.
DETAIL:  Define array type "t2" of table type is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
-- 4. table nest table, will be supported soon
-- create or replace package pck1 as
-- type t1 is table of int;
-- type t2 is table of t1;
-- end pck1;
-- /
-- create or replace function func1() return int as
-- type t1 is table of int;
-- type t2 is table of t1;
-- begin
-- return 0;
-- end;
-- /
-- 5. record nest ref cursor
drop package if exists pck1;
NOTICE:  package pck1() does not exist, skipping
create or replace package pck1 as
type t1 is ref cursor;
type t2 is record(c1 t1,c2 int);
end pck1;
/
ERROR:  ref cursor type nested by record is not supported yet.
DETAIL:  Define a record type of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is ref cursor;
type t2 is record(c1 t1,c2 int);
begin
return 0;
end;
/
ERROR:  ref cursor type nested by record is not supported yet.
DETAIL:  Define a record type of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
-- 6. table nest ref cursor
create or replace package pck1 as
type t1 is ref cursor;
type t2 is table of t1;
end pck1;
/
ERROR:  ref cursor type nested by table type is not supported yet.
DETAIL:  Define table type "t2" of ref cursor is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is ref cursor;
type t2 is table of t1;
begin
return 0;
end;
/
ERROR:  ref cursor type nested by table type is not supported yet.
DETAIL:  Define table type "t2" of ref cursor is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
-- 7. varray nest ref cursor
create or replace package pck1 as
type t1 is ref cursor;
type t2 is varray(10) of t1;
end pck1;
/
ERROR:  ref cursor type nested by array is not supported yet.
DETAIL:  Define array type "t2" of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 3
create or replace function func1() return int as
type t1 is ref cursor;
type t2 is varray(10) of t1;
begin
return 0;
end;
/
ERROR:  ref cursor type nested by array is not supported yet.
DETAIL:  Define array type "t2" of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL function "func1" near line 2
DROP package pck1;
ERROR:  package pck1 does not exist
DROP function func1();
ERROR:  function func1 does not exist
-- 8.package nest
create or replace package pck1 as
type t1 is table of int;
type t2 is varray(10) of int;
type t3 is ref cursor;
end pck1;
/
create or replace package pck2 as
type t1 is varray(10) of pck1.t2;
v1 t1;
function func1() return int;
end pck2;
/
ERROR:  array or table type nested by array type is not supported yet.
DETAIL:  Define array type "t1" of array or table type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 2
-- 9.package nested
create or replace package pck2 as
type t1 is table of pck1.t1;
v1 t1;
function func1() return int;
end pck2;
/
ERROR:  array or table type nested by table type is not supported yet.
DETAIL:  Define table type "t1" of array or table type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 2
-- 10.package nested
create or replace package pck2 as
type t1 is table of pck1.t3;
v1 t1;
function func1() return int;
end pck2;
/
ERROR:  ref cursor type nested by table type is not supported yet.
DETAIL:  Define table type "t1" of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 2
-- 10.package nested
create or replace package pck2 as
type t1 is record(a pck1.t3);
v1 t1;
function func1() return int;
end pck2;
/
ERROR:  ref cursor type nested by record is not supported yet.
DETAIL:  Define record type of ref cursor type is not supported yet.
CONTEXT:  compilation of PL/pgSQL package near line 2
DROP package pck2;
ERROR:  package pck2 does not exist
DROP package pck1;
-- test type nested by private type
create or replace package pck1 as
type t1 is varray(10) of int;
type t2 is record (a int, b int);
end pck1;
/
create or replace package body pck1 as
type t3 is varray(10) of int;
type t4 is record (a t3, b int);
procedure p2 (a pck1.t2) is
type t5 is varray(10) of t4;
type t6 is varray(10) of t2;
begin
null;
end;
end pck1;
/
DROP PACKAGE pck1;
--?.*
-- test replace body, do not influence head 
create or replace package pck1 as
type t1 is varray(10) of int;
type t2 is record (a int, b int);
end pck1;
/
create or replace package pck2 as
procedure p1 (a pck1.t1);
end pck2;
/
create or replace package body pck2 as
procedure p1 (a pck1.t1) is
begin
null;
end;
end pck2;
/
create or replace package body pck1 as
procedure p1 (a int) is
begin
null;
end;
end pck1;
/
call pck2.p1(array[1,2,4]);
 p1 
----
 
(1 row)

DROP PACKAGE pck2;
NOTICE:  drop cascades to function plpgsql_packagetype2.p1(integer[])
DROP PACKAGE pck1;
NOTICE:  drop cascades to function plpgsql_packagetype2.p1(integer)
-- test package table of type
create or replace package pck1 is
type t1 is table of int index by varchar2(10);
end pck1;
/
create or replace package  pck2 is
va pck1.t1;
procedure p1;
end pck2;
/
create or replace package body pck2 is
procedure p1 is
begin
va('aaa') := 1;
va('a') := 2;
raise info '%', va;
end;
end pck2;
/
call pck2.p1();
INFO:  {1,2}
 p1 
----
 
(1 row)

DROP PACKAGE pck2;
NOTICE:  drop cascades to function plpgsql_packagetype2.p1()
DROP PACKAGE pck1;
-- test package record type as procedure in out param
-- (1) in param
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a in r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
va r1;
begin
va := (1,2);
p2(va);
va := (4,5);
p2(va);
end;
procedure p2 (a in r1) as
begin
raise info '%', a;
end;
end pck1;
/
call pck1.p1();
INFO:  (1,2)
CONTEXT:  SQL statement "CALL p2(va)"
PL/pgSQL function p1() line 4 at PERFORM
INFO:  (4,5)
CONTEXT:  SQL statement "CALL p2(va)"
PL/pgSQL function p1() line 6 at PERFORM
 p1 
----
 
(1 row)

DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
--?.*
-- (2) out param
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a out r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
va r1;
begin
raise info '%', va;
p2(va);
raise info '%', va;
end;
procedure p2 (a out r1) as
begin
a.a := 11;
a.b := 22;
end;
end pck1;
/
call pck1.p1();
INFO:  (,)
INFO:  (11,22)
 p1 
----
 
(1 row)

DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
drop cascades to function plpgsql_packagetype2.p2()
-- (3) inout param
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a inout r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
va r1;
begin
va := (11,22);
raise info '%', va;
p2(va);
raise info '%', va;
end;
procedure p2 (a inout r1) as
begin
a.a := a.a + 1;
a.b := a.b + 1;
end;
end pck1;
/
call pck1.p1();
INFO:  (11,22)
INFO:  (12,23)
 p1 
----
 
(1 row)

DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
--?.*
-- test more column number
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a out r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
type r2 is record (a int, b int, c int);
va r1;
vb r2;
begin
va := (1,2);
vb := (1,2,3);
raise info '%',va;
p2(vb);
raise info '%',va;
end;
procedure p2 (a out r1) as
begin
raise info '%', a;
a := (4,5);
end;
end pck1;
/
call pck1.p1();
INFO:  (1,2)
INFO:  (,)
CONTEXT:  SQL statement "CALL p2(vb)"
PL/pgSQL function p1() line 8 at SQL statement
ERROR:  mismatch between assignment and variable filed.
CONTEXT:  PL/pgSQL function p1() line 8 at SQL statement
DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
drop cascades to function plpgsql_packagetype2.p2()
-- test less column number
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a out r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
type r2 is record (a int);
va r1;
vb r2;
begin
va := (1,2);
vb.a := 1;
raise info '%',va;
p2(vb);
raise info '%',va;
end;
procedure p2 (a out r1) as
begin
raise info '%', a;
a := (4,5);
end;
end pck1;
/
call pck1.p1();
INFO:  (1,2)
INFO:  (,)
CONTEXT:  SQL statement "CALL p2(vb)"
PL/pgSQL function p1() line 8 at SQL statement
ERROR:  mismatch between assignment and variable filed.
CONTEXT:  PL/pgSQL function p1() line 8 at SQL statement
DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
drop cascades to function plpgsql_packagetype2.p2()
-- test wrong column type
create or replace package pck1 as
type r1 is record (a int, b int);
procedure p1;
procedure p2(a out r1);
end pck1;
/
create or replace package body pck1 as
procedure p1 as
type r2 is record (a int, b varchar2(10));
va r1;
vb r2;
begin
va := (1,2);
vb := (1,'aa');
raise info '%',va;
p2(vb);
raise info '%',va;
end;
procedure p2 (a out r1) as
begin
raise info '%', a;
a := (4,5);
end;
end pck1;
/
call pck1.p1();
INFO:  (1,2)
--?.*
CONTEXT:  SQL statement "CALL p2(vb)"
PL/pgSQL function p1() line 8 at SQL statement
INFO:  (1,2)
 p1 
----
 
(1 row)

DROP PACKAGE pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function plpgsql_packagetype2.p1()
drop cascades to function plpgsql_packagetype2.p2()
-- test package type alter
create or replace package pck1 is
type r1 is record (a int, b int);
type r2 is table of int index by varchar(10);
type r3 is varray(10) of int;
end pck1;
/
-- (1) grant or revoke
grant drop on type pck1.r1 to public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
grant alter on type pck1.r2 to public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
grant alter on type pck1.r3 to public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
revoke drop on type pck1.r1 from public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
revoke drop on type pck1.r2 from public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
revoke drop on type pck1.r3 from public;
ERROR:  Not allowed to GRANT/REVOKE type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
-- (2) drop
DROP TYPE pck1.r1 cascade;
ERROR:  Not allowed to drop type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
DROP TYPE pck1.r2 cascade;
ERROR:  Not allowed to drop type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
DROP TYPE pck1.r3 cascade;
ERROR:  Not allowed to drop type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
-- (3) alter: rename
ALTER TYPE pck1.r1 RENAME TO o1;
ERROR:  Not allowed to alter type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
ALTER TYPE pck1.r2 RENAME TO o1;
ERROR:  Not allowed to alter type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
ALTER TYPE pck1.r3 RENAME TO o1;
ERROR:  Not allowed to alter type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
-- (4) alter: owner
ALTER TYPE pck1.r1 OWNER TO CURRENT_USER;
ERROR:  Not allowed to alter type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
ALTER TYPE pck1.r2 OWNER TO CURRENT_USER;
ERROR:  Not allowed to alter type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
ALTER TYPE pck1.r3 OWNER TO CURRENT_USER;
ERROR:  Not allowed to alter type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
-- (5) alter: set schema
ALTER TYPE pck1.r1 SET SCHEMA public;
ERROR:  Not allowed to alter type "pck1.r1"
DETAIL:  "pck1.r1" is a package or procedure type
ALTER TYPE pck1.r2 SET SCHEMA public;
ERROR:  Not allowed to alter type "pck1.r2"
DETAIL:  "pck1.r2" is a package or procedure type
ALTER TYPE pck1.r3 SET SCHEMA public;
ERROR:  Not allowed to alter type "pck1.r3"
DETAIL:  "pck1.r3" is a package or procedure type
DROP PACKAGE pck1;
-- test package type as table of type column
create or replace package pck1 is
type r1 is record (a int, b int);
type r2 is table of int index by varchar(10);
type r3 is varray(10) of int;
end pck1;
/
-- (1) as table
create table t1(a pck1.r1);
ERROR:  type "pck1.r1" is not supported as column type
DETAIL:  "pck1.r1" is a package or procedure type
create table t1(a pck1.r2);
ERROR:  type "pck1.r2" is not supported as column type
DETAIL:  "pck1.r2" is a package or procedure type
create table t1(a pck1.r3);
ERROR:  type "pck1.r3" is not supported as column type
DETAIL:  "pck1.r3" is a package or procedure type
-- (2) as type
create type o1 as (a pck1.r1);
ERROR:  type "pck1.r1" is not supported as column type
DETAIL:  "pck1.r1" is a package or procedure type
create type o1 as (a pck1.r2);
ERROR:  type "pck1.r2" is not supported as column type
DETAIL:  "pck1.r2" is a package or procedure type
create type o1 as (a pck1.r3);
ERROR:  type "pck1.r3" is not supported as column type
DETAIL:  "pck1.r3" is a package or procedure type
-- (3) in procedure
create or replace procedure p1 as
begin
create table t1(a pck1.r1);
end;
/
call p1();
ERROR:  type "pck1.r1" is not supported as column type
DETAIL:  "pck1.r1" is a package or procedure type
CONTEXT:  SQL statement "create table t1(a pck1.r1)"
PL/pgSQL function p1() line 2 at SQL statement
create or replace procedure p1 as
begin
create table t1(a pck1.r2);
end;
/
call p1();
ERROR:  type "pck1.r2" is not supported as column type
DETAIL:  "pck1.r2" is a package or procedure type
CONTEXT:  SQL statement "create table t1(a pck1.r2)"
PL/pgSQL function p1() line 2 at SQL statement
create or replace procedure p1 as
begin
create table t1(a pck1.r3);
end;
/
call p1();
ERROR:  type "pck1.r3" is not supported as column type
DETAIL:  "pck1.r3" is a package or procedure type
CONTEXT:  SQL statement "create table t1(a pck1.r3)"
PL/pgSQL function p1() line 2 at SQL statement
create or replace procedure p1 as
begin
create type o1 as (a pck1.r1);
end;
/
call p1();
ERROR:  type "pck1.r1" is not supported as column type
DETAIL:  "pck1.r1" is a package or procedure type
CONTEXT:  SQL statement "create type o1 as (a pck1.r1)"
PL/pgSQL function p1() line 2 at SQL statement
create or replace procedure p1 as
begin
create type o1 as (a pck1.r2);
end;
/
call p1();
ERROR:  type "pck1.r2" is not supported as column type
DETAIL:  "pck1.r2" is a package or procedure type
CONTEXT:  SQL statement "create type o1 as (a pck1.r2)"
PL/pgSQL function p1() line 2 at SQL statement
create or replace procedure p1 as
begin
create type o1 as (a pck1.r3);
end;
/
call p1();
ERROR:  type "pck1.r3" is not supported as column type
DETAIL:  "pck1.r3" is a package or procedure type
CONTEXT:  SQL statement "create type o1 as (a pck1.r3)"
PL/pgSQL function p1() line 2 at SQL statement
DROP procedure p1;
DROP package pck1;
-- test package-depended type clean
create or replace package pck4 is
va int;
end pck4;
/
create or replace package body pck4 is
type test_pck4_recordtype is record (a int, b int);
type test_pck4_arraytype is varray(10) of int;
type test_pck4_tableoftype is table of int index by varchar2(10);
type test_pck4_refcursor is ref cursor;
end pck4;
/
select count(*) from pg_type where typname like '%.test_pck4%';
 count 
-------
     4
(1 row)

select count(*) from PG_SYNONYM where synname like '%.test_pck4%';
 count 
-------
     1
(1 row)

create or replace package body pck4 is
vb int;
end pck4;
/
select count(*) from pg_type where typname like '%.test_pck4%';
 count 
-------
     0
(1 row)

select count(*) from PG_SYNONYM where synname like '%.test_pck4%';
 count 
-------
     0
(1 row)

DROP PACKAGE pck4;
-- test table of record index by varchar
create or replace package pkg045
is
type type000 is record(c1 number(7,3),c2 varchar2(30));
type type001 is table of type000 index by varchar2(30);
function proc045_2(col1 int) return int;
end pkg045;
/
create or replace package body pkg045
is
function proc045_2(col1 int) return int
is
b2 pkg045.type001;
begin
b2('1').c1:=1.000;
b2('1').c2:='aaa';
raise info '%,%', b2('1').c1, b2('1').c2;
return 1;
end;
end pkg045;
/
call pkg045.proc045_2(1);
INFO:  1.000,aaa
 proc045_2 
-----------
         1
(1 row)

drop package pkg045;
NOTICE:  drop cascades to function plpgsql_packagetype2.proc045_2(integer)
-- test alter package/function owner
-- (a) alter package
reset search_path;
create user alt_user_1 PASSWORD 'gauss@123';
create user alt_user_2 PASSWORD 'gauss@123';
SET SESSION AUTHORIZATION alt_user_1 password 'gauss@123';
drop package if exists pck1;
NOTICE:  package pck1() does not exist, skipping
create or replace package pck1 as
type tt1 is record(c1 int,c2 int);
type tt2 is table of tt1;
type tt3 is varray(10) of tt1;
function func1()return int;
procedure proc1();
end pck1;
/
create or replace package body pck1 as
function func1()return int as
type tt5 is record(c1 tt1,c2 int);
type tt6 is table of pck1.tt1;
type tt7 is varray(10) of pck1.tt1;
type tt8 is ref cursor;
type tt9 is table of tt5;
begin
return 0;
end;
procedure proc1() as
type tta is record(c1 tt1,c2 int);
type ttb is table of pck1.tt1;
type ttc is varray(10) of pck1.tt1;
type ttd is ref cursor;
type tte is table of tta;
begin
null;
end;
end pck1;
/
reset session AUTHORIZATION;
alter package alt_user_1.pck1 owner to alt_user_2;
------usename user2
select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.tt1%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.tt2%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.tt3%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.tt5%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.tta%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

drop package alt_user_1.pck1;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function alt_user_1.func1()
drop cascades to function alt_user_1.proc1()
-- (b) alter function
SET SESSION AUTHORIZATION alt_user_1 password 'gauss@123';
create or replace function func1()return int as
type ttt5 is record(c1 int,c2 int);
type ttt6 is table of int;
type ttt7 is varray(10) of int;
type ttt8 is ref cursor;
type ttt9 is table of ttt5;
begin
return 0;
end;
/
reset session AUTHORIZATION;
alter function alt_user_1.func1() owner to alt_user_2;
select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.ttt5%' limit 1);
  usename   
------------
 alt_user_2
(1 row)

select usename from pg_user where usesysid = (select typowner from pg_type where typname like '%.ttt6%' limit 1);
 usename 
---------
(0 rows)

drop function alt_user_1.func1();
drop user alt_user_1 cascade;
drop user alt_user_2 cascade;
set search_path=plpgsql_packagetype1;
-- test record with table of to be nested
  -- a. nested table, should error
create or replace package pck1 as
type t1 is table of int index by int;
type t2 is table of t1;
type r1 is record (a t2, b int);
end pck1;
/
ERROR:  nested table of type is not supported as record type attribute
LINE 4: type r1 is record (a t2, b int);
                             ^
QUERY:   PACKAGE  DECLARE 
type t1 is table of int index by int;
type t2 is table of t1;
type r1 is record (a t2, b int);
end 
CONTEXT:  compilation of PL/pgSQL package near line 4
  -- b. table with index by, should error
create or replace package pck1 as
type t1 is table of int index by int;
type r1 is record (a t1, b int);
type r2 is record (a r1, b int);
end pck1;
/
ERROR:  record type with table of attribute is not suppoted to be nested.
LINE 4: type r2 is record (a r1, b int);
                             ^
DETAIL:  attribute "a" of record type "r1" is table of with index by, which is not supported to be nested.
QUERY:   PACKAGE  DECLARE 
type t1 is table of int index by int;
type r1 is record (a t1, b int);
type r2 is record (a r1, b int);
end 
CONTEXT:  compilation of PL/pgSQL package near line 4
  -- c. table without index by, should success
create or replace package pck1 as
type t1 is table of int;
type r1 is record (a t1, b int);
type r2 is record (a r1, b int);
end pck1;
/
  -- d. table with index by, should error
create or replace package pck1 as
type t1 is table of int index by int;
type r1 is record (a t1, b int);
type r2 is varray(10) of r1;
end pck1;
/
ERROR:  record type with table of attribute is not suppoted to be nested.
LINE 4: type r2 is varray(10) of r1;
                                 ^
DETAIL:  attribute "a" of record type "r1" is table of with index by, which is not supported to be nested.
QUERY:   PACKAGE  DECLARE 
type t1 is table of int index by int;
type r1 is record (a t1, b int);
type r2 is varray(10) of r1;
end 
CONTEXT:  compilation of PL/pgSQL package near line 4
drop package pck1;
-- test pck.r1 ref record with table of, should error
-- a, self ref
create or replace package pck1 as
type t1 is table of int index by int;
type r1 is record (a t1, b int);
va pck1.r1;
procedure p1;
end pck1;
/
create or replace package pck1 as
type t1 is table of int index by int;
type r1 is record (a t1, b int);
procedure p1;
end pck1;
/
create or replace package body pck1 as
procedure p1 as
vb pck1.r1;
begin
null;
end;
end pck1;
/
drop package pck1;
NOTICE:  drop cascades to function plpgsql_packagetype1.p1()
-- b, another ref
create or replace package pck1 as
type t1 is table of int index by int;
type r1 is record (a t1, b int);
end pck1;
/
create or replace procedure p1 as
va pck1.r1;
begin
null;
end;
/
drop package pck1;
drop procedure p1;
-- test pck1.va%type ref table of
-- a. var ref
create or replace package pck2 as
type t1 is table of int index by varchar2;
va t1;
end pck2;
/
create or replace procedure p1 as
type t1 is table of int index by varchar2;
va t1;
vb pck2.va%type;
begin
va('aa') := 1;
vb('bb') := 1;
end;
/
call p1();
 p1 
----
 
(1 row)

drop procedure p1;
drop package pck2;
-- b. procedure ref
create or replace package pck2 as
type t1 is table of int index by varchar2;
va t1;
procedure p1(vb pck2.va%type);
end pck2;
/
create or replace package pck2 as
type t1 is table of int index by varchar2;
va t1;
procedure p1(vb va%type);
end pck2;
/
ERROR:  not support ref table of variable as procedure argument type
CONTEXT:  compilation of PL/pgSQL package near line 3
-- test va.col%type ref table of
-- a. var ref
create or replace package pck1 as
type t1 is table of int index by varchar;
type r1 is record (a t1, b int);
va r1;
procedure p1;
end pck1;
/
create or replace package body pck1 as
procedure p1 as
vb va.a%type;
begin
vb('aa') := 1;
end;
end pck1;
/
call pck1.p1();
 p1 
----
 
(1 row)

drop package pck1;
NOTICE:  drop cascades to function plpgsql_packagetype1.p1()
-- b. procedure ref
create or replace package pck1 as
type t1 is table of int index by varchar;
type r1 is record (a t1, b int);
va r1;
procedure p1(vb va.a%type);
end pck1;
/
ERROR:  not support ref table of variable as procedure argument type
CONTEXT:  compilation of PL/pgSQL package near line 4
-- test record.col%type ref table of
create or replace package pck1 as
type t1 is table of int index by varchar;
type r1 is record (a t1, b int);
va pck1.r1.a%type;
procedure p1;
end pck1;
/
-- test pck1.record.col%type ref table of
-- test pck1.va.col%type ref table of
create or replace package pak1 as
type tp_varray is varray(1) of char%type;
varray1 tp_varray;
procedure p1;
end pak1 ;
/
--------------------------------------------------
------------------ END OF TESTS ------------------
--------------------------------------------------
drop package pak1;
NOTICE:  drop cascades to function plpgsql_packagetype1.p1()
drop package p_test2;
ERROR:  package p_test2 does not exist
drop package plpgsql_packagetype1.p_test2;
ERROR:  package plpgsql_packagetype1.p_test2 does not exist
drop package plpgsql_packagetype1.p_test1;
ERROR:  package plpgsql_packagetype1.p_test1 does not exist
-- clean up --
drop schema if exists plpgsql_packagetype2 cascade;
drop schema if exists plpgsql_packagetype1 cascade;
NOTICE:  drop cascades to 4 other objects
--?.*
drop cascades to function plpgsql_packagetype1.p1(integer[])
--?.*
drop cascades to function plpgsql_packagetype1.p1()
