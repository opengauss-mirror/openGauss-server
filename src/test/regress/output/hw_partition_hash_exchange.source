-- 0. function
--a.partition name
create table test_exchange_func_ord (a int);
create table test_exchange_func_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_func_ord values (1);
insert into test_exchange_func_ht values (2);
select * from test_exchange_func_ord;
 a 
---
 1
(1 row)

select * from test_exchange_func_ht;
 a 
---
 2
(1 row)

alter table test_exchange_func_ht exchange partition (p2) with table test_exchange_func_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ord;
 a 
---
 2
(1 row)

select * from test_exchange_func_ht;
 a 
---
 1
(1 row)

insert into test_exchange_func_ord values (4);
insert into test_exchange_func_ht values (3);
select * from test_exchange_func_ord order by 1;
 a 
---
 2
 4
(2 rows)

select * from test_exchange_func_ht order by 1;
 a 
---
 1
 3
(2 rows)

select * from test_exchange_func_ht partition(p1) order by 1;
 a 
---
 3
(1 row)

select * from test_exchange_func_ht partition(p2) order by 1;
 a 
---
 1
(1 row)

drop table test_exchange_func_ord;
drop table test_exchange_func_ht;
--b.partition for
create table test_exchange_func_ord (a int);
create table test_exchange_func_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_func_ord values (1);
insert into test_exchange_func_ht values (2);
select * from test_exchange_func_ord;
 a 
---
 1
(1 row)

select * from test_exchange_func_ht;
 a 
---
 2
(1 row)

select * from test_exchange_func_ht partition for (1);
 a 
---
 2
(1 row)

alter table test_exchange_func_ht exchange partition for (1) with table test_exchange_func_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition for (1);
 a 
---
 1
(1 row)

select * from test_exchange_func_ord;
 a 
---
 2
(1 row)

select * from test_exchange_func_ht;
 a 
---
 1
(1 row)

drop table test_exchange_func_ord;
drop table test_exchange_func_ht;
-- 1. table, partition not exist
--a.ordinary table does not exist
create table test_exchange_exist_ord (a int);
create table test_exchange_exist_ht (a int) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_exist_ht exchange partition (p1) with table test_exchange_exist;
ERROR:  relation "test_exchange_exist" does not exist
drop table test_exchange_exist_ord;
drop table test_exchange_exist_ht;
--b.partitioned table does not exist
create table test_exchange_exist_ord (a int);
create table test_exchange_exist_ht (a int) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_exist exchange partition (p1) with table test_exchange_exist_ord;
ERROR:  relation "test_exchange_exist" does not exist
drop table test_exchange_exist_ord;
drop table test_exchange_exist_ht;
--c.partition does not exist
create table test_exchange_exist_ord (a int);
create table test_exchange_exist_ht (a int) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_exist_ht exchange partition (p3) with table test_exchange_exist_ord;
ERROR:  Specified partition does not exist
drop table test_exchange_exist_ord;
drop table test_exchange_exist_ht;
-- 2. table type check
--a
create table test_exchange_table_type_ord (a int);
create table test_exchange_table_type_ht (a int);
--ERROR
alter table test_exchange_table_type_ht exchange partition (p1) with table test_exchange_table_type_ord;
ERROR:  can not exchange partition against NON-PARTITIONED table
drop table test_exchange_table_type_ord;
drop table test_exchange_table_type_ht;
--b
create table test_exchange_table_type_ord (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create table test_exchange_table_type_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_table_type_ht exchange partition (p1) with table test_exchange_table_type_ord;
ERROR:  ALTER TABLE EXCHANGE requires an ordinary table
drop table test_exchange_table_type_ord;
drop table test_exchange_table_type_ht;
--c
create table test_exchange_table_type_ord (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create table test_exchange_table_type_ht (a int);
--ERROR
alter table test_exchange_table_type_ht exchange partition (p1) with table test_exchange_table_type_ord;
ERROR:  can not exchange partition against NON-PARTITIONED table
drop table test_exchange_table_type_ord;
drop table test_exchange_table_type_ht;
-- 3. column(name, number, type)
--a.column name 列名字必须一致
create table test_exchange_column_name_ord (b int);
create table test_exchange_column_name_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_name_ht exchange partition (p1) with table test_exchange_column_name_ord;
ERROR:  column name mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_name_ord;
drop table test_exchange_column_name_ht;
--b.column number 列数量必须一致
create table test_exchange_column_number_ord (a int, b int);
create table test_exchange_column_number_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_number_ht exchange partition (p1) with table test_exchange_column_number_ord;
ERROR:  tables in ALTER TABLE EXCHANGE PARTITION must have the same number of columns
drop table test_exchange_column_number_ord;
drop table test_exchange_column_number_ht;
--c.column type: int and float
create table test_exchange_column_type_ord (a float);
create table test_exchange_column_type_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
--d.column type: int and char
create table test_exchange_column_type_ord (a char);
create table test_exchange_column_type_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
--e.column type: char(4) and char(8)
create table test_exchange_column_type_ord (a char(4));
create table test_exchange_column_type_ht (a char(8))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
--f.column type: char(8) and text
create table test_exchange_column_type_ord (a text);
create table test_exchange_column_type_ht (a char(8))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
--g.column type: int4 and int8
create table test_exchange_column_type_ord (a int4);
create table test_exchange_column_type_ht (a int8) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
--h.column type: float4 and float8
create table test_exchange_column_type_ord (a float4);
create table test_exchange_column_type_ht (a numeric(10,5))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_column_type_ht exchange partition (p1) with table test_exchange_column_type_ord;
ERROR:  column type or size mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_column_type_ord;
drop table test_exchange_column_type_ht;
 
-- 4. constraint check
--a.check
--a-1
create table test_exchange_constraint_ord (a int check (a>0));
create table test_exchange_constraint_ht (a int check (a>0))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--a-2
create table test_exchange_constraint_ord (a int check (a>0));
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--a-3
create table test_exchange_constraint_ord (a int check (a>0));
create table test_exchange_constraint_ht (a int check (a>1))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--a-4-1
create table test_exchange_constraint_ord (a int, check (a>0), check (a<3));
create table test_exchange_constraint_ht (a int, check (a<3), check (a>0))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--a-4-2
create table test_exchange_constraint_ord (a int, check (a>0), check (a<3));
create table test_exchange_constraint_ht (a int, check (a>0), check (a<2))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--b.not null
--b-1
create table test_exchange_constraint_ord (a int not null);
create table test_exchange_constraint_ht (a int not null)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--b-2
create table test_exchange_constraint_ord (a int not null);
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  column not null constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--c.unique
--c-1
create table test_exchange_constraint_ord (a int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_exchange_constraint_ord_a_key" for table "test_exchange_constraint_ord"
create table test_exchange_constraint_ht (a int unique)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_exchange_constraint_ht_a_key" for table "test_exchange_constraint_ht"
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--c-2
create table test_exchange_constraint_ord (a int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_exchange_constraint_ord_a_key" for table "test_exchange_constraint_ord"
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--d.primary key
--d-1
create table test_exchange_constraint_ord (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ord_pkey" for table "test_exchange_constraint_ord"
create table test_exchange_constraint_ht (a int primary key)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ht_pkey" for table "test_exchange_constraint_ht"
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--d-2
create table test_exchange_constraint_ord (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ord_pkey" for table "test_exchange_constraint_ord"
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  column not null constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--e.deferrable
--e-1
create table test_exchange_constraint_ref (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ref_pkey" for table "test_exchange_constraint_ref"
create table test_exchange_constraint_ord (a int, foreign key (a) references test_exchange_constraint_ref (a));
create table test_exchange_constraint_ht (a int, foreign key (a) references test_exchange_constraint_ref (a))
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
drop table test_exchange_constraint_ref;
--e-2
create table test_exchange_constraint_ref (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ref_pkey" for table "test_exchange_constraint_ref"
create table test_exchange_constraint_ord (a int, foreign key (a) references test_exchange_constraint_ref (a));
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
drop table test_exchange_constraint_ref;
--e-3
create table test_exchange_constraint_ref (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_exchange_constraint_ref_pkey" for table "test_exchange_constraint_ref"
create table test_exchange_constraint_ord (a int, foreign key (a) references test_exchange_constraint_ref (a));
create table test_exchange_constraint_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
--ERROR
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ref;
ERROR:  column not null constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
drop table test_exchange_constraint_ref;
--f.default
--f-1
create table test_exchange_constraint_ord (a int default 1);
create table test_exchange_constraint_ht (a int default 1)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
--f-2
create table test_exchange_constraint_ord (a int default 1);
create table test_exchange_constraint_ht (a int default 2)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
alter table test_exchange_constraint_ht exchange partition (p1) with table test_exchange_constraint_ord;
ERROR:  column default constraint mismatch in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_constraint_ord;
drop table test_exchange_constraint_ht;
/*
-- 5. distribute check  集中式不支持分布
--a.distribute is same
create table test_exchange_distirbute_ord (a int) distribute by hash (a);
create table test_exchange_distirbute_ht (a int) distribute by hash (a) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);

insert into test_exchange_distirbute_ord values(1);
insert into test_exchange_distirbute_ht values(2);

alter table test_exchange_distirbute_ht exchange partition (p1) with table test_exchange_distirbute_ord;

drop table test_exchange_distirbute_ord;
drop table test_exchange_distirbute_ht;


--b.distribute is different
create table test_exchange_distirbute_ord (a int, b int) distribute by hash (b);
create table test_exchange_distirbute_ht (a int, b int) distribute by hash (a) 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);

insert into test_exchange_distirbute_ord values(1, 1);
insert into test_exchange_distirbute_ht values(2, 2);

--ERROR
alter table test_exchange_distirbute_ht exchange partition (p1) with table test_exchange_distirbute_ord;

drop table test_exchange_distirbute_ord;
drop table test_exchange_distirbute_ht;


--c
create table test_exchange_distirbute_ord (a int) distribute by replication;
create table test_exchange_distirbute_ht (a int) distribute by roundrobin 
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);

insert into test_exchange_distirbute_ord values(1);
insert into test_exchange_distirbute_ht values(2);

--ERROR
alter table test_exchange_distirbute_ht exchange partition (p1) with table test_exchange_distirbute_ord;

drop table test_exchange_distirbute_ord;
drop table test_exchange_distirbute_ht;
*/
-- 6. index check
--a.index number
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_a on test_exchange_index_ord (a);
create index test_exchange_index_ord_b on test_exchange_index_ord (b);
create index test_exchange_index_ht_a on test_exchange_index_ht (a) local;
--ERROR
alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
ERROR:  tables in ALTER TABLE EXCHANGE PARTITION must have the same number of indexs
drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
--b-1.index column
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_b on test_exchange_index_ord (b);
create index test_exchange_index_ht_a on test_exchange_index_ht (a) local;
--ERROR
alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
ERROR:  index mismatch for tables in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
--b-2.index column
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_a_b on test_exchange_index_ord (a, b);
create index test_exchange_index_ht_a_c on test_exchange_index_ht (a, c) local;
--ERROR
alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
ERROR:  index mismatch for tables in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
--c.index type
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create unique index test_exchange_index_ord_a on test_exchange_index_ord (a);
create index test_exchange_index_ht_a on test_exchange_index_ht (a) local;
--ERROR
alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
ERROR:  index mismatch for tables in ALTER TABLE EXCHANGE PARTITION
drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
--d.index on the same column, but name not same
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_a_1 on test_exchange_index_ord (a);
create index test_exchange_index_ord_b on test_exchange_index_ord (b);
create index test_exchange_index_ord_a_2 on test_exchange_index_ord (a);
create index test_exchange_index_ht_b on test_exchange_index_ht (b) local;
create index test_exchange_index_ht_a_1 on test_exchange_index_ht (a) local;
create index test_exchange_index_ht_a_2 on test_exchange_index_ht (a) local;
alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
-- 7. validation check
--a.default validation
create table test_exchange_validation_ord (a int);
create table test_exchange_validation_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_validation_ord values (1), (10);
--ERROR
alter table test_exchange_validation_ht exchange partition (p1) with table test_exchange_validation_ord;
ERROR:  some rows in table do not qualify for specified partition
drop table test_exchange_validation_ord;
drop table test_exchange_validation_ht;
--b.with validation
create table test_exchange_validation_ord (a int);
create table test_exchange_validation_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_validation_ord values (1), (10);
--ERROR
alter table test_exchange_validation_ht exchange partition (p1) with table test_exchange_validation_ord with validation;
ERROR:  some rows in table do not qualify for specified partition
drop table test_exchange_validation_ord;
drop table test_exchange_validation_ht;
--c.without validation
create table test_exchange_validation_ord (a int);
create table test_exchange_validation_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_validation_ord values (1), (10);
--SUCCESS
alter table test_exchange_validation_ht exchange partition (p1) with table test_exchange_validation_ord without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
drop table test_exchange_validation_ord;
drop table test_exchange_validation_ht;
/*
-- 8. table relfilenode
create table test_exchange_table_relfilenode_ord (a int);
create table test_exchange_table_relfilenode_ht (a int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);

insert into test_exchange_table_relfilenode_ord values (3);
insert into test_exchange_table_relfilenode_ht values (2);

select relname, relfilenode from pg_class where relname = 'test_exchange_table_relfilenode_ord';
select relname, relfilenode from pg_partition where relname = 'p1';

alter table test_exchange_table_relfilenode_ht exchange partition (p1) with table test_exchange_table_relfilenode_ord;

select relname, relfilenode from pg_class where relname = 'test_exchange_table_relfilenode_ord';
select relname, relfilenode from pg_partition where relname = 'p1';

drop table test_exchange_table_relfilenode_ord;
drop table test_exchange_table_relfilenode_ht;



-- 9. toast table relfilenode
create table test_exchange_table_toast_ord (a text);
create table test_exchange_table_toast_ht (a text)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);

insert into test_exchange_table_toast_ord values ('A');
insert into test_exchange_table_toast_ht values ('C');

select c1.relname, c1.oid, c1.relfilenode, c1.reltoastrelid, c2.relname, c2.relfilenode from pg_class c1, pg_class c2 where c1.relname = 'test_exchange_table_toast_ord' and c1.reltoastrelid=c2.oid;
select p.relname, p.oid, p.relfilenode, p.reltoastrelid, c.relname, c.relfilenode from pg_class c, pg_partition p where p.relname = 'p2' and p.reltoastrelid=c.oid;

alter table test_exchange_table_toast_ht exchange partition (p2) with table test_exchange_table_toast_ord;

select c1.relname, c1.oid, c1.relfilenode, c1.reltoastrelid, c2.relname, c2.relfilenode from pg_class c1, pg_class c2 where c1.relname = 'test_exchange_table_toast_ord' and c1.reltoastrelid=c2.oid;
select p.relname, p.oid, p.relfilenode, p.reltoastrelid, c.relname, c.relfilenode from pg_class c, pg_partition p where p.relname = 'p2' and p.reltoastrelid=c.oid;

insert into test_exchange_table_toast_ord values ('B');
insert into test_exchange_table_toast_ht values ('A');

select * from test_exchange_table_toast_ord order by 1;
select * from test_exchange_table_toast_ht order by 1;

drop table test_exchange_table_toast_ord;
drop table test_exchange_table_toast_ht;



-- 10. index relfilenode
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_a on test_exchange_index_ord(a);
create index test_exchange_index_ord_a_c on test_exchange_index_ord(a, c);
create index test_exchange_index_ht_a on test_exchange_index_ht(a) local (partition p1_index_a, partition p2_index_a);
create index test_exchange_index_ht_a_c on test_exchange_index_ht(a, c) local (partition p1_index_a_c, partition p2_index_a_c);

select relname, relfilenode from pg_class where relname='test_exchange_index_ord_a';
select relname, relfilenode from pg_partition where relname='p2_index_a';
select relname, relfilenode from pg_class where relname='test_exchange_index_ord_a_c';
select relname, relfilenode from pg_partition where relname='p2_index_a_c';

alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;

select relname, relfilenode from pg_class where relname='test_exchange_index_ord_a';
select relname, relfilenode from pg_partition where relname='p2_index_a';
select relname, relfilenode from pg_class where relname='test_exchange_index_ord_a_c';
select relname, relfilenode from pg_partition where relname='p2_index_a_c';

drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
*/
-- 11. index is available after exchange
create table test_exchange_index_ord (a int, b int, c int);
create table test_exchange_index_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
create index test_exchange_index_ord_a on test_exchange_index_ord(a);
create index test_exchange_index_ht_a on test_exchange_index_ht(a) local;
insert into test_exchange_index_ord select generate_series(3,4);
insert into test_exchange_index_ht select generate_series(1,7);
select a from test_exchange_index_ht partition (p1);
 a 
---
 3
 4
 7
(3 rows)

select a from test_exchange_index_ht partition (p2);
 a 
---
 1
 2
 5
 6
(4 rows)

set enable_seqscan = off;
explain(verbose on, costs off) select a from test_exchange_index_ord where a=1;
                      QUERY PLAN                      
------------------------------------------------------
 Bitmap Heap Scan on public.test_exchange_index_ord
   Output: a
   Recheck Cond: (test_exchange_index_ord.a = 1)
   ->  Bitmap Index Scan on test_exchange_index_ord_a
         Index Cond: (test_exchange_index_ord.a = 1)
(5 rows)

select a from test_exchange_index_ord where a=1;
 a 
---
(0 rows)

explain(verbose on, costs off) select a from test_exchange_index_ht where a=1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Partitioned Bitmap Heap Scan on public.test_exchange_index_ht
   Output: a
   Recheck Cond: (test_exchange_index_ht.a = 1)
   Selected Partitions:  2
   ->  Partitioned Bitmap Index Scan on test_exchange_index_ht_a
         Index Cond: (test_exchange_index_ht.a = 1)
         Selected Partitions:  2
(7 rows)

select a from test_exchange_index_ht where a=1;
 a 
---
 1
(1 row)

alter table test_exchange_index_ht exchange partition (p1) with table test_exchange_index_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select a from test_exchange_index_ht partition (p1);
 a 
---
 3
 4
(2 rows)

select a from test_exchange_index_ht partition (p2);
 a 
---
 1
 2
 5
 6
(4 rows)

explain(verbose on, costs off) select a from test_exchange_index_ord where a=3;
                      QUERY PLAN                      
------------------------------------------------------
 Bitmap Heap Scan on public.test_exchange_index_ord
   Output: a
   Recheck Cond: (test_exchange_index_ord.a = 3)
   ->  Bitmap Index Scan on test_exchange_index_ord_a
         Index Cond: (test_exchange_index_ord.a = 3)
(5 rows)

select a from test_exchange_index_ord where a=3;
 a 
---
 3
(1 row)

explain(verbose on, costs off) select a from test_exchange_index_ht where a=3;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Partitioned Bitmap Heap Scan on public.test_exchange_index_ht
   Output: a
   Recheck Cond: (test_exchange_index_ht.a = 3)
   Selected Partitions:  1
   ->  Partitioned Bitmap Index Scan on test_exchange_index_ht_a
         Index Cond: (test_exchange_index_ht.a = 3)
         Selected Partitions:  1
(7 rows)

select a from test_exchange_index_ht where a=3;
 a 
---
 3
(1 row)

drop table test_exchange_index_ord;
drop table test_exchange_index_ht;
-- 12. tablespace
\! rm -fr '@testtablespace@/partition_exchange_ts1'
\! mkdir '@testtablespace@/partition_exchange_ts1'
\! rm -fr '@testtablespace@/partition_exchange_ts2'
\! mkdir '@testtablespace@/partition_exchange_ts2'
create tablespace partition_exchange_ts1 location '@testtablespace@/partition_exchange_ts1';
create tablespace partition_exchange_ts2 location '@testtablespace@/partition_exchange_ts2';
--a. table tablespace
create table test_exchange_tablespace_ord (a int) tablespace partition_exchange_ts1;
create table test_exchange_tablespace_ht (a int)
partition by hash(a)
(
	PARTITION p1 tablespace partition_exchange_ts2
);
insert into test_exchange_tablespace_ord values (1);
insert into test_exchange_tablespace_ht values (2);
select * from test_exchange_tablespace_ord;
 a 
---
 1
(1 row)

select * from test_exchange_tablespace_ht;
 a 
---
 2
(1 row)

--look tablespace
select c.relname, t.spcname from pg_class c, pg_tablespace t where c.reltablespace=t.oid and c.relname='test_exchange_tablespace_ord';
           relname            |        spcname         
------------------------------+------------------------
 test_exchange_tablespace_ord | partition_exchange_ts1
(1 row)

with partitioned_objs_oids as
(
	select oid from pg_class where relname = 'test_exchange_tablespace_ht'
)
select p.relname, t.spcname from pg_partition p, pg_tablespace t where p.reltablespace=t.oid and p.relname='p1'
 and p.parentid in (select oid from partitioned_objs_oids);
 relname |        spcname         
---------+------------------------
 p1      | partition_exchange_ts2
(1 row)

alter table test_exchange_tablespace_ht exchange partition (p1) with table test_exchange_tablespace_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
--check tablespace has exchanged
select c.relname, t.spcname from pg_class c, pg_tablespace t where c.reltablespace=t.oid and c.relname='test_exchange_tablespace_ord';
           relname            |        spcname         
------------------------------+------------------------
 test_exchange_tablespace_ord | partition_exchange_ts2
(1 row)

with partitioned_objs_oids as
(
	select oid from pg_class where relname = 'test_exchange_tablespace_ht'
)
select p.relname, t.spcname from pg_partition p, pg_tablespace t where p.reltablespace=t.oid and p.relname='p1'
 and p.parentid in (select oid from partitioned_objs_oids);
 relname |        spcname         
---------+------------------------
 p1      | partition_exchange_ts1
(1 row)

insert into test_exchange_tablespace_ord values (4);
insert into test_exchange_tablespace_ht values (2);
select * from test_exchange_tablespace_ord order by 1;
 a 
---
 2
 4
(2 rows)

select * from test_exchange_tablespace_ht order by 1;
 a 
---
 1
 2
(2 rows)

drop table test_exchange_tablespace_ord;
drop table test_exchange_tablespace_ht;
--a. index tablespace
create table test_exchange_tablespace_ord (a int);
create table test_exchange_tablespace_ht (a int)
partition by hash(a)
(
	PARTITION p1 tablespace partition_exchange_ts2
);
create index test_exchange_tablespace_ord_a on test_exchange_tablespace_ord (a) tablespace partition_exchange_ts1;
create index test_exchange_tablespace_ht_a on test_exchange_tablespace_ht (a) local (partition p1_index_a tablespace partition_exchange_ts2);
--look tablespace
select c.relname, t.spcname from pg_class c, pg_tablespace t where c.reltablespace=t.oid and c.relname='test_exchange_tablespace_ord_a';
            relname             |        spcname         
--------------------------------+------------------------
 test_exchange_tablespace_ord_a | partition_exchange_ts1
(1 row)

select p.relname, t.spcname from pg_partition p, pg_tablespace t where p.reltablespace=t.oid and p.relname='p1_index_a';
  relname   |        spcname         
------------+------------------------
 p1_index_a | partition_exchange_ts2
(1 row)

alter table test_exchange_tablespace_ht exchange partition (p1) with table test_exchange_tablespace_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
--check tablespace has exchanged
select c.relname, t.spcname from pg_class c, pg_tablespace t where c.reltablespace=t.oid and c.relname='test_exchange_tablespace_ord_a';
            relname             |        spcname         
--------------------------------+------------------------
 test_exchange_tablespace_ord_a | partition_exchange_ts2
(1 row)

select p.relname, t.spcname from pg_partition p, pg_tablespace t where p.reltablespace=t.oid and p.relname='p1_index_a';
  relname   |        spcname         
------------+------------------------
 p1_index_a | partition_exchange_ts1
(1 row)

drop table test_exchange_tablespace_ord;
drop table test_exchange_tablespace_ht;
drop tablespace partition_exchange_ts1;
drop tablespace partition_exchange_ts2;
\! rm -fr '@testtablespace@/partition_exchange_ts1'
\! rm -fr '@testtablespace@/partition_exchange_ts2'
-- 13. verbose
-- a.syntax
create table test_exchange_verbose_ord (a int);
create table test_exchange_verbose_ht (a int)
partition by hash(a)
(
	PARTITION test_exchange_verbose_ht_p1,
	PARTITION test_exchange_verbose_ht_p2,
	PARTITION test_exchange_verbose_ht_p3
);
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord with validation verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
--ERROR
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord without validation verbose;
ERROR:  syntax error at or near "verbose"
LINE 1: ... table test_exchange_verbose_ord without validation verbose;
                                                               ^
alter table test_exchange_verbose_ht exchange partition for (5) with table test_exchange_verbose_ord verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
alter table test_exchange_verbose_ht exchange partition for (5) with table test_exchange_verbose_ord with validation verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
--ERROR
alter table test_exchange_verbose_ht exchange partition for (5) with table test_exchange_verbose_ord without validation verbose;
ERROR:  syntax error at or near "verbose"
LINE 1: ... table test_exchange_verbose_ord without validation verbose;
                                                               ^
drop table test_exchange_verbose_ord;
drop table test_exchange_verbose_ht;
-- b.function
create table test_exchange_verbose_ord (a int);
create table test_exchange_verbose_ht (a int)
partition by hash(a)
(
	PARTITION test_exchange_verbose_ht_p1,
	PARTITION test_exchange_verbose_ht_p2,
	PARTITION test_exchange_verbose_ht_p3
);
insert into test_exchange_verbose_ord values(generate_series(1, 6));
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_verbose_ord order by 1;
 a 
---
(0 rows)

select * from test_exchange_verbose_ht order by 1;
 a 
---
 1
 2
 3
 4
 5
 6
(6 rows)

select * from test_exchange_verbose_ht partition (test_exchange_verbose_ht_p1) order by 1;
 a 
---
 1
 4
(2 rows)

select * from test_exchange_verbose_ht partition (test_exchange_verbose_ht_p2) order by 1;
 a 
---
 2
 6
(2 rows)

select * from test_exchange_verbose_ht partition (test_exchange_verbose_ht_p3) order by 1;
 a 
---
 3
 5
(2 rows)

drop table test_exchange_verbose_ord;
drop table test_exchange_verbose_ht;
-- c.index
create table test_exchange_verbose_ord (a int, b int);
create table test_exchange_verbose_ht (a int, b int)
partition by hash(b)
(
	PARTITION test_exchange_verbose_ht_p1,
	PARTITION test_exchange_verbose_ht_p2,
	PARTITION test_exchange_verbose_ht_p3
);
create index test_exchange_verbose_ord_index on test_exchange_verbose_ord (b);
create index test_exchange_verbose_ht_index on test_exchange_verbose_ht (b) local;
insert into test_exchange_verbose_ord values (-1, generate_series(1, 6));
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
set enable_seqscan=off;
explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=5;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 5)
   Selected Partitions:  3
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 5)
         Selected Partitions:  3
(6 rows)

select b from test_exchange_verbose_ht where b=5 order by 1;
 b 
---
 5
(1 row)

truncate test_exchange_verbose_ord;
truncate test_exchange_verbose_ht;
insert into test_exchange_verbose_ord values (-1, generate_series(1, 6));
update test_exchange_verbose_ord set b=1 where b=5;
update test_exchange_verbose_ord set b=2 where b=6;
update test_exchange_verbose_ord set b=1 where b=3;
update test_exchange_verbose_ord set b=3 where b=4;
delete from test_exchange_verbose_ord where b=2;
delete from test_exchange_verbose_ord where b=3;
alter table test_exchange_verbose_ht exchange partition (test_exchange_verbose_ht_p1) with table test_exchange_verbose_ord verbose;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 1)
   Selected Partitions:  1
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 1)
         Selected Partitions:  1
(6 rows)

select b from test_exchange_verbose_ht where b=1 order by 1;
 b 
---
 1
 1
 1
(3 rows)

explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=2;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 2)
   Selected Partitions:  2
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 2)
         Selected Partitions:  2
(6 rows)

select b from test_exchange_verbose_ht where b=2 order by 1;
 b 
---
(0 rows)

explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=5;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 5)
   Selected Partitions:  3
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 5)
         Selected Partitions:  3
(6 rows)

select b from test_exchange_verbose_ht where b=5 order by 1;
 b 
---
(0 rows)

explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=6;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 6)
   Selected Partitions:  2
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 6)
         Selected Partitions:  2
(6 rows)

select b from test_exchange_verbose_ht where b=6 order by 1;
 b 
---
(0 rows)

explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 3)
   Selected Partitions:  3
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 3)
         Selected Partitions:  3
(6 rows)

select b from test_exchange_verbose_ht where b=3 order by 1;
 b 
---
(0 rows)

explain(ANALYZE false,VERBOSE false, COSTS false,BUFFERS false,TIMING false) select b from test_exchange_verbose_ht where b=4;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Partitioned Bitmap Heap Scan on test_exchange_verbose_ht
   Recheck Cond: (b = 4)
   Selected Partitions:  1
   ->  Partitioned Bitmap Index Scan on test_exchange_verbose_ht_index
         Index Cond: (b = 4)
         Selected Partitions:  1
(6 rows)

select b from test_exchange_verbose_ht where b=4 order by 1;
 b 
---
(0 rows)

drop table test_exchange_verbose_ord;
drop table test_exchange_verbose_ht;
-- 14. global index
--drop table and index
drop table if exists exchange_table;
NOTICE:  table "exchange_table" does not exist, skipping
drop table if exists alter_table;
NOTICE:  table "alter_table" does not exist, skipping
create table alter_table
(
    INV_DATE_SK               integer               not null,
    INV_ITEM_SK               integer               not null,
    INV_WAREHOUSE_SK          integer               not null,
    INV_QUANTITY_ON_HAND      integer
)
partition by hash(inv_date_sk)
(
    partition p0,
    partition p1,
    partition p2
);
--succeed
insert into alter_table values (generate_series(1000,5000,1000),generate_series(1000,5000,1000),generate_series(1000,5000,1000));
insert into alter_table values (generate_series(10000,18000,2000),generate_series(10000,18000,2000),generate_series(10000,18000,2000));
insert into alter_table values (generate_series(20000,28000,2000),generate_series(20000,28000,2000),generate_series(20000,28000,2000));
--succeed 
create index local_alter_table_index1 on alter_table(INV_DATE_SK) local;
create index global_alter_table_index1 on alter_table(INV_ITEM_SK) global;
create index global_alter_table_index2 on alter_table(INV_WAREHOUSE_SK) global;
explain (costs off) select count(*) from alter_table where INV_DATE_SK < 10000;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on alter_table
               Recheck Cond: (inv_date_sk < 10000)
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on local_alter_table_index1
                     Index Cond: (inv_date_sk < 10000)
                     Selected Partitions:  1..3
(9 rows)

select count(*) from alter_table where INV_DATE_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_DATE_SK < 20000;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on alter_table
               Recheck Cond: (inv_date_sk < 20000)
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on local_alter_table_index1
                     Index Cond: (inv_date_sk < 20000)
                     Selected Partitions:  1..3
(9 rows)

select count(*) from alter_table where INV_DATE_SK < 20000;
 count 
-------
    10
(1 row)

explain (costs off) select count(*) from alter_table where INV_ITEM_SK < 10000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_item_sk < 10000)
         ->  Bitmap Index Scan on global_alter_table_index1
               Index Cond: (inv_item_sk < 10000)
(5 rows)

select count(*) from alter_table where INV_ITEM_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_ITEM_SK < 10000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_item_sk < 10000)
         ->  Bitmap Index Scan on global_alter_table_index1
               Index Cond: (inv_item_sk < 10000)
(5 rows)

select count(*) from alter_table where INV_ITEM_SK < 20000;
 count 
-------
    10
(1 row)

explain (costs off) select count(*) from alter_table where INV_WAREHOUSE_SK < 10000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_warehouse_sk < 10000)
         ->  Bitmap Index Scan on global_alter_table_index2
               Index Cond: (inv_warehouse_sk < 10000)
(5 rows)

select count(*) from alter_table where INV_WAREHOUSE_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_WAREHOUSE_SK < 20000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_warehouse_sk < 20000)
         ->  Bitmap Index Scan on global_alter_table_index2
               Index Cond: (inv_warehouse_sk < 20000)
(5 rows)

select count(*) from alter_table where INV_WAREHOUSE_SK < 20000;
 count 
-------
    10
(1 row)

select part.relname, part.indextblid, part.parttype, part.rangenum, part.intervalnum, part.partstrategy, part.relallvisible,
    part.reltoastrelid, part.partkey, part.interval, part.boundaries, part.reltuples
from pg_class class, pg_partition part, pg_index ind where class.relname = 'alter_table' and ind.indrelid = class.oid and part.parentid = ind.indrelid
order by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11;
   relname   | indextblid | parttype | rangenum | intervalnum | partstrategy | relallvisible | reltoastrelid | partkey | interval | boundaries | reltuples 
-------------+------------+----------+----------+-------------+--------------+---------------+---------------+---------+----------+------------+-----------
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
(12 rows)

create table exchange_table
(
    INV_DATE_SK               integer               not null,
    INV_ITEM_SK               integer               not null,
    INV_WAREHOUSE_SK          integer               not null,
    INV_QUANTITY_ON_HAND      integer
);
--succeed
select * from alter_table partition (p0);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        3000 |        3000 |             3000 |                     
        4000 |        4000 |             4000 |                     
       10000 |       10000 |            10000 |                     
       24000 |       24000 |            24000 |                     
       28000 |       28000 |            28000 |                     
(5 rows)

select * from alter_table partition (p1);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        1000 |        1000 |             1000 |                     
        2000 |        2000 |             2000 |                     
        5000 |        5000 |             5000 |                     
       12000 |       12000 |            12000 |                     
       14000 |       14000 |            14000 |                     
       16000 |       16000 |            16000 |                     
       18000 |       18000 |            18000 |                     
       22000 |       22000 |            22000 |                     
(8 rows)

select * from alter_table partition (p2);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
       20000 |       20000 |            20000 |                     
       26000 |       26000 |            26000 |                     
(2 rows)

insert into exchange_table values (3000,3000,3000);
insert into exchange_table values (4000,4000,4000);
select * from exchange_table;
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        3000 |        3000 |             3000 |                     
        4000 |        4000 |             4000 |                     
(2 rows)

--succeed 
create index local_exchange_table_index1 on exchange_table(INV_DATE_SK);
select part.relname, part.indextblid, part.parttype, part.rangenum, part.intervalnum, part.partstrategy, part.relallvisible,
    part.reltoastrelid, part.partkey, part.interval, part.boundaries, part.reltuples
from pg_class class, pg_partition part, pg_index ind where class.relname = 'alter_table' and ind.indrelid = class.oid and part.parentid = ind.indrelid
order by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11;
   relname   | indextblid | parttype | rangenum | intervalnum | partstrategy | relallvisible | reltoastrelid | partkey | interval | boundaries | reltuples 
-------------+------------+----------+----------+-------------+--------------+---------------+---------------+---------+----------+------------+-----------
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         5
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
(12 rows)

ALTER TABLE alter_table EXCHANGE PARTITION (p0) WITH TABLE exchange_table update global index;
select part.relname, part.indextblid, part.parttype, part.rangenum, part.intervalnum, part.partstrategy, part.relallvisible,
    part.reltoastrelid, part.partkey, part.interval, part.boundaries, part.reltuples
from pg_class class, pg_partition part, pg_index ind where class.relname = 'alter_table' and ind.indrelid = class.oid and part.parentid = ind.indrelid
order by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11;
   relname   | indextblid | parttype | rangenum | intervalnum | partstrategy | relallvisible | reltoastrelid | partkey | interval | boundaries | reltuples 
-------------+------------+----------+----------+-------------+--------------+---------------+---------------+---------+----------+------------+-----------
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 alter_table |          0 | r        |        0 |           0 | h            |             0 |             0 | 1       |          |            |         0
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         2
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         2
 p0          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {0}        |         2
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p1          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {1}        |         8
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
 p2          |          0 | p        |        0 |           0 | h            |             0 |             0 |         |          | {2}        |         2
(12 rows)

select * from alter_table partition (p0);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        3000 |        3000 |             3000 |                     
        4000 |        4000 |             4000 |                     
(2 rows)

select * from alter_table partition (p1);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        1000 |        1000 |             1000 |                     
        2000 |        2000 |             2000 |                     
        5000 |        5000 |             5000 |                     
       12000 |       12000 |            12000 |                     
       14000 |       14000 |            14000 |                     
       16000 |       16000 |            16000 |                     
       18000 |       18000 |            18000 |                     
       22000 |       22000 |            22000 |                     
(8 rows)

select * from alter_table partition (p2);
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
       20000 |       20000 |            20000 |                     
       26000 |       26000 |            26000 |                     
(2 rows)

select * from exchange_table;
 inv_date_sk | inv_item_sk | inv_warehouse_sk | inv_quantity_on_hand 
-------------+-------------+------------------+----------------------
        3000 |        3000 |             3000 |                     
        4000 |        4000 |             4000 |                     
       10000 |       10000 |            10000 |                     
       24000 |       24000 |            24000 |                     
       28000 |       28000 |            28000 |                     
(5 rows)

explain (costs off) select count(*) from alter_table where INV_DATE_SK < 10000;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on alter_table
               Recheck Cond: (inv_date_sk < 10000)
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on local_alter_table_index1
                     Index Cond: (inv_date_sk < 10000)
                     Selected Partitions:  1..3
(9 rows)

select count(*) from alter_table where INV_DATE_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_DATE_SK < 20000;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Partition Iterator
         Iterations: 3
         ->  Partitioned Bitmap Heap Scan on alter_table
               Recheck Cond: (inv_date_sk < 20000)
               Selected Partitions:  1..3
               ->  Partitioned Bitmap Index Scan on local_alter_table_index1
                     Index Cond: (inv_date_sk < 20000)
                     Selected Partitions:  1..3
(9 rows)

select count(*) from alter_table where INV_DATE_SK < 20000;
 count 
-------
     9
(1 row)

explain (costs off) select count(*) from alter_table where INV_ITEM_SK < 10000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_item_sk < 10000)
         ->  Bitmap Index Scan on global_alter_table_index1
               Index Cond: (inv_item_sk < 10000)
(5 rows)

select count(*) from alter_table where INV_ITEM_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_ITEM_SK < 20000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_item_sk < 20000)
         ->  Bitmap Index Scan on global_alter_table_index1
               Index Cond: (inv_item_sk < 20000)
(5 rows)

select count(*) from alter_table where INV_ITEM_SK < 20000;
 count 
-------
     9
(1 row)

explain (costs off) select count(*) from alter_table where INV_WAREHOUSE_SK < 10000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_warehouse_sk < 10000)
         ->  Bitmap Index Scan on global_alter_table_index2
               Index Cond: (inv_warehouse_sk < 10000)
(5 rows)

select count(*) from alter_table where INV_WAREHOUSE_SK < 10000;
 count 
-------
     5
(1 row)

explain (costs off) select count(*) from alter_table where INV_WAREHOUSE_SK < 20000;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on alter_table
         Recheck Cond: (inv_warehouse_sk < 20000)
         ->  Bitmap Index Scan on global_alter_table_index2
               Index Cond: (inv_warehouse_sk < 20000)
(5 rows)

select count(*) from alter_table where INV_WAREHOUSE_SK < 20000;
 count 
-------
     9
(1 row)

--clean
drop index if exists local_exchange_table_index1;
drop table if exists exchange_table;
drop index if exists local_alter_table_index1;
drop index if exists global_alter_table_index1;
drop index if exists global_alter_table_index2;
drop table if exists alter_table;
-- 15. Ustore
--a.partition name
create table test_exchange_func_ord (a int) WITH (STORAGE_TYPE = USTORE, init_td=32);
create table test_exchange_func_ht (a int) WITH (STORAGE_TYPE = USTORE, init_td=32)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_func_ord values (3);
insert into test_exchange_func_ht values (2);
select * from test_exchange_func_ord;
 a 
---
 3
(1 row)

select * from test_exchange_func_ht;
 a 
---
 2
(1 row)

select * from test_exchange_func_ht partition (p1);
 a 
---
(0 rows)

select * from test_exchange_func_ht partition (p2);
 a 
---
 2
(1 row)

alter table test_exchange_func_ht exchange partition (p1) with table test_exchange_func_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ord;
 a 
---
(0 rows)

select * from test_exchange_func_ht;
 a 
---
 3
 2
(2 rows)

select * from test_exchange_func_ht partition (p1);
 a 
---
 3
(1 row)

select * from test_exchange_func_ht partition (p2);
 a 
---
 2
(1 row)

insert into test_exchange_func_ord values (4);
insert into test_exchange_func_ht values (3);
select * from test_exchange_func_ord order by 1;
 a 
---
 4
(1 row)

select * from test_exchange_func_ht order by 1;
 a 
---
 2
 3
 3
(3 rows)

select * from test_exchange_func_ht partition(p1) order by 1;
 a 
---
 3
 3
(2 rows)

select * from test_exchange_func_ht partition(p2) order by 1;
 a 
---
 2
(1 row)

drop table test_exchange_func_ord;
drop table test_exchange_func_ht;
--b.partition for
create table test_exchange_func_ord (a int) WITH (STORAGE_TYPE = USTORE, init_td=32);
create table test_exchange_func_ht (a int) WITH (STORAGE_TYPE = USTORE, init_td=32)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2
);
insert into test_exchange_func_ord values (3);
insert into test_exchange_func_ht values (2);
select * from test_exchange_func_ord;
 a 
---
 3
(1 row)

select * from test_exchange_func_ht;
 a 
---
 2
(1 row)

select * from test_exchange_func_ht partition (p1);
 a 
---
(0 rows)

select * from test_exchange_func_ht partition (p2);
 a 
---
 2
(1 row)

alter table test_exchange_func_ht exchange partition for (3) with table test_exchange_func_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ord;
 a 
---
(0 rows)

select * from test_exchange_func_ht order by a ;
 a 
---
 2
 3
(2 rows)

select * from test_exchange_func_ht partition (p1);
 a 
---
 3
(1 row)

select * from test_exchange_func_ht partition (p2);
 a 
---
 2
(1 row)

drop table test_exchange_func_ord;
drop table test_exchange_func_ht;
-- 16. ROW LEVEL SECURITY POLICY
create table test_exchange_row_enable_ord (a int, b int, c int);
create table test_exchange_row_enable_ht (a int, b int, c int)
partition by hash(a)
(
	PARTITION p1,
	PARTITION p2,
	PARTITION p3
);
insert into test_exchange_row_enable_ord select generate_series(3,4);
insert into test_exchange_row_enable_ht select generate_series(1,5);
--打开行访问控制开关
ALTER TABLE test_exchange_row_enable_ord ENABLE ROW LEVEL SECURITY;
----创建行访问控制策略，当前用户只能查看用户自身的数据
CREATE ROW LEVEL SECURITY POLICY test_exchange_row_enable_ord_rls ON test_exchange_row_enable_ord USING(a = CURRENT_USER);
--exchange 
alter table test_exchange_row_enable_ht exchange partition (p2) with table test_exchange_row_enable_ord;
ERROR:  ALTER TABLE EXCHANGE not support with row level security policy table
drop table test_exchange_row_enable_ord;
drop table test_exchange_row_enable_ht;
-- 17. test build hashpartition map
create table test_exchange_ord (a int, b int, c int);
create table test_exchange_func_ht (a int, b int, c int)
partition by hash(a)
(
        PARTITION p1,
        PARTITION p2,
        PARTITION p3,
        PARTITION p4,
        PARTITION p5,
        PARTITION p6,
        PARTITION p7,
        PARTITION p8,
        PARTITION p9
);
alter table test_exchange_func_ht exchange partition (p3) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
alter table test_exchange_func_ht exchange partition (p5) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
alter table test_exchange_func_ht exchange partition (p7) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
alter table test_exchange_func_ht exchange partition (p9) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht;
 a | b | c 
---+---+---
(0 rows)

drop table test_exchange_ord;
drop table test_exchange_func_ht;
create table test_exchange_ord (a int, b int, c int);
create table test_exchange_func_ht (a int, b int, c int)
partition by hash(a)
(
        PARTITION p1,
        PARTITION p2,
        PARTITION p3,
        PARTITION p4,
        PARTITION p5,
        PARTITION p6,
        PARTITION p7,
        PARTITION p8,
        PARTITION p9
);
insert into test_exchange_func_ht values(generate_series(1,100));
select * from test_exchange_func_ht partition(p1);
 a  | b | c 
----+---+---
  9 |   |  
 10 |   |  
 16 |   |  
 23 |   |  
 31 |   |  
 54 |   |  
 57 |   |  
 60 |   |  
 79 |   |  
 81 |   |  
 82 |   |  
 83 |   |  
 97 |   |  
(13 rows)

alter table test_exchange_func_ht exchange partition for (9) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p1);
 a | b | c 
---+---+---
(0 rows)

alter table test_exchange_func_ht exchange partition for (9) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p1);
 a  | b | c 
----+---+---
  9 |   |  
 10 |   |  
 16 |   |  
 23 |   |  
 31 |   |  
 54 |   |  
 57 |   |  
 60 |   |  
 79 |   |  
 81 |   |  
 82 |   |  
 83 |   |  
 97 |   |  
(13 rows)

select * from test_exchange_func_ht partition(p5);
  a  | b | c 
-----+---+---
   2 |   |  
  12 |   |  
  14 |   |  
  15 |   |  
  25 |   |  
  66 |   |  
  75 |   |  
  76 |   |  
  87 |   |  
  94 |   |  
  96 |   |  
 100 |   |  
(12 rows)

alter table test_exchange_func_ht exchange partition for (2) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p5);
 a | b | c 
---+---+---
(0 rows)

alter table test_exchange_func_ht exchange partition for (2) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p5);
  a  | b | c 
-----+---+---
   2 |   |  
  12 |   |  
  14 |   |  
  15 |   |  
  25 |   |  
  66 |   |  
  75 |   |  
  76 |   |  
  87 |   |  
  94 |   |  
  96 |   |  
 100 |   |  
(12 rows)

select * from test_exchange_func_ht partition(p9);
 a  | b | c 
----+---+---
 17 |   |  
 19 |   |  
 21 |   |  
 22 |   |  
 26 |   |  
 36 |   |  
 37 |   |  
 42 |   |  
 44 |   |  
 67 |   |  
 68 |   |  
 70 |   |  
 78 |   |  
 84 |   |  
 95 |   |  
(15 rows)

alter table test_exchange_func_ht exchange partition for (17) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p9);
 a | b | c 
---+---+---
(0 rows)

alter table test_exchange_func_ht exchange partition for (17) with table test_exchange_ord;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_exchange_func_ht partition(p9);
 a  | b | c 
----+---+---
 17 |   |  
 19 |   |  
 21 |   |  
 22 |   |  
 26 |   |  
 36 |   |  
 37 |   |  
 42 |   |  
 44 |   |  
 67 |   |  
 68 |   |  
 70 |   |  
 78 |   |  
 84 |   |  
 95 |   |  
(15 rows)

drop table test_exchange_ord;
drop table test_exchange_func_ht;
